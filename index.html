<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <title>TeaTrade Exchange | Global Tea Market Terminal</title>
    <link rel="icon" type="image/png" href="images/favicon-nb.png">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Supabase Client -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <style>
        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #111827;
            --bg-tertiary: #1a2332;
            --bg-card: #151d2b;
            --border: #2d3a4f;
            --border-light: #374357;
            --text-primary: #e5e7eb;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --accent-blue: #1a73e8;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-orange: #f59e0b;
            --accent-purple: #8b5cf6;
            --ticker-bg: #0f1419;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            overflow-x: hidden;
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            width: 100%;
            max-width: 100vw;
        }

        /* Top Bar */
        .top-bar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 0 20px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: var(--accent-blue);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
        }

        .logo-text {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 16px;
            letter-spacing: -0.5px;
        }

        .logo-text span {
            color: var(--accent-blue);
        }

        .nav-links {
            display: flex;
            gap: 24px;
            margin-left: auto;
            margin-right: 32px;
        }

        .nav-links a {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            transition: color 0.2s;
        }

        .nav-links a:hover, .nav-links a.active {
            color: var(--text-primary);
        }

        .user-section {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .market-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--accent-green);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.closed {
            background: var(--accent-red);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Ticker Strip */
        .ticker-strip {
            background: var(--ticker-bg);
            border-bottom: 1px solid var(--border);
            overflow: hidden;
            height: 36px;
        }

        .ticker-track {
            display: flex;
            animation: scroll 25s linear infinite;
            height: 100%;
            align-items: center;
        }

        @keyframes scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .ticker-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 24px;
            white-space: nowrap;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }

        .ticker-symbol {
            color: var(--text-primary);
            font-weight: 600;
        }

        .ticker-price {
            color: var(--text-secondary);
        }

        .ticker-change.up {
            color: var(--accent-green);
        }

        .ticker-change.down {
            color: var(--accent-red);
        }

        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: minmax(220px, 280px) 1fr minmax(280px, 320px);
            gap: 1px;
            background: var(--border);
            min-height: calc(100vh - 85px);
        }

        .main-grid > * {
            min-height: 100%;
        }

        /* Sidebar */
        .sidebar {
            background: var(--bg-secondary);
            padding: 16px;
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 85px);
            overflow: hidden;
        }
        
        .sidebar-section:last-child {
            flex: 1;
            margin-bottom: 0;
            min-height: 0;
        }

        .sidebar-section {
            margin-bottom: 24px;
        }

        .sidebar-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 12px;
            font-weight: 600;
        }

        .watchlist-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background: var(--bg-card);
            border-radius: 6px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .watchlist-item:hover {
            border-color: var(--border-light);
            background: var(--bg-tertiary);
        }

        .watchlist-name {
            font-weight: 500;
            font-size: 13px;
        }

        .watchlist-grade {
            font-size: 11px;
            color: var(--text-muted);
        }

        .watchlist-price {
            text-align: right;
        }

        .watchlist-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            font-weight: 600;
        }

        .watchlist-change {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }

        .up { color: var(--accent-green); font-weight: 600; }
        .down { color: var(--accent-red); font-weight: 600; }

        /* IB Chat Section */
        .chat-section {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            min-height: 200px;
            border-top: 1px solid var(--border);
            margin-top: 16px;
            position: relative;
        }
        
        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            flex-shrink: 0;
        }
        
        .chat-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .chat-notification-badge {
            display: none;
            position: fixed;
            bottom: 24px;
            left: 24px;
            background: var(--accent-blue);
            color: white;
            padding: 10px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            z-index: 10000;
            box-shadow: 0 4px 16px rgba(26, 115, 232, 0.5);
            animation: chatBadgePulse 2s ease-in-out infinite;
            transition: transform 0.2s, background 0.2s;
            width: fit-content;
            max-width: 100px;
            height: auto;
            max-height: 44px;
        }
        
        .chat-notification-badge:hover {
            background: #2563eb;
            transform: scale(1.05);
        }
        
        .chat-notification-badge.visible {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        .chat-notification-badge svg {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }
        
        .chat-notification-badge-text {
            display: none;
        }
        
        .chat-notification-count {
            background: white;
            color: var(--accent-blue);
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 700;
            min-width: 18px;
            text-align: center;
            flex-shrink: 0;
        }
        
        @keyframes chatBadgePulse {
            0%, 100% { box-shadow: 0 4px 12px rgba(26, 115, 232, 0.4); }
            50% { box-shadow: 0 4px 20px rgba(26, 115, 232, 0.6); }
        }
        
        .chat-online {
            font-size: 10px;
            color: var(--accent-green);
            font-weight: 400;
            text-transform: none;
            letter-spacing: 0;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--border-light) var(--bg-tertiary);
            padding-right: 4px;
            padding-bottom: 8px;
            min-height: 0;
        }
        
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }
        
        .chat-messages::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }
        
        .chat-messages::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 3px;
        }
        
        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        .chat-message {
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
        }
        
        .chat-message:last-child {
            border-bottom: none;
        }
        
        .chat-message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .chat-sender {
            font-size: 11px;
            font-weight: 600;
            color: var(--accent-blue);
        }
        
        .chat-sender.system {
            color: var(--accent-orange);
        }
        
        .chat-time {
            font-size: 10px;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .chat-text {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
        }
        
        .chat-input-container {
            margin-top: auto;
            padding: 8px 6px 0 0;
            display: flex;
            gap: 4px;
            align-items: center;
            flex-shrink: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            position: sticky;
            bottom: 0;
        }
        
        .chat-input {
            flex: 1;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0 10px;
            height: 28px;
            font-size: 12px;
            color: var(--text-primary);
            outline: none;
            box-sizing: border-box;
            max-width: calc(100% - 80px);
        }
        
        .chat-input:focus {
            border-color: var(--accent-blue);
        }
        
        .chat-input::placeholder {
            color: var(--text-muted);
        }
        
        .chat-send {
            background: var(--accent-blue);
            border: none;
            border-radius: 4px;
            padding: 0 12px;
            height: 28px;
            cursor: pointer;
            color: white;
            font-size: 11px;
            font-weight: 600;
            display: flex;
            align-items: center;
            box-sizing: border-box;
        }
        
        .chat-send:hover {
            background: #1557b0;
        }
        
        .chat-blast {
            background: var(--accent-orange);
            border: none;
            border-radius: 4px;
            width: 28px;
            height: 28px;
            padding: 0;
            cursor: pointer;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            box-sizing: border-box;
        }
        
        .chat-blast svg {
            width: 14px;
            height: 14px;
        }
        
        .chat-blast:hover {
            background: #d97706;
        }
        
        /* Own message styling (must come before private for cascade) */
        .chat-message.own {
            background: rgba(26, 115, 232, 0.1);
            border-left: 2px solid var(--accent-blue);
            padding-left: 8px;
            margin-left: -8px;
        }
        
        /* Private message styling - higher priority */
        .chat-message.private,
        .chat-message.own.private {
            background: rgba(147, 51, 234, 0.15) !important;
            border-left: 2px solid var(--accent-purple, #9333ea) !important;
            padding-left: 8px;
            margin-left: -8px;
        }
        
        .chat-message.private .chat-sender,
        .chat-message.own.private .chat-sender {
            color: var(--accent-purple, #9333ea) !important;
        }
        
        .chat-message.private .chat-text::before,
        .chat-message.own.private .chat-text::before {
            content: 'ðŸ”’ ';
            font-size: 10px;
        }
        
        .chat-sender.dm-target {
            color: var(--accent-purple, #9333ea);
        }
        
        .chat-sender.dm-target::before {
            content: 'â†’ ';
        }

        /* Center Content */
        .center-content {
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            min-height: 100%;
        }

        /* Chart Section */
        .chart-section {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            transition: opacity 0.15s ease, transform 0.15s ease;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .chart-title {
            display: flex;
            align-items: center;
            gap: 10px;
            white-space: nowrap;
        }

        .chart-title h2 {
            font-size: 22px;
            font-weight: 600;
            margin: 0;
        }

        .chart-badge {
            padding: 3px 8px 3px 12px;
            background: var(--accent-blue);
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            position: relative;
            animation: livePulse 2s ease-in-out infinite;
        }
        
        .chart-badge::before {
            content: '';
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            width: 5px;
            height: 5px;
            background: #10b981;
            border-radius: 50%;
            animation: liveDot 1.5s ease-in-out infinite;
        }
        
        @keyframes livePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        @keyframes liveDot {
            0%, 100% { opacity: 1; transform: translateY(-50%) scale(1); }
            50% { opacity: 0.6; transform: translateY(-50%) scale(0.8); }
        }
        
        /* Timeframe Dropdown */
        .timeframe-dropdown {
            position: relative;
        }
        
        .timeframe-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .timeframe-btn:hover {
            border-color: var(--accent-blue);
        }
        
        .timeframe-menu {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 4px 0;
            min-width: 80px;
            z-index: 100;
            display: none;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        }
        
        .timeframe-menu.visible {
            display: block;
        }
        
        .timeframe-item {
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .timeframe-item:hover {
            background: var(--bg-tertiary);
        }
        
        .timeframe-item.active {
            color: var(--accent-blue);
            background: rgba(26, 115, 232, 0.1);
        }

        .chart-stats {
            display: flex;
            gap: 32px;
            margin-top: 8px;
        }

        .chart-stat {
            text-align: left;
        }

        .chart-stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 28px;
            font-weight: 700;
        }

        .chart-stat-label {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .chart-controls {
            display: flex;
            gap: 8px;
        }

        .chart-btn {
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chart-btn:hover, .chart-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .chart-type-toggle {
            display: flex;
            gap: 4px;
            margin-left: 16px;
            padding-left: 16px;
            border-left: 1px solid var(--border);
        }

        .chart-type-btn {
            padding: 6px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .chart-type-btn:hover, .chart-type-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .chart-type-btn svg {
            width: 14px;
            height: 14px;
        }

        /* Studies Dropdown */
        .studies-dropdown {
            position: relative;
            margin-left: 16px;
            padding-left: 16px;
            border-left: 1px solid var(--border);
        }

        .studies-btn {
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .studies-btn:hover {
            background: var(--bg-card);
            border-color: var(--border-light);
        }

        .studies-btn.has-active {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
            color: white;
        }

        .studies-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 0;
            min-width: 180px;
            z-index: 100;
            display: none;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        }

        .studies-menu.visible {
            display: block;
        }

        .studies-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 14px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .studies-item:hover {
            background: var(--bg-tertiary);
        }

        .studies-item-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .studies-color {
            width: 12px;
            height: 3px;
            border-radius: 2px;
        }

        .studies-toggle {
            width: 36px;
            height: 20px;
            background: var(--bg-secondary);
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .studies-toggle.active {
            background: var(--accent-blue);
        }

        .studies-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .studies-toggle.active::after {
            left: 18px;
        }

        /* Price Alert Bell */
        .price-alert-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .price-alert-btn:hover {
            color: var(--accent-orange);
            background: rgba(245, 158, 11, 0.1);
        }

        .price-alert-btn.has-alert {
            color: var(--accent-orange);
        }

        .price-alert-btn svg {
            width: 16px;
            height: 16px;
        }

        /* SL/TP Inputs */
        .sltp-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
            overflow: hidden;
        }

        .sltp-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
            position: relative;
        }

        .sltp-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
        }

        .sltp-label .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .sltp-label .dot.sl {
            background: var(--accent-red);
        }

        .sltp-label .dot.tp {
            background: var(--accent-green);
        }

        .sltp-input {
            padding: 6px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            width: 100%;
            box-sizing: border-box;
            -moz-appearance: textfield;
        }
        
        .sltp-input::-webkit-outer-spin-button,
        .sltp-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .sltp-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .sltp-input-wrapper input {
            padding-right: 28px;
        }
        
        .sltp-arrows {
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 1px;
        }
        
        .sltp-arrow {
            width: 18px;
            height: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border: none;
            border-radius: 2px;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.15s;
            padding: 0;
        }
        
        .sltp-arrow:hover {
            background: var(--accent-blue);
            color: white;
        }
        
        .sltp-arrow svg {
            width: 10px;
            height: 10px;
        }

        .sltp-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .sltp-input::placeholder {
            color: var(--text-muted);
        }

        .chart-container {
            height: 280px;
            background: var(--bg-card);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }
        
        /* RSI Sub-Chart */
        .rsi-chart-container {
            height: 80px;
            background: var(--bg-card);
            border-radius: 8px;
            margin-top: 8px;
            padding: 8px 0;
            position: relative;
        }
        
        .rsi-header {
            position: absolute;
            top: 8px;
            left: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 5;
        }
        
        .rsi-label {
            font-size: 10px;
            font-weight: 600;
            color: #ec4899;
            text-transform: uppercase;
        }
        
        .rsi-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
        }
        
        .rsi-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .rsi-crosshair {
            position: absolute;
            pointer-events: none;
            display: none;
        }
        
        .rsi-crosshair .crosshair-v {
            position: absolute;
            top: 0;
            width: 1px;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
        }
        
        .rsi-crosshair .crosshair-h {
            position: absolute;
            left: 0;
            width: 100%;
            height: 1px;
            background: rgba(255, 255, 255, 0.3);
        }
        
        .rsi-tooltip {
            position: absolute;
            background: rgba(17, 24, 39, 0.95);
            border: 1px solid var(--border-light);
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 10;
            white-space: nowrap;
        }
        
        .rsi-tooltip.visible {
            opacity: 1;
        }
        
        /* Market Depth Heatmap */
        .market-depth-container {
            background: var(--bg-card);
            border-radius: 8px;
            margin-top: 8px;
            padding: 12px;
        }
        
        .market-depth-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .market-depth-title {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .market-depth-ratio {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
        }
        
        .market-depth-bar {
            height: 24px;
            border-radius: 4px;
            display: flex;
            overflow: hidden;
            position: relative;
        }
        
        .depth-bids {
            background: rgba(16, 185, 129, 0.4);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding-left: 8px;
        }
        
        .depth-asks {
            background: rgba(239, 68, 68, 0.4);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 8px;
        }
        
        .depth-label {
            font-size: 10px;
            font-weight: 600;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        .market-depth-levels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 9px;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Watchlist Tabs */
        .watchlist-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
        }
        
        .watchlist-tab {
            flex: 1;
            padding: 6px 8px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            background: var(--bg-card);
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .watchlist-tab:hover {
            color: var(--text-primary);
        }
        
        .watchlist-tab.active {
            background: var(--accent-blue);
            color: white;
        }
        
        /* Macro Indicators */
        .macro-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background: var(--bg-card);
            border-radius: 6px;
            margin-bottom: 6px;
        }
        
        .macro-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .macro-icon {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        
        .macro-icon.currency { background: rgba(59, 130, 246, 0.2); }
        .macro-icon.oil { background: rgba(245, 158, 11, 0.2); }
        .macro-icon.shipping { background: rgba(139, 92, 246, 0.2); }
        .macro-icon.weather { background: rgba(16, 185, 129, 0.2); }
        
        .macro-name {
            font-size: 12px;
            font-weight: 500;
        }
        
        .macro-subtext {
            font-size: 10px;
            color: var(--text-muted);
        }
        
        .macro-value {
            text-align: right;
        }
        
        .macro-price {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            font-weight: 600;
        }
        
        .macro-change {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            display: flex;
            align-items: center;
            gap: 2px;
            justify-content: flex-end;
        }
        
        .macro-impact {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-top: 4px;
            display: inline-block;
        }
        
        .macro-impact.bullish { background: rgba(16, 185, 129, 0.2); color: var(--accent-green); }
        .macro-impact.bearish { background: rgba(239, 68, 68, 0.2); color: var(--accent-red); }
        .macro-impact.neutral { background: rgba(156, 163, 175, 0.2); color: var(--text-muted); }
        
        /* Trade Log */
        .portfolio-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
        }
        
        .portfolio-tab {
            padding: 6px 12px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            background: var(--bg-card);
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .portfolio-tab:hover {
            color: var(--text-primary);
        }
        
        .portfolio-tab.active {
            background: var(--accent-blue);
            color: white;
        }
        
        .trade-log-container {
            display: none;
            overflow-x: auto;
        }
        
        .trade-log-container.active {
            display: block;
        }
        
        .trade-log-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            margin-bottom: 12px;
        }
        
        .trade-stat {
            background: var(--bg-card);
            padding: 8px 4px;
            border-radius: 6px;
            text-align: center;
        }
        
        .trade-stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 600;
        }
        
        .trade-stat-label {
            font-size: 8px;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-top: 2px;
        }
        
        .trade-log-table {
            width: 100%;
            font-size: 10px;
            border-collapse: collapse;
            table-layout: fixed;
        }
        
        .trade-log-table th {
            text-align: left;
            padding: 6px 4px;
            font-size: 8px;
            text-transform: uppercase;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border);
        }
        
        .trade-log-table td {
            padding: 6px 4px;
            border-bottom: 1px solid var(--border);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .trade-log-table tr:hover {
            background: var(--bg-tertiary);
        }
        
        .trade-type-badge {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .trade-type-badge.long { background: rgba(16, 185, 129, 0.2); color: var(--accent-green); }
        .trade-type-badge.short { background: rgba(239, 68, 68, 0.2); color: var(--accent-red); }
        
        /* Command Line */
        .command-line-container {
            position: relative;
            flex: 1;
            max-width: 400px;
            margin: 0 24px;
        }
        
        .command-line {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 12px 8px 36px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            outline: none;
            transition: all 0.2s;
        }
        
        .command-line:focus {
            border-color: var(--accent-blue);
            background: var(--bg-card);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .command-line::placeholder {
            color: var(--text-muted);
        }
        
        .command-line-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            font-size: 12px;
        }
        
        .command-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-top: 4px;
            max-height: 350px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .command-suggestions::-webkit-scrollbar {
            width: 6px;
        }
        
        .command-suggestions::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 3px;
        }
        
        .command-suggestions::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
            transition: background 0.2s;
        }
        
        .command-suggestions::-webkit-scrollbar-thumb:hover {
            background: var(--accent-blue);
        }
        
        .command-suggestions.active {
            display: block;
        }
        
        .search-category {
            padding: 6px 12px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
        }
        
        .command-suggestion {
            padding: 10px 12px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.1s;
            gap: 12px;
        }
        
        .command-suggestion:hover, .command-suggestion.selected {
            background: var(--bg-tertiary);
        }
        
        .search-result-info {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }
        
        .search-result-symbol {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .search-result-symbol .origin {
            color: var(--accent-blue);
        }
        
        .search-result-name {
            font-size: 11px;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .search-result-price {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 12px;
            text-align: right;
        }
        
        .search-result-price.up { color: var(--accent-green); }
        .search-result-price.down { color: var(--accent-red); }
        
        .search-result-actions {
            display: flex;
            gap: 4px;
        }
        
        .search-action-btn {
            padding: 4px 8px;
            font-size: 10px;
            font-weight: 600;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .search-action-btn:hover {
            opacity: 0.8;
        }
        
        .search-action-btn.chart {
            background: var(--accent-blue);
            color: white;
        }
        
        .search-action-btn.buy {
            background: var(--accent-green);
            color: white;
        }
        
        .search-action-btn.sell {
            background: var(--accent-red);
            color: white;
        }
        
        .command-suggestion-cmd {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-blue);
        }
        
        .command-suggestion-desc {
            color: var(--text-muted);
            font-size: 10px;
        }
        
        /* Maximize Functionality */
        .maximize-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .maximize-btn:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
        }
        
        .panel-maximized {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999 !important;
            margin: 0 !important;
            border-radius: 0 !important;
            background: var(--bg-primary) !important;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        body.modal-open {
            overflow: hidden !important;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        /* Trading Hub Layout */
        .trading-hub-container {
            display: none;
            flex: 1;
            overflow: hidden;
            position: relative;
            height: 100%;
        }
        
        .panel-maximized .trading-hub-container {
            display: flex;
            height: 100%;
        }
        
        .panel-maximized .chart-header,
        .panel-maximized .chart-container,
        .panel-maximized .market-depth-section {
            display: none;
        }
        
        .trading-hub-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            padding: 12px;
            gap: 8px;
            position: relative;
            height: 100%;
            overflow: hidden;
        }
        
        .trading-hub-sidebar {
            width: 320px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            margin: 12px 12px 12px 0;
            border-radius: 8px;
            scrollbar-width: thin;
            scrollbar-color: var(--border-light) var(--bg-tertiary);
        }
        
        .trading-hub-sidebar::-webkit-scrollbar {
            width: 6px;
        }
        
        .trading-hub-sidebar::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }
        
        .trading-hub-sidebar::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 3px;
        }
        
        .trading-hub-sidebar::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        /* Trading Hub Trade Panel Styles */
        .trading-hub-sidebar .trade-panel {
            padding: 16px;
        }
        
        .trading-hub-sidebar .trade-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 16px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 4px;
        }
        
        .trading-hub-sidebar .trade-tab {
            flex: 1;
            padding: 10px 16px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .trading-hub-sidebar .trade-tab:hover {
            color: var(--text-primary);
        }
        
        .trading-hub-sidebar .trade-tab.active[data-tab="hub-buy"] {
            background: var(--accent-green);
            color: white;
        }
        
        .trading-hub-sidebar .trade-tab.active[data-tab="hub-sell"] {
            background: var(--accent-red);
            color: white;
        }
        
        .trading-hub-sidebar .trade-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .trading-hub-sidebar .form-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .trading-hub-sidebar .form-group label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .trading-hub-sidebar .form-input {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: 'JetBrains Mono', monospace;
            transition: border-color 0.2s;
        }
        
        .trading-hub-sidebar .form-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        
        .trading-hub-sidebar .quick-amounts {
            display: flex;
            gap: 6px;
            margin-top: 6px;
        }
        
        .trading-hub-sidebar .quick-amounts button {
            flex: 1;
            padding: 6px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .trading-hub-sidebar .quick-amounts button:hover {
            background: var(--bg-card);
            border-color: var(--accent-blue);
            color: var(--text-primary);
        }
        
        .trading-hub-sidebar .order-preview {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 12px;
            margin-top: 4px;
        }
        
        .trading-hub-sidebar .preview-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            padding: 4px 0;
            color: var(--text-secondary);
        }
        
        .trading-hub-sidebar .preview-row span:last-child {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
        }
        
        .trading-hub-sidebar .trade-button {
            width: 100%;
            padding: 14px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
            margin-top: 8px;
        }
        
        .trading-hub-sidebar .trade-button.buy {
            background: var(--accent-green);
            color: white;
        }
        
        .trading-hub-sidebar .trade-button.buy:hover {
            background: #059669;
            transform: translateY(-1px);
        }
        
        .trading-hub-sidebar .trade-button.sell {
            background: var(--accent-red);
            color: white;
        }
        
        .trading-hub-sidebar .trade-button.sell:hover {
            background: #dc2626;
            transform: translateY(-1px);
        }
        
        .trading-hub-chart-area {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            background: var(--bg-card);
            border-radius: 8px;
            overflow: hidden;
            min-height: 350px;
            height: 0; /* Allow flex to control height */
        }
        
        .trading-hub-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        
        .trading-hub-chart-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .trading-hub-chart-title h3 {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
        }
        
        .trading-hub-price {
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            font-weight: 700;
        }
        
        .trading-hub-price.up { color: var(--accent-green); }
        .trading-hub-price.down { color: var(--accent-red); }
        
        .trading-hub-change {
            font-size: 13px;
            font-weight: 500;
        }
        
        .trading-hub-canvas-wrapper {
            flex: 1;
            position: relative;
            min-height: 300px;
            background: #1a1a2e;
            width: 100%;
        }
        
        .trading-hub-canvas-wrapper canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* RSI Sub-chart with Resizer */
        .trading-hub-rsi-section {
            background: var(--bg-card);
            border-radius: 8px;
            overflow: hidden;
            display: none;
            flex-shrink: 0;
        }
        
        .trading-hub-rsi-section.visible {
            display: flex;
            flex-direction: column;
        }
        
        .rsi-resize-handle {
            height: 6px;
            background: var(--bg-secondary);
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
        }
        
        .rsi-resize-handle::before {
            content: '';
            width: 40px;
            height: 3px;
            background: var(--border-light);
            border-radius: 2px;
        }
        
        .rsi-resize-handle:hover {
            background: var(--bg-tertiary);
        }
        
        .trading-hub-rsi-canvas {
            width: 100%;
        }
        
        .trading-hub-rsi-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-secondary);
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        /* Live Trade Log */
        .trading-hub-log {
            background: var(--bg-card);
            border-radius: 8px;
            height: 140px;
            min-height: 140px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .trading-hub-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        
        .trading-hub-log-header h4 {
            font-size: 12px;
            font-weight: 600;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
        }
        
        .trading-hub-log-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            scrollbar-width: thin;
            scrollbar-color: var(--border-light) var(--bg-tertiary);
        }
        
        .trading-hub-log-content::-webkit-scrollbar {
            width: 6px;
        }
        
        .trading-hub-log-content::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }
        
        .trading-hub-log-content::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 3px;
        }
        
        .trading-hub-log-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        .trade-log-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 8px;
            font-size: 11px;
            border-bottom: 1px solid var(--border);
        }
        
        .trade-log-item:last-child {
            border-bottom: none;
        }
        
        .trade-log-time {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-muted);
            font-size: 10px;
            min-width: 50px;
        }
        
        .trade-log-symbol {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            min-width: 60px;
        }
        
        .trade-log-side {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 700;
            min-width: 35px;
            text-align: center;
        }
        
        .trade-log-side.buy {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }
        
        .trade-log-side.sell {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-red);
        }
        
        .trade-log-qty {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
        }
        
        .trade-log-price {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
            margin-left: auto;
        }
        
        .trading-hub-close-btn {
            position: fixed;
            top: 24px;
            right: 24px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 36px;
            height: 36px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            z-index: 10001;
            transition: all 0.2s;
        }
        
        .trading-hub-close-btn:hover {
            background: var(--accent-red);
            color: white;
            border-color: var(--accent-red);
        }
        
        .panel-maximized .chart-container {
            height: calc(100vh - 200px) !important;
        }
        
        .maximize-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 9998;
        }
        
        .maximize-overlay.active {
            display: block;
        }
        
        /* Flash Quote Board */
        .quote-board-section {
            padding: 0 16px;
            margin-bottom: 16px;
        }
        
        .quote-board {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }
        
        .quote-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .quote-card:hover {
            border-color: var(--border-light);
            transform: translateY(-2px);
        }
        
        .quote-card.selected {
            border-color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.1);
        }
        
        .quote-card.flash-green {
            animation: flashQuoteGreen 0.5s ease;
        }
        
        .quote-card.flash-red {
            animation: flashQuoteRed 0.5s ease;
        }
        
        @keyframes flashQuoteGreen {
            0%, 100% { background: var(--bg-card); }
            50% { background: rgba(16, 185, 129, 0.3); }
        }
        
        @keyframes flashQuoteRed {
            0%, 100% { background: var(--bg-card); }
            50% { background: rgba(239, 68, 68, 0.3); }
        }
        
        .quote-symbol {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 14px;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        
        .quote-price {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 2px;
        }
        
        .quote-change {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 600;
        }
        
        .quote-volume {
            font-size: 9px;
            color: var(--text-muted);
            margin-top: 4px;
        }
        
        /* Quick Quote Modal */
        .quick-quote-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .quick-quote-modal-overlay.active {
            display: flex;
        }
        
        .quick-quote-modal {
            background: var(--bg-secondary);
            border-radius: 12px;
            width: 100%;
            max-width: 900px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        }
        
        .quick-quote-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-card);
        }
        
        .quick-quote-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .quick-quote-symbol {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .quick-quote-name {
            font-size: 12px;
            color: var(--text-muted);
            font-weight: 400;
        }
        
        .quick-quote-price-info {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }
        
        .quick-quote-current-price {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-weight: 600;
        }
        
        .quick-quote-change {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 500;
        }
        
        .quick-quote-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 28px;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
        }
        
        .quick-quote-close:hover {
            color: var(--text-primary);
        }
        
        .quick-quote-body {
            display: grid;
            grid-template-columns: 1fr 260px;
            flex: 1;
            overflow: hidden;
        }
        
        .quick-quote-chart-area {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow: hidden;
        }
        
        .quick-quote-chart {
            flex: 1;
            background: var(--bg-card);
            border-radius: 8px;
            position: relative;
            min-height: 280px;
        }
        
        .quick-quote-chart canvas {
            width: 100%;
            height: 100%;
        }
        
        .quick-quote-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }
        
        .quick-stat {
            background: var(--bg-card);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        
        .quick-stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .quick-stat-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-top: 4px;
            font-weight: 400;
        }
        
        .quick-quote-trade-panel {
            background: var(--bg-card);
            border-left: 1px solid var(--border);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 260px;
            min-width: 260px;
            max-width: 260px;
        }
        
        .quick-trade-type-toggle {
            display: flex;
            gap: 6px;
        }
        
        .quick-trade-type-btn {
            flex: 1;
            padding: 10px;
            font-size: 12px;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .quick-trade-type-btn.buy {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-green);
        }
        
        .quick-trade-type-btn.buy.active {
            background: var(--accent-green);
            color: white;
        }
        
        .quick-trade-type-btn.sell {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-red);
        }
        
        .quick-trade-type-btn.sell.active {
            background: var(--accent-red);
            color: white;
        }
        
        .quick-trade-input-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .quick-trade-input-group label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            font-weight: 500;
        }
        
        .quick-trade-input {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            -webkit-appearance: none;
            -moz-appearance: textfield;
            width: 100%;
            box-sizing: border-box;
        }
        
        .quick-trade-input::-webkit-outer-spin-button,
        .quick-trade-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .quick-trade-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        
        /* Quick Quote Crosshair and Tooltip */
        .qq-crosshair {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }
        
        .qq-crosshair-v, .qq-crosshair-h {
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
        }
        
        .qq-crosshair-v {
            width: 1px;
            top: 0;
            bottom: 0;
        }
        
        .qq-crosshair-h {
            height: 1px;
            left: 0;
            right: 0;
        }
        
        .qq-tooltip {
            display: none;
            position: absolute;
            background: rgba(17, 24, 39, 0.95);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            padding: 10px 12px;
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
            pointer-events: none;
            z-index: 100;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .qq-tooltip-row {
            display: flex;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 4px;
        }
        
        .qq-tooltip-row:last-child {
            margin-bottom: 0;
        }
        
        .qq-tooltip-label {
            color: var(--text-muted);
        }
        
        .qq-tooltip-value {
            font-weight: 500;
        }
        
        .qq-tooltip-value.up { color: var(--accent-green); }
        .qq-tooltip-value.down { color: var(--accent-red); }
        
        /* Hub Chart Crosshair and Tooltip */
        .hub-crosshair {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }
        
        .hub-crosshair-v, .hub-crosshair-h {
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
        }
        
        .hub-crosshair-v {
            width: 1px;
            top: 0;
            bottom: 0;
        }
        
        .hub-crosshair-h {
            height: 1px;
            left: 0;
            right: 0;
        }
        
        .hub-tooltip {
            display: none;
            position: absolute;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 12px 14px;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
            pointer-events: none;
            z-index: 100;
            min-width: 170px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
        
        .hub-tooltip.visible {
            display: block;
        }
        
        .hub-tooltip-date {
            color: var(--text-muted);
            font-size: 11px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border);
        }
        
        .hub-tooltip-row {
            display: flex;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 4px;
        }
        
        .hub-tooltip-row:last-child {
            margin-bottom: 0;
        }
        
        .hub-tooltip-label {
            color: var(--text-muted);
        }
        
        .hub-tooltip-value {
            font-weight: 600;
        }
        
        .hub-tooltip-value.up { color: var(--accent-green); }
        .hub-tooltip-value.down { color: var(--accent-red); }

        .quick-quote-chart {
            position: relative;
        }
        
        .quick-trade-summary {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 12px;
        }
        
        .quick-trade-summary-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .quick-trade-summary-row:last-child {
            margin-bottom: 0;
            padding-top: 8px;
            border-top: 1px solid var(--border);
            font-weight: 600;
        }
        
        .quick-trade-execute {
            padding: 12px;
            font-size: 13px;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .quick-trade-execute.buy {
            background: var(--accent-green);
            color: white;
        }
        
        .quick-trade-execute.sell {
            background: var(--accent-red);
            color: white;
        }
        
        .quick-trade-execute:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        
        /* Quick Quote Chart Toolbar */
        .qq-chart-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-card);
            border-radius: 8px;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .qq-timeframe-selector {
            display: flex;
            gap: 4px;
        }
        
        .qq-tf-btn {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .qq-tf-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .qq-tf-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        
        .qq-indicator-toggle {
            display: flex;
            gap: 6px;
        }
        
        .qq-indicator-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 5px 10px;
            font-size: 10px;
            font-weight: 600;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .qq-indicator-btn:hover {
            background: var(--bg-secondary);
        }
        
        .qq-indicator-btn.active {
            background: var(--bg-secondary);
            border-color: var(--accent-blue);
            color: var(--text-primary);
        }
        
        .indicator-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .indicator-dot.sma { background: #f59e0b; }
        .indicator-dot.ema { background: #8b5cf6; }
        .indicator-dot.bollinger { background: #3b82f6; }
        
        .qq-chart-type-toggle {
            display: flex;
            gap: 4px;
        }
        
        .qq-chart-type-btn {
            padding: 6px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .qq-chart-type-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .qq-chart-type-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        
        /* Open Positions in Modal */
        .qq-open-positions {
            display: none;
        }
        
        .qq-open-positions.has-positions {
            display: block;
            background: var(--bg-card);
            border-radius: 8px;
            padding: 12px;
        }
        
        .qq-positions-header {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        
        .qq-position-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: var(--bg-secondary);
            border-radius: 6px;
            margin-bottom: 6px;
        }
        
        .qq-position-row:last-child {
            margin-bottom: 0;
        }
        
        .qq-position-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .qq-position-side {
            font-size: 10px;
            font-weight: 700;
            padding: 3px 6px;
            border-radius: 3px;
        }
        
        .qq-position-side.buy {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }
        
        .qq-position-side.sell {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-red);
        }
        
        .qq-position-details {
            font-size: 12px;
        }
        
        .qq-position-qty {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
        }
        
        .qq-position-entry {
            font-size: 11px;
            color: var(--text-muted);
        }
        
        .qq-position-pnl {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 13px;
        }
        
        .qq-position-pnl.profit { color: var(--accent-green); }
        .qq-position-pnl.loss { color: var(--accent-red); }
        
        /* SL/TP Section in Modal */
        .qq-sltp-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .qq-sltp-group label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 6px;
        }
        
        .qq-sltp-group .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .qq-sltp-group .dot.sl { background: var(--accent-red); }
        .qq-sltp-group .dot.tp { background: var(--accent-green); }
        
        /* Trade Annotations on Chart */
        .qq-trade-annotations {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }
        
        .qq-trade-annotation {
            position: absolute;
            right: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
        }
        
        .qq-trade-annotation.entry {
            background: rgba(59, 130, 246, 0.9);
            color: white;
        }
        
        .qq-trade-annotation.sl {
            background: rgba(239, 68, 68, 0.9);
            color: white;
        }
        
        .qq-trade-annotation.tp {
            background: rgba(16, 185, 129, 0.9);
            color: white;
        }
        
        /* Price Animation */
        .qq-price-flash {
            animation: priceFlash 0.5s ease;
        }
        
        @keyframes priceFlash {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .qq-price-up {
            animation: priceUp 0.3s ease;
        }
        
        .qq-price-down {
            animation: priceDown 0.3s ease;
        }
        
        @keyframes priceUp {
            0% { background: transparent; }
            50% { background: rgba(16, 185, 129, 0.3); }
            100% { background: transparent; }
        }
        
        @keyframes priceDown {
            0% { background: transparent; }
            50% { background: rgba(239, 68, 68, 0.3); }
            100% { background: transparent; }
        }
        
        @media (max-width: 900px) {
            .quick-quote-body {
                grid-template-columns: 1fr;
            }
            .quick-quote-trade-panel {
                border-left: none;
                border-top: 1px solid var(--border);
            }
            .qq-chart-toolbar {
                flex-direction: column;
                align-items: flex-start;
            }
        }
        
        /* Mobile sticky trade bar - hidden on desktop */
        .qq-mobile-trade-bar {
            display: none;
        }
        
        @media (max-width: 768px) {
            .qq-mobile-trade-bar {
                display: block;
                position: sticky;
                bottom: 0;
                left: 0;
                right: 0;
                padding: 12px 16px;
                padding-bottom: max(12px, env(safe-area-inset-bottom));
                background: var(--bg-card);
                border-top: 1px solid var(--border);
                z-index: 20;
            }
            
            .qq-mobile-trade-btn {
                width: 100%;
                padding: 16px;
                font-size: 16px;
                font-weight: 700;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                color: white;
                transition: opacity 0.2s;
            }
            
            .qq-mobile-trade-btn.buy {
                background: linear-gradient(135deg, #059669, #10b981);
            }
            
            .qq-mobile-trade-btn.sell {
                background: linear-gradient(135deg, #dc2626, #ef4444);
            }
            
            .qq-mobile-trade-btn:active {
                opacity: 0.85;
            }
            
            .qq-mobile-trade-price {
                font-family: 'JetBrains Mono', monospace;
                font-size: 14px;
                opacity: 0.9;
            }
            
            /* Mobile trade form overlay */
            .qq-mobile-trade-form {
                display: none;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: var(--bg-card);
                border-top: 1px solid var(--border);
                border-radius: 16px 16px 0 0;
                padding: 20px 16px;
                padding-bottom: max(20px, env(safe-area-inset-bottom));
                z-index: 10001;
                box-shadow: 0 -8px 30px rgba(0,0,0,0.4);
                max-height: 75vh;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .qq-mobile-trade-form.active {
                display: block;
                animation: slideUp 0.3s ease;
            }
            
            @keyframes slideUp {
                from { transform: translateY(100%); }
                to { transform: translateY(0); }
            }
            
            .qq-mobile-trade-form-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 16px;
            }
            
            .qq-mobile-trade-form-title {
                font-size: 16px;
                font-weight: 700;
                color: var(--text-primary);
            }
            
            .qq-mobile-trade-form-close {
                background: none;
                border: none;
                color: var(--text-muted);
                font-size: 24px;
                cursor: pointer;
                padding: 4px;
            }
            
            .qq-mobile-trade-form .quick-trade-input-group,
            .qq-mobile-trade-form .qq-sltp-section,
            .qq-mobile-trade-form .quick-trade-summary,
            .qq-mobile-trade-form .quick-trade-execute {
                display: flex;
            }
            
            .qq-mobile-trade-form .qq-sltp-section {
                display: grid;
            }
            
            .qq-mobile-trade-form .quick-trade-input-group {
                flex-direction: column;
                gap: 6px;
                margin-bottom: 12px;
            }
            
            .qq-mobile-trade-form .quick-trade-input {
                padding: 14px 12px;
                font-size: 16px;
                border-radius: 10px;
            }
            
            .qq-mobile-trade-form .quick-trade-summary {
                margin: 12px 0;
                border-radius: 10px;
                padding: 14px;
                flex-direction: column;
            }
            
            .qq-mobile-trade-form .quick-trade-execute {
                padding: 16px;
                font-size: 16px;
                border-radius: 10px;
                margin-top: 8px;
            }
            
            /* Overlay behind mobile trade form */
            .qq-mobile-trade-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
            }
            
            .qq-mobile-trade-overlay.active {
                display: block;
            }
        }
        
        /* Multi-Chart Dashboard Modal */
        .multi-chart-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            padding: 20px;
        }
        
        .multi-chart-modal-overlay.active {
            display: flex;
            flex-direction: column;
        }
        
        .multi-chart-modal {
            background: var(--bg-secondary);
            border-radius: 12px;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .multi-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
        }
        
        .multi-chart-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .multi-chart-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .mc-add-chart-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: var(--accent-blue);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .mc-add-chart-btn:hover {
            background: #2563eb;
        }
        
        .multi-chart-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 28px;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
        }
        
        .multi-chart-close:hover {
            color: var(--text-primary);
        }
        
        .multi-chart-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 8px;
            padding: 8px;
            overflow: hidden;
        }
        
        .multi-chart-grid.single {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
        }
        
        .multi-chart-grid.double {
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: 1fr;
        }
        
        .multi-chart-grid.triple {
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
        }
        
        .mc-chart-panel {
            background: var(--bg-card);
            border-radius: 8px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            transition: border-color 0.2s;
        }
        
        .mc-chart-panel:hover {
            border-color: var(--border-light);
        }
        
        .mc-chart-panel.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        
        .mc-empty-placeholder {
            text-align: center;
            color: var(--text-muted);
        }
        
        .mc-empty-placeholder svg {
            margin-bottom: 8px;
            opacity: 0.5;
        }
        
        .mc-empty-placeholder span {
            font-size: 12px;
        }
        
        .mc-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
        }
        
        .mc-panel-symbol {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .mc-panel-symbol-name {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 13px;
        }
        
        .mc-panel-price {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }
        
        .mc-panel-price.up { color: var(--accent-green); }
        .mc-panel-price.down { color: var(--accent-red); }
        
        .mc-panel-actions {
            display: flex;
            gap: 6px;
        }
        
        .mc-panel-btn {
            padding: 4px 8px;
            font-size: 10px;
            font-weight: 600;
            border-radius: 4px;
            border: none;
            cursor: pointer;
        }
        
        .mc-panel-btn.trade {
            background: var(--accent-blue);
            color: white;
        }
        
        .mc-panel-btn.close {
            background: var(--bg-tertiary);
            color: var(--text-muted);
        }
        
        .mc-panel-btn:hover {
            opacity: 0.8;
        }
        
        .mc-panel-chart {
            flex: 1;
            position: relative;
            min-height: 120px;
        }
        
        .mc-panel-chart canvas {
            width: 100%;
            height: 100%;
        }
        
        .mc-resize-handle {
            position: absolute;
            right: 0;
            bottom: 0;
            width: 16px;
            height: 16px;
            cursor: se-resize;
            opacity: 0.3;
            transition: opacity 0.2s;
        }
        
        .mc-resize-handle:hover {
            opacity: 0.7;
        }
        
        .mc-resize-handle svg {
            width: 100%;
            height: 100%;
        }
        
        /* Tea Selector for Multi-Chart */
        .mc-tea-selector {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            width: 280px;
            max-height: 300px;
            z-index: 100;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }
        
        .mc-tea-selector-header {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        
        .mc-tea-selector-list {
            max-height: 220px;
            overflow-y: auto;
        }
        
        .mc-tea-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .mc-tea-option:hover {
            background: var(--bg-tertiary);
        }
        
        .mc-tea-option-symbol {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 12px;
        }
        
        .mc-tea-option-price {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }
        
        @media (max-width: 768px) {
            .multi-chart-grid {
                grid-template-columns: 1fr;
                grid-template-rows: auto;
            }
        }
        
        .studies-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        .chart-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .chart-tooltip {
            position: absolute;
            background: rgba(17, 24, 39, 0.95);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            padding: 10px 12px;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 10;
            min-width: 160px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .chart-tooltip.visible {
            opacity: 1;
        }

        .tooltip-date {
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border);
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
        }

        .tooltip-label {
            color: var(--text-muted);
        }

        .tooltip-value {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
        }

        .tooltip-value.up { color: var(--accent-green); }
        .tooltip-value.down { color: var(--accent-red); }

        .chart-crosshair {
            position: absolute;
            pointer-events: none;
            display: none;
        }

        .crosshair-v {
            position: absolute;
            width: 1px;
            background: rgba(255,255,255,0.2);
            top: 0;
            bottom: 0;
        }

        .crosshair-h {
            position: absolute;
            height: 1px;
            background: rgba(255,255,255,0.2);
            left: 0;
            right: 0;
        }

        /* Auction Data Grid */
        .auction-section {
            flex: 1;
            padding: 20px;
            overflow: auto;
            display: flex;
            flex-direction: column;
        }
        
        .auction-section .table-container {
            flex: 1;
        }
        
        /* Order History Section */
        .order-history-section {
            padding: 20px;
            border-top: 1px solid var(--border);
            background: var(--bg-secondary);
        }
        
        .order-history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .order-history-title {
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .order-count {
            background: var(--accent-blue);
            color: white;
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .order-filter-buttons {
            display: flex;
            gap: 8px;
        }
        
        .order-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .order-table-wrapper {
            max-height: 320px;
            overflow-y: auto;
        }

        .order-table-wrapper::-webkit-scrollbar {
            width: 6px;
        }

        .order-table-wrapper::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }

        .order-table-wrapper::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        .order-table-wrapper::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .pairs-table-wrapper {
            max-height: 760px;
            overflow-y: auto;
        }

        .pairs-table-wrapper::-webkit-scrollbar {
            width: 6px;
        }

        .pairs-table-wrapper::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }

        .pairs-table-wrapper::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        .pairs-table-wrapper::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .auction-table-wrapper {
            max-height: 600px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--border-light) var(--bg-tertiary);
        }

        .auction-table-wrapper::-webkit-scrollbar {
            width: 6px;
        }

        .auction-table-wrapper::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }

        .auction-table-wrapper::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        .auction-table-wrapper::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        .order-table th {
            text-align: left;
            padding: 8px 12px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            position: sticky;
            top: 0;
            background: var(--bg-secondary);
            z-index: 1;
        }

        .order-table th.sortable {
            cursor: pointer;
            user-select: none;
            transition: color 0.2s ease;
        }

        .order-table th.sortable:hover {
            color: var(--text-primary);
        }

        .order-table th.sortable::after {
            content: '';
            display: inline-block;
            margin-left: 4px;
            opacity: 0.3;
        }

        .order-table th.sortable.asc::after {
            content: 'â–²';
            opacity: 1;
            color: var(--accent-blue);
        }

        .order-table th.sortable.desc::after {
            content: 'â–¼';
            opacity: 1;
            color: var(--accent-blue);
        }
        
        /* Sortable data-table headers */
        .data-table th.sortable {
            cursor: pointer;
            user-select: none;
            transition: color 0.2s ease;
        }

        .data-table th.sortable:hover {
            color: var(--text-primary);
        }

        .data-table th.sortable::after {
            content: '';
            display: inline-block;
            margin-left: 4px;
            opacity: 0.3;
        }

        .data-table th.sortable.asc::after {
            content: 'â–²';
            opacity: 1;
            color: var(--accent-blue);
        }

        .data-table th.sortable.desc::after {
            content: 'â–¼';
            opacity: 1;
            color: var(--accent-blue);
        }
        
        .order-table tfoot td {
            padding: 10px 12px;
            border-top: 2px solid var(--border);
            font-weight: 600;
            background: var(--bg-tertiary);
            position: sticky;
            bottom: 0;
            z-index: 1;
        }
        
        .order-table td {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
            color: var(--text-primary);
        }
        
        .order-table tr:hover {
            background: var(--bg-card);
        }
        
        .order-table tr:last-child td {
            border-bottom: none;
        }
        
        .order-table .order-price {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
        }
        
        .order-table td.up {
            color: var(--accent-green);
            font-weight: 600;
        }
        
        .order-table td.down {
            color: var(--accent-red);
            font-weight: 600;
        }
        
        .order-table .order-qty {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
        }
        
        .order-status {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .order-status.filled {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-green);
        }
        
        .order-status.pending {
            background: rgba(251, 191, 36, 0.15);
            color: var(--accent-orange);
        }

        .order-status.closed {
            background: rgba(96, 165, 250, 0.15);
            color: var(--accent-blue);
        }

        .close-position-btn {
            font-size: 11px;
            font-weight: 600;
            padding: 4px 12px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            background: rgba(255, 107, 107, 0.15);
            color: var(--accent-red);
            transition: all 0.2s ease;
        }

        .close-position-btn:hover {
            background: var(--accent-red);
            color: white;
        }

        .close-position-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .order-status.filled {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-green);
        }
        
        .order-status.pending {
            background: rgba(245, 158, 11, 0.15);
            color: var(--accent-orange);
        }
        
        .order-status.partial {
            background: rgba(26, 115, 232, 0.15);
            color: var(--accent-blue);
        }

        .order-side {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .order-side.buy-side {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-green);
        }
        
        .order-side.sell-side {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-red);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .section-filters {
            display: flex;
            gap: 8px;
        }

        .filter-btn {
            padding: 5px 10px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
        }

        .filter-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        /* Market Toggle (Singles/Pairs) */
        .market-toggle {
            display: flex;
            gap: 0;
            margin-right: 16px;
        }

        .toggle-btn {
            padding: 5px 14px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toggle-btn:first-child {
            border-radius: 4px 0 0 4px;
            border-right: none;
        }

        .toggle-btn:last-child {
            border-radius: 0 4px 4px 0;
        }

        .toggle-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .toggle-btn:hover:not(.active) {
            background: var(--bg-tertiary);
        }

        /* Pairs table styles */
        .pair-symbol {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pair-symbol .base {
            color: var(--accent-green);
        }

        .pair-symbol .quote {
            color: var(--accent-red);
        }
        
        .index-badge {
            font-size: 8px;
            font-weight: 700;
            background: var(--accent-purple);
            color: white;
            padding: 2px 4px;
            border-radius: 3px;
            letter-spacing: 0.5px;
        }
        
        .index-pair-row {
            background: rgba(147, 51, 234, 0.05);
        }
        
        .index-pair-row:hover td {
            background: rgba(147, 51, 234, 0.1) !important;
        }
        
        /* Pairs table price cells - no flex, simple display */
        .pairs-price {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 13px;
            white-space: nowrap;
        }
        
        .pairs-price.flash-up {
            animation: flashGreen 1s ease;
        }
        
        .pairs-price.flash-down {
            animation: flashRed 1s ease;
        }

        .pair-ratio {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 14px;
            color: var(--accent-blue);
        }

        .trade-pair-btn {
            padding: 4px 12px;
            font-size: 11px;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .trade-pair-btn.long {
            background: var(--accent-green);
            color: white;
        }

        .trade-pair-btn.short {
            background: var(--accent-red);
            color: white;
            margin-left: 6px;
        }

        .trade-pair-btn:hover {
            opacity: 0.85;
            transform: translateY(-1px);
        }

        /* Pairs Modal */
        .pairs-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .pairs-modal-overlay.active {
            display: flex;
        }

        .pairs-modal {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            width: 420px;
            max-width: 95%;
        }

        .pairs-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .pairs-modal-title {
            font-size: 18px;
            font-weight: 600;
        }

        .pairs-modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 24px;
            cursor: pointer;
        }

        .pairs-modal-pair {
            text-align: center;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .pairs-modal-pair .pair-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .pairs-modal-pair .ratio-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            color: var(--accent-blue);
        }

        .side-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .side-btn {
            flex: 1;
            padding: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .side-btn.long.active {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: white;
        }

        .side-btn.short.active {
            background: var(--accent-red);
            border-color: var(--accent-red);
            color: white;
        }

        .side-btn:hover:not(.active) {
            background: var(--bg-tertiary);
        }

        .leverage-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }

        .leverage-btn {
            flex: 1;
            padding: 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .leverage-btn.active {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
            color: white;
        }

        .leverage-btn:hover:not(.active) {
            background: var(--bg-tertiary);
        }

        .pairs-input-group {
            margin-bottom: 16px;
        }

        .pairs-input-group label {
            display: block;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .pairs-input-group input {
            width: 100%;
            padding: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
        }

        .pairs-summary {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
        }

        .pairs-summary-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 13px;
        }

        .pairs-summary-row .label {
            color: var(--text-muted);
        }

        .pairs-summary-row .value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
        }

        .pairs-summary-row.exposure .value {
            color: var(--accent-orange);
        }

        .pairs-modal-actions {
            display: flex;
            gap: 12px;
        }

        .pairs-modal-actions button {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pairs-modal-actions .cancel-btn {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .pairs-modal-actions .confirm-btn {
            color: white;
            background: var(--accent-blue);
        }

        .pairs-modal-actions .confirm-btn.long {
            background: var(--accent-green);
        }

        .pairs-modal-actions .confirm-btn.short {
            background: var(--accent-red);
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .data-table th {
            text-align: left;
            padding: 10px 12px;
            background: var(--bg-secondary);
            color: var(--text-muted);
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .data-table td {
            padding: 12px;
            border-bottom: 1px solid var(--border);
        }

        .data-table tr:hover td {
            background: var(--bg-tertiary);
        }

        .grade-badge {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 12px;
            padding: 3px 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            display: inline-block;
        }

        .auction-center {
            color: var(--accent-blue);
            font-weight: 500;
        }

        .price-cell {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 100px;
        }
        
        .price-cell span {
            flex: 1;
        }
        
        .price-cell .price-alert-btn {
            opacity: 0.4;
            transition: opacity 0.2s;
        }
        
        .price-cell:hover .price-alert-btn {
            opacity: 1;
        }
        
        .price-cell .price-alert-btn.has-alert {
            opacity: 1;
            color: var(--accent-orange);
        }

        .price-cell.up {
            color: var(--accent-green);
        }

        .price-cell.down {
            color: var(--accent-red);
        }

        .price-cell.flash-up {
            animation: flashGreen 1s ease;
        }

        .price-cell.flash-down {
            animation: flashRed 1s ease;
        }

        @keyframes flashGreen {
            0% { background: rgba(0, 212, 170, 0.5); }
            100% { background: transparent; }
        }

        @keyframes flashRed {
            0% { background: rgba(255, 107, 107, 0.5); }
            100% { background: transparent; }
        }

        .volume-bar {
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 4px;
        }

        .volume-fill {
            height: 100%;
            background: var(--accent-blue);
            border-radius: 2px;
        }

        /* Right Panel */
        .right-panel {
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            min-height: 100%;
            overflow: hidden;
            max-width: 320px;
        }

        .panel-section {
            padding: 16px;
            border-bottom: 1px solid var(--border);
            overflow: hidden;
        }
        
        .panel-section:last-child {
            flex: 1;
            border-bottom: none;
        }

        .panel-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 12px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .live-badge {
            display: flex;
            align-items: center;
            gap: 4px;
            color: var(--accent-green);
            font-size: 10px;
        }

        .live-badge::before {
            content: '';
            width: 6px;
            height: 6px;
            background: var(--accent-green);
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        .news-feed {
            max-height: 300px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--border-light) var(--bg-tertiary);
        }

        .news-feed::-webkit-scrollbar {
            width: 6px;
        }

        .news-feed::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }

        .news-feed::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 3px;
        }

        .news-feed::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .news-item {
            padding: 12px 0;
            border-bottom: 1px solid var(--border);
        }

        .news-item:last-child {
            border-bottom: none;
        }

        .news-time {
            font-size: 10px;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }

        .news-headline {
            font-size: 13px;
            line-height: 1.4;
            margin-top: 4px;
        }

        .news-tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            margin-right: 6px;
        }

        .news-tag { background: var(--accent-blue); color: white; }

        /* Order Book / Depth of Market */
        .order-book-section {
            position: relative;
            overflow: hidden;
        }

        .order-book-container {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            display: flex;
            flex-direction: column;
        }

        .ob-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            padding: 6px 10px;
            position: relative;
            z-index: 1;
            cursor: pointer;
            transition: background 0.15s;
            overflow: hidden;
        }
        
        .ob-row:hover { background: rgba(255,255,255,0.03); }
        
        .ob-row > span {
            position: relative;
            z-index: 2;
        }

        .ob-header {
            color: var(--text-muted);
            font-size: 10px;
            border-bottom: 1px solid var(--border);
            margin-bottom: 4px;
            cursor: default;
        }

        .ob-header:hover { background: transparent; }

        .ob-price-up { color: var(--accent-green); font-weight: 500; }
        .ob-price-down { color: var(--accent-red); font-weight: 500; }
        
        .depth-bar {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            z-index: 0;
            opacity: 0.3;
            pointer-events: none;
        }

        .ask-bar { 
            background-color: var(--accent-red);
        }
        .bid-bar { 
            background-color: var(--accent-green);
        }

        .ob-spread {
            text-align: center;
            padding: 10px 0;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
            margin: 4px 0;
            background: rgba(255,255,255,0.02);
        }

        .ob-spread-label {
            font-size: 10px;
            color: var(--text-muted);
        }

        .ob-spread-price { 
            font-size: 16px; 
            font-weight: 700; 
            color: var(--text-primary); 
            margin-top: 2px;
        }

        .ob-blur-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 55%;
            background: linear-gradient(to bottom, rgba(10,14,23,0) 0%, rgba(10,14,23,0.9) 35%, rgba(10,14,23,1) 100%);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 20px;
            z-index: 10;
            pointer-events: none;
        }
        
        .ob-lock-content {
            text-align: center;
            pointer-events: auto;
        }

        .ob-lock-icon {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-light);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 8px;
            color: var(--text-muted);
        }

        .ob-lock-icon svg {
            width: 14px;
            height: 14px;
        }
        
        .ob-lock-content h4 { 
            color: var(--text-primary); 
            margin: 0 0 4px; 
            font-size: 12px;
            font-weight: 600;
        }

        .ob-lock-content p { 
            color: var(--text-muted); 
            font-size: 11px; 
            margin: 0 0 12px;
            max-width: 200px;
        }
        
        .ob-btn-access {
            background: var(--accent-blue);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        .ob-btn-access:hover { background: #1557b0; }

        /* Top Movers */
        .movers-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .mover-card {
            background: var(--bg-card);
            border-radius: 6px;
            padding: 12px;
        }

        .mover-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .mover-name {
            font-weight: 600;
            font-size: 13px;
        }

        .mover-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: 700;
            margin-top: 4px;
        }

        /* Auction Calendar */
        .calendar-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 0;
            border-bottom: 1px solid var(--border);
        }

        .calendar-date {
            width: 48px;
            text-align: center;
            padding: 8px;
            background: var(--bg-card);
            border-radius: 6px;
        }

        .calendar-day {
            font-size: 18px;
            font-weight: 700;
        }

        .calendar-month {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .calendar-info {
            flex: 1;
        }

        .calendar-name {
            font-weight: 500;
            font-size: 13px;
        }

        .calendar-center {
            font-size: 11px;
            color: var(--text-muted);
        }

        .calendar-status {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
        }

        .calendar-status.live {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
        }

        .calendar-status.upcoming {
            background: rgba(26, 115, 232, 0.2);
            color: var(--accent-blue);
        }

        /* Market Summary Cards */
        .market-cards {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1px;
            background: var(--border);
            border-bottom: 1px solid var(--border);
        }

        .market-card {
            background: var(--bg-secondary);
            padding: 16px 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .market-card:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .market-card:active {
            transform: translateY(0);
        }

        .market-card.active {
            border-color: var(--accent-primary);
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(245, 158, 11, 0.05) 100%);
        }

        .market-card-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .market-card-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-weight: 700;
            margin-top: 4px;
        }

        .market-card-change {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            margin-top: 4px;
        }

        /* Spark line placeholder */


        /* Bottom Stats Bar */
        .bottom-bar {
            background: var(--ticker-bg);
            border-top: 1px solid var(--border);
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }

        .bottom-stat {
            display: flex;
            gap: 24px;
        }

        .bottom-stat span {
            color: var(--text-secondary);
        }

        /* Responsive */
        
        /* Smaller laptops (1366px-1440px screens) */
        @media (max-width: 1440px) {
            .main-grid {
                grid-template-columns: minmax(200px, 240px) 1fr minmax(260px, 300px);
            }
            .sidebar {
                padding: 12px;
            }
            .right-panel {
                padding: 12px;
            }
            .market-cards {
                gap: 8px;
            }
            .market-card {
                padding: 12px;
            }
            .quote-board {
                gap: 6px;
            }
            .quote-card {
                padding: 10px;
            }
            .top-bar {
                padding: 0 12px;
            }
            .nav-links {
                gap: 16px;
                margin-right: 20px;
            }
            .nav-links a {
                font-size: 12px;
            }
            .command-line-container {
                max-width: 280px;
            }
            .command-line-input {
                font-size: 12px;
            }
            .ticker-strip {
                font-size: 11px;
            }
        }
        
        /* Small laptops / tablets (1200px-1366px) */
        @media (max-width: 1366px) {
            .main-grid {
                grid-template-columns: minmax(180px, 220px) 1fr minmax(240px, 280px);
            }
            .sidebar-title {
                font-size: 10px;
            }
            .watchlist-symbol {
                font-size: 11px;
            }
            .panel-title {
                font-size: 12px;
            }
            .trade-panel {
                padding: 12px;
            }
            .orders-table th,
            .orders-table td {
                padding: 8px 6px;
                font-size: 10px;
            }
            .nav-links {
                gap: 12px;
                margin-right: 16px;
            }
            .command-line-container {
                max-width: 240px;
            }
            .market-card-value {
                font-size: 1.2rem;
            }
            .chart-header {
                padding: 10px;
            }
            .bottom-bar {
                padding: 6px 12px;
                font-size: 10px;
            }
        }
        
        /* Hide left sidebar first, keep right panel */
        @media (max-width: 1280px) {
            .main-grid {
                grid-template-columns: 1fr minmax(260px, 300px);
            }
            .sidebar {
                display: none;
            }
            /* Show sidebar when mobile menu is active */
            .sidebar.mobile-open {
                display: flex;
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                width: 280px;
                z-index: 9999;
                box-shadow: 4px 0 20px rgba(0,0,0,0.5);
                animation: slideInLeft 0.25s ease;
            }
            .mobile-menu-btn {
                display: flex;
                align-items: center;
            }
        }
        
        /* Hide both sidebars */
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            .sidebar, .right-panel {
                display: none;
            }
            /* Show sidebar when mobile menu is active */
            .sidebar.mobile-open {
                display: flex;
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                width: 280px;
                z-index: 9999;
                box-shadow: 4px 0 20px rgba(0,0,0,0.5);
                animation: slideInLeft 0.25s ease;
            }
            .market-cards {
                grid-template-columns: repeat(2, 1fr);
            }
            .quote-board {
                grid-template-columns: repeat(5, 1fr);
            }
        }
        
        @keyframes slideInLeft {
            from {
                transform: translateX(-100%);
            }
            to {
                transform: translateX(0);
            }
        }
        
        /* Mobile Menu Hamburger Button */
        .mobile-menu-btn {
            display: none;
            background: transparent;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            padding: 8px;
            margin-right: 8px;
        }
        
        .mobile-menu-btn svg {
            width: 24px;
            height: 24px;
        }
        
        @media (max-width: 1200px) {
            .mobile-menu-btn {
                display: flex;
                align-items: center;
            }
        }
        
        /* Mobile overlay when sidebar is open */
        .mobile-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 9998;
        }
        
        .mobile-overlay.active {
            display: block;
        }
        
        /* Mobile close button for sidebar */
        .mobile-sidebar-header {
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            border-bottom: 1px solid var(--border);
            margin: -16px -16px 16px -16px;
        }
        
        @media (max-width: 1200px) {
            .sidebar.mobile-open .mobile-sidebar-header {
                display: flex;
            }
        }
        
        .mobile-close-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
        }

        /* Mobile Styles */
        @media (max-width: 768px) {
            /* Prevent any overflow */
            html, body {
                overflow-x: hidden;
                width: 100%;
                max-width: 100vw;
            }
            
            /* Hide ticker strip and bottom bar on mobile */
            .ticker-strip {
                display: none;
            }
            
            .bottom-bar {
                display: none;
            }
            
            /* Market Cards - horizontal scroll */
            .market-cards {
                display: flex;
                flex-wrap: nowrap;
                overflow-x: auto;
                gap: 10px;
                padding: 10px;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .market-cards::-webkit-scrollbar {
                display: none;
            }
            .market-card {
                flex: 0 0 auto;
                min-width: 140px;
                padding: 12px;
            }
            .market-card-label {
                font-size: 9px;
            }
            .market-card-value {
                font-size: 1.1rem;
            }
            .market-card-change {
                font-size: 10px;
            }
            
            /* Quote board - horizontal scroll */
            .quote-board {
                display: flex;
                flex-wrap: nowrap;
                overflow-x: auto;
                gap: 8px;
                padding: 10px;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .quote-board::-webkit-scrollbar {
                display: none;
            }
            .quote-card {
                flex: 0 0 auto;
                min-width: 90px;
                padding: 10px;
            }
            .quote-symbol {
                font-size: 11px;
            }
            .quote-price {
                font-size: 13px;
            }
            .quote-change {
                font-size: 10px;
            }

            /* Top Bar */
            .top-bar {
                padding: 0 10px;
                height: 44px;
            }
            .logo-text {
                display: none;
            }
            .nav-links {
                display: none;
            }
            .command-line-container {
                display: none;
            }
            .user-section .market-status span:not(.status-dot) {
                display: none;
            }
            .user-section .market-status {
                gap: 0;
                padding: 0 6px;
            }
            .user-balance {
                flex-direction: row;
                gap: 4px;
                padding: 4px 8px;
                background: var(--bg-tertiary);
                border-radius: 4px;
            }
            .user-balance-label {
                display: none;
            }
            .user-balance-amount {
                font-size: 12px;
            }
            .user-menu {
                gap: 6px;
            }

            /* Main content - full width */
            .center-content {
                padding: 0;
                width: 100%;
                max-width: 100vw;
                overflow-x: hidden;
            }
            
            /* Chart section */
            .chart-section {
                padding: 12px;
                margin: 0;
                border-radius: 0;
            }
            .chart-header {
                flex-direction: column;
                gap: 10px;
            }
            .chart-title h2 {
                font-size: 1rem;
            }
            .chart-badge {
                font-size: 9px;
                padding: 2px 6px;
            }
            .chart-stats {
                display: flex;
                gap: 12px;
                flex-wrap: wrap;
            }
            .chart-stat-value {
                font-size: 0.9rem !important;
            }
            .chart-stat-label {
                font-size: 8px;
            }
            .chart-controls {
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
                width: 100%;
            }
            .chart-btn {
                padding: 5px 8px;
                font-size: 10px;
            }
            .chart-container {
                height: 200px;
            }
            
            /* Market depth */
            .market-depth {
                padding: 10px;
            }

            /* Auction Section */
            .auction-section {
                padding: 10px;
                overflow-x: hidden;
            }
            .section-header {
                flex-direction: column;
                gap: 8px;
                align-items: flex-start;
            }
            .section-title {
                font-size: 11px;
            }
            .section-filters {
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
            }
            .filter-btn, .toggle-btn {
                padding: 4px 8px;
                font-size: 10px;
            }
            
            /* Auction table - horizontal scroll wrapper */
            .auction-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                max-height: none;
            }
            .data-table {
                min-width: 600px;
            }
            .data-table th, .data-table td {
                padding: 8px 6px;
                font-size: 11px;
                white-space: nowrap;
            }
            .grade-badge {
                padding: 2px 4px;
                font-size: 9px;
            }
            
            /* Order history */
            .order-history-section {
                padding: 10px;
            }
            .order-table-wrapper {
                overflow-x: auto;
            }
            .order-table {
                min-width: 500px;
            }
            
            /* Login button mobile */
            .login-btn {
                padding: 6px 12px;
                font-size: 11px;
            }
            
            /* =============================================
               TRADING212-STYLE MOBILE QUICK QUOTE MODAL
               ============================================= */
            
            /* Full-screen takeover on mobile */
            .quick-quote-modal-overlay {
                padding: 0;
                align-items: stretch;
                background: var(--bg-primary);
            }
            
            .quick-quote-modal {
                max-width: 100%;
                max-height: 100%;
                height: 100%;
                border-radius: 0;
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
            }
            
            /* Header - Trading212 style: symbol dropdown + icons */
            .quick-quote-header {
                padding: 12px 16px;
                flex-wrap: nowrap;
                gap: 8px;
                position: sticky;
                top: 0;
                z-index: 10;
                background: var(--bg-card);
            }
            
            .quick-quote-title {
                flex-direction: column;
                gap: 2px;
                flex: 1;
                min-width: 0;
            }
            
            .quick-quote-symbol {
                font-size: 13px;
            }
            
            .quick-quote-name {
                font-size: 11px;
            }
            
            .quick-quote-price-info {
                flex-direction: column;
                align-items: flex-end;
                gap: 2px;
            }
            
            .quick-quote-current-price {
                font-size: 16px;
            }
            
            .quick-quote-change {
                font-size: 11px;
            }
            
            .quick-quote-close {
                font-size: 24px;
                padding: 0 4px;
            }
            
            /* Body - single column vertical layout */
            .quick-quote-body {
                grid-template-columns: 1fr;
                overflow: visible;
            }
            
            /* Buy/Sell bar - Trading212 gradient style at top */
            .quick-quote-trade-panel {
                order: -1;
                width: 100%;
                min-width: unset;
                max-width: unset;
                border-left: none;
                border-bottom: 1px solid var(--border);
                padding: 12px 16px;
                gap: 10px;
            }
            
            /* Buy/Sell toggle - Trading212 wide gradient bar */
            .quick-trade-type-toggle {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 0;
                background: var(--bg-tertiary);
                border-radius: 8px;
                overflow: hidden;
                border: 1px solid var(--border);
            }
            
            .quick-trade-type-btn {
                border-radius: 0;
                padding: 14px;
                font-size: 14px;
                font-weight: 700;
            }
            
            .quick-trade-type-btn.buy.active {
                background: linear-gradient(135deg, #059669, #10b981);
            }
            
            .quick-trade-type-btn.sell.active {
                background: linear-gradient(135deg, #dc2626, #ef4444);
            }
            
            /* Price display within buy/sell bar */
            .qq-mobile-price-bar {
                display: grid;
                grid-template-columns: 1fr auto 1fr;
                align-items: center;
                gap: 8px;
            }
            
            /* Hide trade details initially, show below chart */
            .quick-trade-input-group,
            .qq-sltp-section,
            .quick-trade-summary,
            .quick-trade-execute {
                display: none;
            }
            
            /* Chart area */
            .quick-quote-chart-area {
                padding: 8px 12px;
                gap: 8px;
            }
            
            .quick-quote-chart {
                min-height: 200px;
                max-height: 220px;
                height: 200px;
            }
            
            /* Toolbar - compact horizontal row below chart */
            .qq-chart-toolbar {
                padding: 6px;
                gap: 6px;
                border-radius: 6px;
                flex-wrap: nowrap;
                overflow-x: auto;
            }
            
            .qq-timeframe-selector {
                gap: 2px;
                flex-shrink: 0;
            }
            
            .qq-tf-btn {
                padding: 6px 10px;
                font-size: 11px;
                border-radius: 6px;
            }
            
            /* Hide indicators on mobile - too cramped */
            .qq-indicator-toggle {
                display: none;
            }
            
            .qq-chart-type-toggle {
                flex-shrink: 0;
            }
            
            .qq-chart-type-btn {
                padding: 6px 8px;
            }
            
            /* Stats - Trading212 style: 2-column cards */
            .quick-quote-stats {
                grid-template-columns: 1fr 1fr;
                gap: 8px;
                padding: 0 4px;
            }
            
            .quick-stat {
                padding: 14px 12px;
                text-align: left;
                border: 1px solid var(--border);
            }
            
            .quick-stat-value {
                font-size: 14px;
                margin-bottom: 2px;
            }
            
            .quick-stat-label {
                font-size: 10px;
            }
            
            /* Show trade form below stats on mobile (as expandable section) */
            .qq-mobile-trade-expand {
                display: block;
            }
            
            /* Open positions - compact on mobile */
            .qq-open-positions.has-positions {
                margin: 0 4px;
                padding: 10px;
            }
            
            .qq-position-row {
                padding: 8px;
            }
            
            .qq-position-details {
                font-size: 11px;
            }
            
            .qq-position-pnl {
                font-size: 12px;
            }
            
            /* Mobile sidebar left panel fix */
            .sidebar.mobile-open {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                max-height: 100vh;
            }
        }

        @media (max-width: 400px) {
            .market-card {
                min-width: 120px;
            }
            .quote-card {
                min-width: 80px;
            }
            .chart-container {
                height: 180px;
            }
            .chart-stats {
                gap: 8px;
            }
            .chart-stat-value {
                font-size: 0.85rem !important;
            }
            .login-btn {
                padding: 5px 10px;
                font-size: 10px;
            }
        }

        /* Early Access Modal */
        .early-access-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .early-access-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        .early-access-content {
            position: relative;
            background: #fff;
            border-radius: 16px;
            max-width: 520px;
            width: 90%;
            padding: 40px;
            box-shadow: 0 24px 64px rgba(0,0,0,0.4);
            text-align: center;
        }
        .early-access-badge {
            display: inline-block;
            background: var(--accent-blue);
            color: #fff;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 20px;
        }
        .early-access-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: #202124;
            margin: 0 0 12px 0;
            line-height: 1.2;
        }
        .early-access-subtitle {
            font-size: 1rem;
            color: #5f6368;
            margin: 0 0 24px 0;
            line-height: 1.5;
        }
        .early-access-features {
            text-align: left;
            margin: 0 0 28px 0;
            padding: 0;
            list-style: none;
        }
        .early-access-features li {
            padding: 8px 0;
            font-size: 0.9rem;
            color: #3c4043;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .early-access-features li::before {
            content: '';
            width: 20px;
            height: 20px;
            background: var(--accent-blue);
            border-radius: 50%;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
        }
        .early-access-form {
            display: flex;
            gap: 10px;
            margin-bottom: 16px;
        }
        .early-access-form input[type="text"] {
            flex: 1;
            padding: 14px 18px;
            border: 2px solid #dadce0;
            border-radius: 8px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.2s;
        }
        .early-access-form input[type="text"]:focus {
            border-color: var(--accent-blue);
        }
        .early-access-form button {
            padding: 14px 28px;
            background: var(--accent-blue);
            color: #fff;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
            transition: background 0.2s;
        }
        .early-access-form button:hover {
            background: #1557b0;
        }
        .early-access-form button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        .early-access-privacy {
            font-size: 0.75rem;
            color: #5f6368;
            line-height: 1.5;
        }
        .early-access-privacy a {
            color: var(--accent-blue);
        }
        .early-access-success {
            padding: 20px 0;
        }
        .early-access-success-icon {
            width: 56px;
            height: 56px;
            background: #e6f4ea;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
            color: #137333;
            font-size: 1.5rem;
            font-weight: 700;
        }
        .early-access-success p {
            color: #137333;
            font-size: 1rem;
        }
        @media (max-width: 500px) {
            .early-access-content {
                padding: 28px 20px;
            }
            .early-access-form {
                flex-direction: column;
            }
            .early-access-form button {
                width: 100%;
            }
        }

        /* =============================================
           AUTH MODAL & TRADING PANEL STYLES
           ============================================= */
        
        /* Auth Modal */
        .auth-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .auth-modal.visible {
            display: flex;
        }
        .auth-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
        }
        .auth-content {
            position: relative;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            max-width: 420px;
            width: 90%;
            padding: 32px;
            box-shadow: 0 24px 64px rgba(0,0,0,0.5);
        }
        .auth-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
        }
        .auth-tab {
            flex: 1;
            padding: 10px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .auth-tab.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        .auth-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0 0 8px 0;
        }
        .auth-subtitle {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin: 0 0 24px 0;
        }
        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .auth-input-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .auth-input-group label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .auth-input {
            padding: 12px 14px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }
        .auth-input:focus {
            border-color: var(--accent-blue);
        }
        .auth-input::placeholder {
            color: var(--text-muted);
        }
        .auth-submit {
            padding: 14px;
            background: var(--accent-blue);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 8px;
        }
        .auth-submit:hover {
            background: #1557b0;
        }
        .auth-submit:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
        }
        .auth-error {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid var(--accent-red);
            border-radius: 6px;
            padding: 12px;
            color: var(--accent-red);
            font-size: 13px;
            display: none;
        }
        .auth-error.visible {
            display: block;
        }
        .auth-bonus {
            background: rgba(16, 185, 129, 0.15);
            border: 1px solid var(--accent-green);
            border-radius: 6px;
            padding: 12px;
            text-align: center;
            margin-top: 16px;
        }
        .auth-bonus-amount {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-green);
        }
        .auth-bonus-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        .auth-close {
            position: absolute;
            top: 16px;
            right: 16px;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 24px;
            cursor: pointer;
            line-height: 1;
        }
        .auth-close:hover {
            color: var(--text-primary);
        }

        /* User Menu (logged in state) */
        .user-menu {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .user-balance {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            padding: 6px 12px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
        }
        .user-balance-label {
            color: var(--text-muted);
            font-size: 10px;
            margin-right: 6px;
        }
        .user-balance-amount {
            color: var(--accent-green);
            font-weight: 600;
        }
        .user-avatar {
            width: 32px;
            height: 32px;
            background: var(--accent-blue);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 12px;
            cursor: pointer;
        }
        .login-btn {
            padding: 8px 16px;
            background: var(--accent-blue);
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }
        .login-btn:hover {
            background: #1557b0;
        }

        /* Trading Panel (replaces Order Book lock) */
        .trading-panel {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }
        .trade-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow: hidden;
        }
        .trade-type-toggle {
            display: flex;
            gap: 4px;
        }
        .trade-type-btn {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .trade-type-btn.buy {
            background: transparent;
            color: var(--accent-green);
            border-color: var(--accent-green);
        }
        .trade-type-btn.buy.active {
            background: var(--accent-green);
            color: white;
        }
        .trade-type-btn.sell {
            background: transparent;
            color: var(--accent-red);
            border-color: var(--accent-red);
        }
        .trade-type-btn.sell.active {
            background: var(--accent-red);
            color: white;
        }
        /* Modern Select Dropdown */
        .trade-select {
            padding: 12px 36px 12px 12px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: 'Inter', sans-serif;
            outline: none;
            cursor: pointer;
            width: 100%;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%239ca3af' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .trade-select:hover {
            border-color: var(--border-light);
        }
        .trade-select:focus {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
        }
        .trade-select option {
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 10px;
        }
        .trade-input-row {
            display: flex;
            gap: 8px;
        }
        .trade-input-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
        }
        .trade-input-group label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .trade-input {
            padding: 10px 12px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            outline: none;
            width: 100%;
            box-sizing: border-box;
            -webkit-appearance: none;
            -moz-appearance: textfield;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .trade-input::-webkit-outer-spin-button,
        .trade-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .trade-input:hover {
            border-color: var(--border-light);
        }
        .trade-input:focus {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
        }
        .trade-summary {
            background: var(--bg-card);
            border-radius: 6px;
            padding: 10px 12px;
            font-size: 12px;
        }
        .trade-summary-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }
        .trade-summary-label {
            color: var(--text-muted);
        }
        .trade-summary-value {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
        }
        .trade-execute-btn {
            padding: 14px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }
        .trade-execute-btn.buy {
            background: var(--accent-green);
            color: white;
        }
        .trade-execute-btn.buy:hover {
            background: #0d9668;
        }
        .trade-execute-btn.sell {
            background: var(--accent-red);
            color: white;
        }
        .trade-execute-btn.sell:hover {
            background: #dc2626;
        }
        .trade-execute-btn:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
        }
        .trade-execute-btn.signin-prompt {
            background: var(--accent-blue);
            cursor: pointer;
        }
        .trade-execute-btn.signin-prompt:hover {
            background: #1557b0;
        }

        /* Portfolio Section */
        .portfolio-section {
            padding: 16px;
        }
        .portfolio-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .portfolio-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            font-weight: 700;
        }
        .portfolio-pnl {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }
        .position-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border);
        }
        .position-item:last-child {
            border-bottom: none;
        }
        .position-tea {
            font-weight: 600;
            font-size: 13px;
        }
        .position-qty {
            font-size: 11px;
            color: var(--text-muted);
        }
        .position-value {
            text-align: right;
        }
        .position-current {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }
        .position-pnl {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }

        /* Leaderboard Tab */
        .leaderboard-section {
            padding: 16px;
        }
        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 0;
            border-bottom: 1px solid var(--border);
        }
        .leaderboard-rank {
            width: 24px;
            height: 24px;
            background: var(--bg-card);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
        }
        .leaderboard-rank.gold { background: #f59e0b; color: #000; }
        .leaderboard-rank.silver { background: #9ca3af; color: #000; }
        .leaderboard-rank.bronze { background: #cd7f32; color: #000; }
        .leaderboard-name {
            flex: 1;
            font-size: 13px;
        }
        .leaderboard-return {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            font-weight: 600;
        }

        /* Trade Success Toast */
        .trade-toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: var(--bg-secondary);
            border: 1px solid var(--accent-green);
            border-radius: 8px;
            padding: 16px 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            z-index: 10001;
            display: none;
            animation: slideIn 0.3s ease;
        }
        .trade-toast.visible {
            display: block;
        }
        .trade-toast.error {
            border-color: var(--accent-red);
        }
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .toast-title {
            font-weight: 700;
            font-size: 14px;
            margin-bottom: 4px;
        }
        .toast-message {
            font-size: 12px;
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <!-- Early Access Modal -->
    <div class="early-access-modal" id="early-access-modal">
        <div class="early-access-backdrop"></div>
        <div class="early-access-content">
            <span class="early-access-badge">Early Access</span>
            <h2 class="early-access-title">TeaTrade Exchange</h2>
            <p class="early-access-subtitle">The world's first real-time tea market terminal. Get priority access to auction data, price indices, and institutional-grade analytics.</p>
            <ul class="early-access-features">
                <li>Live auction data from Mombasa, Kolkata, Colombo & more</li>
                <li>Real-time price indices by grade, origin & buyer</li>
                <li>Historical trade analytics & trend forecasting</li>
                <li>Buyer & seller intelligence reports</li>
            </ul>
            <form class="early-access-form" id="early-access-form" onsubmit="submitEarlyAccess(event)">
                <input type="text" id="early-access-email" name="email_address" placeholder="Enter your email address">
                <button type="submit" id="early-access-btn">Get Early Access</button>
            </form>
            <p class="early-access-privacy">Your email is stored securely and used only to notify you when TeaTrade Exchange launches. We never share your data. <a href="/privacy.html" target="_blank">Privacy Policy</a></p>
        </div>
    </div>

    <!-- Auth Modal -->
    <div class="auth-modal" id="auth-modal">
        <div class="auth-backdrop" onclick="closeAuthModal()"></div>
        <div class="auth-content">
            <button class="auth-close" onclick="closeAuthModal()">&times;</button>
            <div class="auth-tabs">
                <button class="auth-tab active" id="tab-signup" onclick="switchAuthTab('signup')">Sign Up</button>
                <button class="auth-tab" id="tab-login" onclick="switchAuthTab('login')">Log In</button>
            </div>
            
            <!-- Signup Form -->
            <div id="signup-form-container">
                <h3 class="auth-title">Join the Paper Trading League</h3>
                <p class="auth-subtitle">Compete to become the world's best tea trader. Top traders win real tea prizes!</p>
                <div class="auth-error" id="signup-error"></div>
                <form class="auth-form" id="signup-form" onsubmit="handleSignup(event)">
                    <div class="auth-input-group">
                        <label>Username</label>
                        <input type="text" class="auth-input" id="signup-username" placeholder="tea_trader_123" required minlength="3" maxlength="20">
                    </div>
                    <div class="auth-input-group">
                        <label>Email</label>
                        <input type="email" class="auth-input" id="signup-email" placeholder="you@example.com" required>
                    </div>
                    <div class="auth-input-group">
                        <label>Password</label>
                        <input type="password" class="auth-input" id="signup-password" placeholder="Min 6 characters" required minlength="6">
                    </div>
                    <button type="submit" class="auth-submit" id="signup-btn">Create Account & Start Trading</button>
                </form>
                <div class="auth-bonus">
                    <div class="auth-bonus-amount">$10,000</div>
                    <div class="auth-bonus-label">Virtual Cash to Start Trading</div>
                </div>
            </div>
            
            <!-- Login Form -->
            <div id="login-form-container" style="display: none;">
                <h3 class="auth-title">Welcome Back</h3>
                <p class="auth-subtitle">Log in to continue trading and climb the leaderboard.</p>
                <div class="auth-error" id="login-error"></div>
                <form class="auth-form" id="login-form" onsubmit="handleLogin(event)">
                    <div class="auth-input-group">
                        <label>Email</label>
                        <input type="email" class="auth-input" id="login-email" placeholder="you@example.com" required>
                    </div>
                    <div class="auth-input-group">
                        <label>Password</label>
                        <input type="password" class="auth-input" id="login-password" placeholder="Your password" required>
                    </div>
                    <button type="submit" class="auth-submit" id="login-btn">Log In</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Trade Toast Notification -->
    <div class="trade-toast" id="trade-toast">
        <div class="toast-title" id="toast-title">Trade Executed!</div>
        <div class="toast-message" id="toast-message"></div>
    </div>

    <!-- Pairs Trade Modal -->
    <div class="pairs-modal-overlay" id="pairs-modal">
        <div class="pairs-modal">
            <div class="pairs-modal-header">
                <div class="pairs-modal-title" id="pairs-modal-title">Trade Pair</div>
                <button class="pairs-modal-close" onclick="closePairsModal()">&times;</button>
            </div>
            <div class="pairs-modal-pair">
                <div class="pair-display" id="modal-pair-display">
                    <span class="base">DRJ</span>/<span class="quote">ASM</span>
                </div>
                <div class="ratio-display" id="modal-ratio-display">Ratio: 5.76</div>
            </div>
            <div class="side-selector">
                <button class="side-btn long active" data-side="LONG" onclick="setPairsSide('LONG')">Long</button>
                <button class="side-btn short" data-side="SHORT" onclick="setPairsSide('SHORT')">Short</button>
            </div>
            <div class="leverage-selector">
                <button class="leverage-btn active" data-leverage="1" onclick="setLeverage(1)">1x</button>
                <button class="leverage-btn" data-leverage="2" onclick="setLeverage(2)">2x</button>
                <button class="leverage-btn" data-leverage="5" onclick="setLeverage(5)">5x</button>
                <button class="leverage-btn" data-leverage="10" onclick="setLeverage(10)">10x</button>
            </div>
            <div class="pairs-input-group">
                <label>Position Size (USD)</label>
                <input type="number" id="pairs-amount" value="100" min="10" step="10" oninput="updatePairsSummary()">
            </div>
            <div class="pairs-summary">
                <div class="pairs-summary-row">
                    <span class="label">Position Size</span>
                    <span class="value" id="summary-size">$100.00</span>
                </div>
                <div class="pairs-summary-row">
                    <span class="label">Leverage</span>
                    <span class="value" id="summary-leverage">1x</span>
                </div>
                <div class="pairs-summary-row exposure">
                    <span class="label">Total Exposure</span>
                    <span class="value" id="summary-exposure">$100.00</span>
                </div>
                <div class="pairs-summary-row">
                    <span class="label">Entry Ratio</span>
                    <span class="value" id="summary-ratio">5.76</span>
                </div>
            </div>
            <div class="pairs-modal-actions">
                <button class="cancel-btn" onclick="closePairsModal()">Cancel</button>
                <button class="confirm-btn" id="pairs-confirm-btn" onclick="executePairTrade()">Confirm Trade</button>
            </div>
        </div>
    </div>

    <!-- Quick Quote Modal -->
    <div class="quick-quote-modal-overlay" id="quick-quote-modal">
        <div class="quick-quote-modal">
            <div class="quick-quote-header">
                <div class="quick-quote-title">
                    <span class="quick-quote-symbol" id="qq-symbol">BP1</span>
                    <span class="quick-quote-name" id="qq-name">Kenya BP1</span>
                </div>
                <div class="quick-quote-price-info">
                    <span class="quick-quote-current-price up" id="qq-price">$3.42</span>
                    <span class="quick-quote-change up" id="qq-change">+2.4%</span>
                </div>
                <button class="quick-quote-close" onclick="closeQuickQuoteModal()">&times;</button>
            </div>
            <div class="quick-quote-body">
                <div class="quick-quote-chart-area">
                    <div class="qq-chart-toolbar">
                        <div class="qq-timeframe-selector">
                            <button class="qq-tf-btn" data-tf="1H" onclick="setQQTimeframe('1H')">1H</button>
                            <button class="qq-tf-btn active" data-tf="1D" onclick="setQQTimeframe('1D')">1D</button>
                            <button class="qq-tf-btn" data-tf="1W" onclick="setQQTimeframe('1W')">1W</button>
                            <button class="qq-tf-btn" data-tf="1M" onclick="setQQTimeframe('1M')">1M</button>
                        </div>
                        <div class="qq-indicator-toggle">
                            <button class="qq-indicator-btn" data-ind="sma" onclick="toggleQQIndicator('sma')">
                                <span class="indicator-dot sma"></span>SMA
                            </button>
                            <button class="qq-indicator-btn" data-ind="ema" onclick="toggleQQIndicator('ema')">
                                <span class="indicator-dot ema"></span>EMA
                            </button>
                            <button class="qq-indicator-btn" data-ind="bollinger" onclick="toggleQQIndicator('bollinger')">
                                <span class="indicator-dot bollinger"></span>BB
                            </button>
                        </div>
                        <div class="qq-chart-type-toggle">
                            <button class="qq-chart-type-btn active" data-type="line" onclick="setQQChartType('line')">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="2,18 8,12 14,16 22,6"></polyline>
                                </svg>
                            </button>
                            <button class="qq-chart-type-btn" data-type="candle" onclick="setQQChartType('candle')">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="6" y="8" width="4" height="8"></rect>
                                    <line x1="8" y1="4" x2="8" y2="8"></line>
                                    <line x1="8" y1="16" x2="8" y2="20"></line>
                                    <rect x="14" y="10" width="4" height="6"></rect>
                                    <line x1="16" y1="6" x2="16" y2="10"></line>
                                    <line x1="16" y1="16" x2="16" y2="18"></line>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="quick-quote-chart">
                        <canvas id="qq-chart"></canvas>
                        <div class="qq-crosshair" id="qq-crosshair">
                            <div class="qq-crosshair-v"></div>
                            <div class="qq-crosshair-h"></div>
                        </div>
                        <div class="qq-tooltip" id="qq-tooltip"></div>
                        <div class="qq-trade-annotations" id="qq-trade-annotations"></div>
                    </div>
                    <div class="quick-quote-stats">
                        <div class="quick-stat">
                            <div class="quick-stat-value" id="qq-high">$3.56</div>
                            <div class="quick-stat-label">24h High</div>
                        </div>
                        <div class="quick-stat">
                            <div class="quick-stat-value" id="qq-low">$3.28</div>
                            <div class="quick-stat-label">24h Low</div>
                        </div>
                        <div class="quick-stat">
                            <div class="quick-stat-value" id="qq-volume">24.5K</div>
                            <div class="quick-stat-label">Volume</div>
                        </div>
                        <div class="quick-stat">
                            <div class="quick-stat-value" id="qq-avg">$3.41</div>
                            <div class="quick-stat-label">Avg Price</div>
                        </div>
                    </div>
                    <div class="qq-open-positions" id="qq-open-positions"></div>
                </div>
                <div class="quick-quote-trade-panel">
                    <div class="quick-trade-type-toggle">
                        <button class="quick-trade-type-btn buy active" id="qq-btn-buy" onclick="setQuickTradeType('BUY')">BUY</button>
                        <button class="quick-trade-type-btn sell" id="qq-btn-sell" onclick="setQuickTradeType('SELL')">SELL</button>
                    </div>
                    <div class="quick-trade-input-group">
                        <label>Quantity (kg)</label>
                        <input type="number" class="quick-trade-input" id="qq-qty" value="100" min="1" oninput="updateQuickTradeSummary()">
                    </div>
                    <div class="quick-trade-input-group">
                        <label>Price ($/kg)</label>
                        <input type="number" class="quick-trade-input" id="qq-trade-price" readonly>
                    </div>
                    <div class="qq-sltp-section">
                        <div class="qq-sltp-group">
                            <label><span class="dot sl"></span>Stop Loss</label>
                            <input type="number" class="quick-trade-input" id="qq-sl" placeholder="0.00" step="0.01">
                        </div>
                        <div class="qq-sltp-group">
                            <label><span class="dot tp"></span>Take Profit</label>
                            <input type="number" class="quick-trade-input" id="qq-tp" placeholder="0.00" step="0.01">
                        </div>
                    </div>
                    <div class="quick-trade-summary">
                        <div class="quick-trade-summary-row">
                            <span>Order Value</span>
                            <span id="qq-order-value">$342.00</span>
                        </div>
                        <div class="quick-trade-summary-row">
                            <span>Your Balance</span>
                            <span id="qq-balance">$10,000.00</span>
                        </div>
                        <div class="quick-trade-summary-row">
                            <span>After Trade</span>
                            <span id="qq-after-trade">$9,658.00</span>
                        </div>
                    </div>
                    <button class="quick-trade-execute buy" id="qq-execute-btn" onclick="executeQuickTrade()">BUY 100 kg</button>
                </div>
            </div>
            <!-- Mobile sticky trade button -->
            <div class="qq-mobile-trade-bar" id="qq-mobile-trade-bar">
                <button class="qq-mobile-trade-btn buy" id="qq-mobile-trade-btn" onclick="toggleMobileQQTradeForm()">
                    <span id="qq-mobile-trade-label">Trade</span>
                    <span id="qq-mobile-trade-price" class="qq-mobile-trade-price"></span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Mobile Quick Quote Trade Form (bottom sheet) -->
    <div class="qq-mobile-trade-overlay" id="qq-mobile-trade-overlay" onclick="closeMobileQQTradeForm()"></div>
    <div class="qq-mobile-trade-form" id="qq-mobile-trade-form">
        <div class="qq-mobile-trade-form-header">
            <div class="qq-mobile-trade-form-title" id="qq-mobile-form-title">Trade Kenya BP1</div>
            <button class="qq-mobile-trade-form-close" onclick="closeMobileQQTradeForm()">&times;</button>
        </div>
        <div class="quick-trade-type-toggle" style="margin-bottom: 14px;">
            <button class="quick-trade-type-btn buy active" id="qq-mobile-btn-buy" onclick="setQuickTradeType('BUY'); this.classList.add('active'); document.getElementById('qq-mobile-btn-sell').classList.remove('active');">BUY</button>
            <button class="quick-trade-type-btn sell" id="qq-mobile-btn-sell" onclick="setQuickTradeType('SELL'); this.classList.add('active'); document.getElementById('qq-mobile-btn-buy').classList.remove('active');">SELL</button>
        </div>
        <div class="quick-trade-input-group">
            <label>Quantity (kg)</label>
            <input type="number" class="quick-trade-input" id="qq-mobile-qty" value="100" min="1" oninput="updateMobileQQSummary()">
        </div>
        <div class="quick-trade-input-group">
            <label>Price ($/kg)</label>
            <input type="number" class="quick-trade-input" id="qq-mobile-price" readonly>
        </div>
        <div class="qq-sltp-section" style="margin-top: 12px;">
            <div class="qq-sltp-group">
                <label><span class="dot sl"></span>Stop Loss</label>
                <input type="number" class="quick-trade-input" id="qq-mobile-sl" placeholder="0.00" step="0.01">
            </div>
            <div class="qq-sltp-group">
                <label><span class="dot tp"></span>Take Profit</label>
                <input type="number" class="quick-trade-input" id="qq-mobile-tp" placeholder="0.00" step="0.01">
            </div>
        </div>
        <div class="quick-trade-summary" style="margin-top: 14px;">
            <div class="quick-trade-summary-row">
                <span>Order Value</span>
                <span id="qq-mobile-order-value">$0.00</span>
            </div>
            <div class="quick-trade-summary-row">
                <span>Your Balance</span>
                <span id="qq-mobile-balance">$10,000.00</span>
            </div>
        </div>
        <button class="quick-trade-execute buy" id="qq-mobile-execute-btn" onclick="executeMobileQQTrade()" style="width: 100%; margin-top: 14px;">BUY 100 kg</button>
    </div>
    
    <!-- Multi-Chart Dashboard Modal -->
    <div class="multi-chart-modal-overlay" id="multi-chart-modal">
        <div class="multi-chart-modal">
            <div class="multi-chart-header">
                <div class="multi-chart-title">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7"></rect>
                        <rect x="14" y="3" width="7" height="7"></rect>
                        <rect x="14" y="14" width="7" height="7"></rect>
                        <rect x="3" y="14" width="7" height="7"></rect>
                    </svg>
                    Multi-Chart Dashboard
                </div>
                <div class="multi-chart-actions">
                    <button class="mc-add-chart-btn" onclick="addMultiChart()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                        Add Chart
                    </button>
                    <button class="multi-chart-close" onclick="closeMultiChartModal()">&times;</button>
                </div>
            </div>
            <div class="multi-chart-grid" id="multi-chart-grid">
                <!-- Charts will be dynamically added here -->
            </div>
        </div>
    </div>

    <!-- Price Alert Modal -->
    <div class="pairs-modal-overlay" id="price-alert-modal">
        <div class="pairs-modal" style="max-width: 340px;">
            <div class="pairs-modal-header">
                <div class="pairs-modal-title" id="alert-modal-title">Set Price Alert</div>
                <button class="pairs-modal-close" onclick="closePriceAlertModal()">&times;</button>
            </div>
            <div class="pairs-modal-pair">
                <div class="pair-display" style="gap: 8px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--accent-blue)" stroke-width="2">
                        <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                        <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
                    </svg>
                    <span id="alert-symbol" style="font-size: 18px; font-weight: 600;">DRJ</span>
                </div>
                <div class="ratio-display" id="alert-current-price">Current: $3.45</div>
            </div>
            <div class="sltp-section" style="margin: 16px 0;">
                <div class="sltp-group">
                    <label class="sltp-label"><span class="dot sl"></span>Alert Below</label>
                    <input type="number" class="sltp-input" id="alert-below" placeholder="e.g. 3.20" step="0.01">
                </div>
                <div class="sltp-group">
                    <label class="sltp-label"><span class="dot tp"></span>Alert Above</label>
                    <input type="number" class="sltp-input" id="alert-above" placeholder="e.g. 3.80" step="0.01">
                </div>
            </div>
            <div class="pairs-modal-actions">
                <button class="cancel-btn" onclick="deletePriceAlert()" id="alert-delete-btn" style="display: none;">Delete Alert</button>
                <button class="confirm-btn" onclick="savePriceAlert()">Save Alert</button>
            </div>
        </div>
    </div>

    <!-- Mobile Overlay -->
    <div class="mobile-overlay" id="mobile-overlay" onclick="closeMobileMenu()"></div>

    <!-- Top Bar -->
    <div class="top-bar">
        <button class="mobile-menu-btn" id="mobile-menu-btn" onclick="toggleMobileMenu()" aria-label="Menu">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12h18M3 6h18M3 18h18"/>
            </svg>
        </button>
        <div class="logo">
            <div class="logo-icon">TT</div>
            <div class="logo-text">TeaTrade <span>Exchange</span></div>
        </div>
        <div class="command-line-container">
            <span class="command-line-icon">âŒ˜</span>
            <input type="text" class="command-line" id="command-line" placeholder="Search teas, pairs, indexes... (press /)" autocomplete="off">
            <div class="command-suggestions" id="command-suggestions"></div>
        </div>
        <nav class="nav-links">
            <a href="#" class="active">Markets</a>
            <a href="#">Auctions</a>
            <a href="#" onclick="openMultiChartModal(); return false;">Dashboard</a>
            <a href="#">Analytics</a>
        </nav>
        <div class="user-section">
            <div class="market-status" id="market-status">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">Mombasa Live</span>
            </div>
            <!-- Logged out state -->
            <div id="logged-out-ui">
                <button class="login-btn" onclick="openAuthModal()">Sign Up / Log In</button>
            </div>
            <!-- Logged in state -->
            <div id="logged-in-ui" class="user-menu" style="display: none;">
                <div class="user-balance">
                    <span class="user-balance-label">BALANCE</span>
                    <span class="user-balance-amount" id="user-balance">$10,000.00</span>
                </div>
                <div class="user-avatar" id="user-avatar" onclick="handleLogout()" title="Click to logout">TT</div>
            </div>
        </div>
    </div>

    <!-- Ticker Strip -->
    <div class="ticker-strip">
        <div class="ticker-track">
            <div class="ticker-item">
                <span class="ticker-symbol">BP1.KE</span>
                <span class="ticker-price">$3.42/kg</span>
                <span class="ticker-change up">+2.4%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">PF1.KE</span>
                <span class="ticker-price">$2.98/kg</span>
                <span class="ticker-change down">-0.8%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">FBOP.IN</span>
                <span class="ticker-price">â‚¹285/kg</span>
                <span class="ticker-change up">+1.2%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">BOP.LK</span>
                <span class="ticker-price">LKR 1,245</span>
                <span class="ticker-change up">+3.1%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">OP.MWI</span>
                <span class="ticker-price">$2.15/kg</span>
                <span class="ticker-change down">-1.4%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">DUST.KE</span>
                <span class="ticker-price">$2.67/kg</span>
                <span class="ticker-change up">+0.6%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">TGFOP.IN</span>
                <span class="ticker-price">â‚¹412/kg</span>
                <span class="ticker-change up">+4.2%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">PEKOE.LK</span>
                <span class="ticker-price">LKR 980</span>
                <span class="ticker-change down">-0.3%</span>
            </div>
            <!-- Duplicate for seamless loop -->
            <div class="ticker-item">
                <span class="ticker-symbol">BP1.KE</span>
                <span class="ticker-price">$3.42/kg</span>
                <span class="ticker-change up">+2.4%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">PF1.KE</span>
                <span class="ticker-price">$2.98/kg</span>
                <span class="ticker-change down">-0.8%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">FBOP.IN</span>
                <span class="ticker-price">â‚¹285/kg</span>
                <span class="ticker-change up">+1.2%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">BOP.LK</span>
                <span class="ticker-price">LKR 1,245</span>
                <span class="ticker-change up">+3.1%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">OP.MWI</span>
                <span class="ticker-price">$2.15/kg</span>
                <span class="ticker-change down">-1.4%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">DUST.KE</span>
                <span class="ticker-price">$2.67/kg</span>
                <span class="ticker-change up">+0.6%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">TGFOP.IN</span>
                <span class="ticker-price">â‚¹412/kg</span>
                <span class="ticker-change up">+4.2%</span>
            </div>
            <div class="ticker-item">
                <span class="ticker-symbol">PEKOE.LK</span>
                <span class="ticker-price">LKR 980</span>
                <span class="ticker-change down">-0.3%</span>
            </div>
        </div>
    </div>

    <!-- Market Summary Cards -->
    <div class="market-cards">
        <div class="market-card" id="market-card-0" onclick="swapChartIndex(0)">
            <div class="market-card-label">Mombasa Auction Index</div>
            <div class="market-card-value" id="card-value-0">$2.87</div>
            <div class="market-card-change up" id="card-change-0">â–² +1.8%</div>
        </div>
        <div class="market-card" id="market-card-1" onclick="swapChartIndex(1)">
            <div class="market-card-label">Kolkata Tea Index</div>
            <div class="market-card-value" id="card-value-1">â‚¹267.45</div>
            <div class="market-card-change up" id="card-change-1">â–² +3.2%</div>
        </div>
        <div class="market-card" id="market-card-2" onclick="swapChartIndex(2)">
            <div class="market-card-label">Colombo Index</div>
            <div class="market-card-value" id="card-value-2">$3.24</div>
            <div class="market-card-change down" id="card-change-2">â–¼ -1.8%</div>
        </div>
        <div class="market-card" id="market-card-3" onclick="swapChartIndex(3)">
            <div class="market-card-label">Global Tea Futures</div>
            <div class="market-card-value" id="card-value-3">$3,847</div>
            <div class="market-card-change up" id="card-change-3">â–² +0.7%</div>
        </div>
    </div>

    <!-- Main Grid -->
    <div class="main-grid">
        <!-- Left Sidebar -->
        <div class="sidebar" id="mobile-sidebar">
            <!-- Mobile sidebar header (hidden on desktop) -->
            <div class="mobile-sidebar-header">
                <span style="font-weight: 600; color: var(--text-primary);">Menu</span>
                <button class="mobile-close-btn" onclick="closeMobileMenu()" aria-label="Close menu">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-title">Watchlist</div>
                <div class="watchlist-tabs">
                    <button class="watchlist-tab active" onclick="switchWatchlistTab('teas')">Teas</button>
                    <button class="watchlist-tab" onclick="switchWatchlistTab('macro')">Macro</button>
                </div>
                <div id="watchlist-teas">
                <!-- Dynamically populated -->
                </div>
                <div id="watchlist-macro" style="display: none;">
                    <div class="macro-item">
                        <div class="macro-info">
                            <div class="macro-icon currency">ðŸ’±</div>
                            <div>
                                <div class="macro-name">USD/KES</div>
                                <div class="macro-subtext">Kenyan Shilling</div>
                            </div>
                        </div>
                        <div class="macro-value">
                            <div class="macro-price" id="macro-usdkes">129.45</div>
                            <div class="macro-change up" id="macro-usdkes-change">â–² +0.32%</div>
                            <div class="macro-impact bearish">Bearish Tea</div>
                        </div>
                    </div>
                    <div class="macro-item">
                        <div class="macro-info">
                            <div class="macro-icon oil">ðŸ›¢ï¸</div>
                            <div>
                                <div class="macro-name">Brent Crude</div>
                                <div class="macro-subtext">Shipping costs</div>
                            </div>
                        </div>
                        <div class="macro-value">
                            <div class="macro-price" id="macro-oil">$82.40</div>
                            <div class="macro-change down" id="macro-oil-change">â–¼ -1.2%</div>
                            <div class="macro-impact bullish">Bullish Tea</div>
                        </div>
                    </div>
                    <div class="macro-item">
                        <div class="macro-info">
                            <div class="macro-icon shipping">ðŸš¢</div>
                            <div>
                                <div class="macro-name">BDI Index</div>
                                <div class="macro-subtext">Baltic Dry Index</div>
                            </div>
                        </div>
                        <div class="macro-value">
                            <div class="macro-price" id="macro-bdi">1,842</div>
                            <div class="macro-change up" id="macro-bdi-change">â–² +2.8%</div>
                            <div class="macro-impact bearish">Bearish Tea</div>
                        </div>
                    </div>
                    <div class="macro-item">
                        <div class="macro-info">
                            <div class="macro-icon weather">ðŸŒ§ï¸</div>
                            <div>
                                <div class="macro-name">Kericho Rain</div>
                                <div class="macro-subtext">Kenya highlands</div>
                            </div>
                        </div>
                        <div class="macro-value">
                            <div class="macro-price" id="macro-rain">+24mm</div>
                            <div class="macro-change up" id="macro-rain-change">Above avg</div>
                            <div class="macro-impact bearish">Bearish Price</div>
                        </div>
                    </div>
                    <div class="macro-item">
                        <div class="macro-info">
                            <div class="macro-icon weather">â˜€ï¸</div>
                            <div>
                                <div class="macro-name">Assam Weather</div>
                                <div class="macro-subtext">India region</div>
                            </div>
                        </div>
                        <div class="macro-value">
                            <div class="macro-price" id="macro-assam">-12mm</div>
                            <div class="macro-change down" id="macro-assam-change">Below avg</div>
                            <div class="macro-impact bullish">Bullish Price</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Top Movers</div>
                <div class="movers-grid">
                    <div class="mover-card">
                        <div class="mover-label">Top Gainer</div>
                        <div class="mover-name">SFTGFOP1</div>
                        <div class="mover-value up">+12.4%</div>
                    </div>
                    <div class="mover-card">
                        <div class="mover-label">Top Loser</div>
                        <div class="mover-name">Fannings</div>
                        <div class="mover-value down">-4.2%</div>
                    </div>
                    <div class="mover-card">
                        <div class="mover-label">Most Volume</div>
                        <div class="mover-name">BP1</div>
                        <div class="mover-value">2.1M kg</div>
                    </div>
                    <div class="mover-card">
                        <div class="mover-label">Highest Bid</div>
                        <div class="mover-name">Silver Tips</div>
                        <div class="mover-value up">$128/kg</div>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Auction Centers</div>
                <div class="watchlist-item" style="flex-direction: column; align-items: flex-start; gap: 4px;">
                    <div style="display: flex; justify-content: space-between; width: 100%;">
                        <span class="watchlist-name">Mombasa</span>
                        <span class="up" style="font-size: 12px;">â— LIVE</span>
                    </div>
                    <div class="volume-bar" style="width: 100%;"><div class="volume-fill" style="width: 85%;"></div></div>
                </div>
                <div class="watchlist-item" style="flex-direction: column; align-items: flex-start; gap: 4px;">
                    <div style="display: flex; justify-content: space-between; width: 100%;">
                        <span class="watchlist-name">Kolkata</span>
                        <span style="color: var(--text-muted); font-size: 12px;">Opens 09:30</span>
                    </div>
                    <div class="volume-bar" style="width: 100%;"><div class="volume-fill" style="width: 0%;"></div></div>
                </div>
                <div class="watchlist-item" style="flex-direction: column; align-items: flex-start; gap: 4px;">
                    <div style="display: flex; justify-content: space-between; width: 100%;">
                        <span class="watchlist-name">Colombo</span>
                        <span style="color: var(--accent-orange); font-size: 12px;">â— Pre-Market</span>
                    </div>
                    <div class="volume-bar" style="width: 100%;"><div class="volume-fill" style="width: 20%;"></div></div>
                </div>
            </div>

            <!-- Upcoming Auctions (moved from right panel) -->
            <div class="sidebar-section">
                <div class="sidebar-title">Upcoming Auctions</div>
                <div class="calendar-item">
                    <div class="calendar-date">
                        <div class="calendar-day">12</div>
                        <div class="calendar-month">Feb</div>
                    </div>
                    <div class="calendar-info">
                        <div class="calendar-name">Mombasa Sale 06</div>
                        <div class="calendar-center">Kenya Tea Exchange</div>
                    </div>
                    <span class="calendar-status live">LIVE</span>
                </div>
                <div class="calendar-item">
                    <div class="calendar-date">
                        <div class="calendar-day">13</div>
                        <div class="calendar-month">Feb</div>
                    </div>
                    <div class="calendar-info">
                        <div class="calendar-name">Kolkata Auction 08</div>
                        <div class="calendar-center">Calcutta Tea Traders</div>
                    </div>
                    <span class="calendar-status upcoming">09:30 IST</span>
                </div>
                <div class="calendar-item">
                    <div class="calendar-date">
                        <div class="calendar-day">14</div>
                        <div class="calendar-month">Feb</div>
                    </div>
                    <div class="calendar-info">
                        <div class="calendar-name">Colombo Weekly</div>
                        <div class="calendar-center">Ceylon Tea Board</div>
                    </div>
                    <span class="calendar-status upcoming">10:00 LKT</span>
                </div>
            </div>
            
            <!-- IB Chat Section -->
            <div class="sidebar-section chat-section" id="chat-section-sidebar">
                <div class="chat-header">
                    <div class="chat-title">
                        TT Messenger
                        <span class="chat-online" id="chat-online-count">0 online</span>
                    </div>
                </div>
                <div class="chat-messages" id="chat-messages">
                    <!-- Messages will be populated dynamically -->
                </div>
                <div class="chat-input-container">
                    <input type="text" class="chat-input" id="chat-input" placeholder="Type a message... (@user for DM)">
                    <button class="chat-send" id="chat-send-btn" onclick="sendChatMessage()">Send</button>
                    <button class="chat-blast" title="BLAST" onclick="sendBlastMessage()"><svg fill="currentColor" viewBox="0 0 24 24"><path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/></svg></button>
                </div>
            </div>
        </div>

        <!-- Center Content -->
        <div class="center-content">
            <!-- Chart Section -->
            <div class="chart-section" id="chart-section">
                <div class="chart-header">
                    <div>
                        <div class="chart-title">
                            <h2 id="main-chart-title">Kenyan Tea Price Index</h2>
                            <span class="chart-badge">Live</span>
                        </div>
                        <div class="chart-stats">
                            <div class="chart-stat">
                                <div class="chart-stat-value up" id="main-chart-price">$3.42</div>
                                <div class="chart-stat-label">Last Trade Price (USD/kg)</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-value" style="font-size: 20px;" id="main-chart-change">+$0.08 (+2.4%)</div>
                                <div class="chart-stat-label">Change Today</div>
                            </div>
                            <div class="chart-stat">
                                <div class="chart-stat-value" style="font-size: 20px;" id="main-chart-volume">8.2M</div>
                                <div class="chart-stat-label">Volume (kg)</div>
                            </div>
                        </div>
                    </div>
                    <div class="chart-controls">
                        <button class="maximize-btn" onclick="toggleMaximize('chart-section')" title="Maximize">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                            </svg>
                        </button>
                        <div class="timeframe-dropdown">
                            <button class="timeframe-btn" id="timeframe-btn" onclick="toggleTimeframeMenu()">
                                <span id="timeframe-label">1W</span>
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><path d="M6 9l6 6 6-6"/></svg>
                            </button>
                            <div class="timeframe-menu" id="timeframe-menu">
                                <div class="timeframe-item" onclick="setTimeframe('1D')">1D</div>
                                <div class="timeframe-item active" onclick="setTimeframe('1W')">1W</div>
                                <div class="timeframe-item" onclick="setTimeframe('1M')">1M</div>
                                <div class="timeframe-item" onclick="setTimeframe('3M')">3M</div>
                                <div class="timeframe-item" onclick="setTimeframe('1Y')">1Y</div>
                                <div class="timeframe-item" onclick="setTimeframe('ALL')">ALL</div>
                            </div>
                        </div>
                        <div class="chart-type-toggle">
                            <button class="chart-type-btn active" id="btn-line" onclick="setChartType('line')" title="Line Chart">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 17l6-6 4 4 8-8"/></svg>
                            </button>
                            <button class="chart-type-btn" id="btn-candle" onclick="setChartType('candle')" title="Candlestick">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="5" y="8" width="4" height="8"/><line x1="7" y1="4" x2="7" y2="8"/><line x1="7" y1="16" x2="7" y2="20"/><rect x="15" y="6" width="4" height="10" fill="currentColor"/><line x1="17" y1="2" x2="17" y2="6"/><line x1="17" y1="16" x2="17" y2="22"/></svg>
                            </button>
                        </div>
                        <div class="studies-dropdown">
                            <button class="studies-btn" id="studies-btn" onclick="toggleStudiesMenu()">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M3 3v18h18"/><path d="M7 16l4-8 4 4 5-9"/></svg>
                                Studies
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><path d="M6 9l6 6 6-6"/></svg>
                            </button>
                            <div class="studies-menu" id="studies-menu">
                                <div class="studies-item" onclick="toggleStudy('sma10')">
                                    <div class="studies-item-label">
                                        <span class="studies-color" style="background: #facc15;"></span>
                                        SMA (10)
                                    </div>
                                    <div class="studies-toggle" id="toggle-sma10"></div>
                                </div>
                                <div class="studies-item" onclick="toggleStudy('sma20')">
                                    <div class="studies-item-label">
                                        <span class="studies-color" style="background: #f59e0b;"></span>
                                        SMA (20)
                                    </div>
                                    <div class="studies-toggle" id="toggle-sma20"></div>
                                </div>
                                <div class="studies-item" onclick="toggleStudy('sma50')">
                                    <div class="studies-item-label">
                                        <span class="studies-color" style="background: #8b5cf6;"></span>
                                        SMA (50)
                                    </div>
                                    <div class="studies-toggle" id="toggle-sma50"></div>
                                </div>
                                <div class="studies-divider"></div>
                                <div class="studies-item" onclick="toggleStudy('ema10')">
                                    <div class="studies-item-label">
                                        <span class="studies-color" style="background: #34d399;"></span>
                                        EMA (10)
                                    </div>
                                    <div class="studies-toggle" id="toggle-ema10"></div>
                                </div>
                                <div class="studies-item" onclick="toggleStudy('ema20')">
                                    <div class="studies-item-label">
                                        <span class="studies-color" style="background: #10b981;"></span>
                                        EMA (20)
                                    </div>
                                    <div class="studies-toggle" id="toggle-ema20"></div>
                                </div>
                                <div class="studies-divider"></div>
                                <div class="studies-item" onclick="toggleStudy('bollinger')">
                                    <div class="studies-item-label">
                                        <span class="studies-color" style="background: #60a5fa;"></span>
                                        Bollinger Bands
                                    </div>
                                    <div class="studies-toggle" id="toggle-bollinger"></div>
                                </div>
                                <div class="studies-divider"></div>
                                <div class="studies-item" onclick="toggleStudy('rsi')">
                                    <div class="studies-item-label">
                                        <span class="studies-color" style="background: #ec4899;"></span>
                                        RSI (14)
                                    </div>
                                    <div class="studies-toggle" id="toggle-rsi"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="chart-container" id="chart-container">
                    <canvas id="priceChart" class="chart-canvas"></canvas>
                    <div class="chart-tooltip" id="chart-tooltip"></div>
                    <div class="chart-crosshair" id="chart-crosshair">
                        <div class="crosshair-v"></div>
                        <div class="crosshair-h"></div>
                    </div>
                </div>
                
                <!-- RSI Sub-Chart -->
                <div class="rsi-chart-container" id="rsi-chart-container" style="display: none;">
                    <div class="rsi-header">
                        <span class="rsi-label">RSI (14)</span>
                        <span class="rsi-value" id="rsi-value">â€”</span>
                    </div>
                    <canvas id="rsiChart" class="rsi-canvas"></canvas>
                    <div class="rsi-crosshair" id="rsi-crosshair">
                        <div class="crosshair-v"></div>
                        <div class="crosshair-h"></div>
                    </div>
                    <div class="rsi-tooltip" id="rsi-tooltip"></div>
                </div>
                
                <!-- Trading Hub (shown when maximized) -->
                <div class="trading-hub-container" id="trading-hub-container">
                    <button class="trading-hub-close-btn" onclick="toggleMaximize('chart-section')" title="Exit Trading Hub">Ã—</button>
                    
                    <div class="trading-hub-main">
                        <!-- Chart Area -->
                        <div class="trading-hub-chart-area">
                            <div class="trading-hub-chart-header">
                                <div class="trading-hub-chart-title">
                                    <h3 id="hub-chart-title">Kenyan Tea Price Index</h3>
                                    <span class="chart-badge">Live</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 16px;">
                                    <span class="trading-hub-price up" id="hub-chart-price">$3.42</span>
                                    <span class="trading-hub-change up" id="hub-chart-change">+2.4%</span>
                                    <div class="chart-controls" style="border: none; padding: 0;">
                                        <div class="timeframe-dropdown">
                                            <button class="timeframe-btn" id="hub-timeframe-btn" onclick="toggleHubTimeframeMenu()">
                                                <span id="hub-timeframe-label">1W</span>
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><path d="M6 9l6 6 6-6"/></svg>
                                            </button>
                                            <div class="timeframe-menu" id="hub-timeframe-menu">
                                                <div class="timeframe-item" onclick="setHubTimeframe('1D')">1D</div>
                                                <div class="timeframe-item active" onclick="setHubTimeframe('1W')">1W</div>
                                                <div class="timeframe-item" onclick="setHubTimeframe('1M')">1M</div>
                                                <div class="timeframe-item" onclick="setHubTimeframe('3M')">3M</div>
                                                <div class="timeframe-item" onclick="setHubTimeframe('1Y')">1Y</div>
                                            </div>
                                        </div>
                                        <div class="chart-type-toggle">
                                            <button class="chart-type-btn active" id="hub-btn-line" onclick="setHubChartType('line')" title="Line Chart">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 17l6-6 4 4 8-8"/></svg>
                                            </button>
                                            <button class="chart-type-btn" id="hub-btn-candle" onclick="setHubChartType('candle')" title="Candlestick">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="5" y="8" width="4" height="8"/><line x1="7" y1="4" x2="7" y2="8"/><line x1="7" y1="16" x2="7" y2="20"/><rect x="15" y="6" width="4" height="10" fill="currentColor"/><line x1="17" y1="2" x2="17" y2="6"/><line x1="17" y1="16" x2="17" y2="22"/></svg>
                                            </button>
                                        </div>
                                        <div class="studies-dropdown">
                                            <button class="studies-btn" id="hub-studies-btn" onclick="toggleHubStudiesMenu()">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M3 3v18h18"/><path d="M7 16l4-8 4 4 5-9"/></svg>
                                                Studies
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><path d="M6 9l6 6 6-6"/></svg>
                                            </button>
                                            <div class="studies-menu" id="hub-studies-menu">
                                                <div class="studies-item" onclick="toggleHubStudy('sma10')">
                                                    <div class="studies-item-label">
                                                        <span class="studies-color" style="background: #facc15;"></span>
                                                        SMA (10)
                                                    </div>
                                                    <div class="studies-toggle" id="hub-toggle-sma10"></div>
                                                </div>
                                                <div class="studies-item" onclick="toggleHubStudy('sma20')">
                                                    <div class="studies-item-label">
                                                        <span class="studies-color" style="background: #f59e0b;"></span>
                                                        SMA (20)
                                                    </div>
                                                    <div class="studies-toggle" id="hub-toggle-sma20"></div>
                                                </div>
                                                <div class="studies-item" onclick="toggleHubStudy('bollinger')">
                                                    <div class="studies-item-label">
                                                        <span class="studies-color" style="background: #60a5fa;"></span>
                                                        Bollinger Bands
                                                    </div>
                                                    <div class="studies-toggle" id="hub-toggle-bollinger"></div>
                                                </div>
                                                <div class="studies-divider"></div>
                                                <div class="studies-item" onclick="toggleHubStudy('rsi')">
                                                    <div class="studies-item-label">
                                                        <span class="studies-color" style="background: #ec4899;"></span>
                                                        RSI (14)
                                                    </div>
                                                    <div class="studies-toggle" id="hub-toggle-rsi"></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="trading-hub-canvas-wrapper" id="hub-canvas-wrapper" style="min-height: 350px; flex: 1; position: relative; cursor: crosshair;">
                                <canvas id="hubPriceChart" width="800" height="350" style="display: block; position: absolute; top: 0; left: 0;"></canvas>
                                <div class="hub-crosshair" id="hub-crosshair">
                                    <div class="hub-crosshair-v"></div>
                                    <div class="hub-crosshair-h"></div>
                                </div>
                                <div class="hub-tooltip" id="hub-tooltip"></div>
                            </div>
                        </div>
                        
                        <!-- RSI Section with Resizer -->
                        <div class="trading-hub-rsi-section" id="hub-rsi-section">
                            <div class="rsi-resize-handle" id="rsi-resize-handle"></div>
                            <div class="trading-hub-rsi-header">
                                <span>RSI (14)</span>
                                <span id="hub-rsi-value">â€”</span>
                            </div>
                            <canvas id="hubRsiChart" class="trading-hub-rsi-canvas"></canvas>
                        </div>
                        
                        <!-- Live Trade Log -->
                        <div class="trading-hub-log">
                            <div class="trading-hub-log-header">
                                <h4>Live Trade Tape</h4>
                                <span style="font-size: 10px; color: var(--text-muted);">Auto-updating</span>
                            </div>
                            <div class="trading-hub-log-content" id="trade-log-content">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Trading Sidebar -->
                    <div class="trading-hub-sidebar">
                        <div class="trade-panel">
                            <div class="trade-tabs">
                                <button class="trade-tab active" data-tab="hub-buy" onclick="switchHubTradeTab('hub-buy')">Buy</button>
                                <button class="trade-tab" data-tab="hub-sell" onclick="switchHubTradeTab('hub-sell')">Sell</button>
                            </div>
                            
                            <div class="trade-form" id="hub-buy-form">
                                <div class="form-group">
                                    <label>Symbol</label>
                                    <select id="hub-buy-symbol" class="form-input" onchange="updateHubOrderPreview()">
                                        <option value="TEA-KE">TEA-KE (Kenya)</option>
                                        <option value="TEA-LK">TEA-LK (Sri Lanka)</option>
                                        <option value="TEA-IN">TEA-IN (India)</option>
                                        <option value="TEA-CN">TEA-CN (China)</option>
                                        <option value="TEA-JP">TEA-JP (Japan)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Order Type</label>
                                    <select id="hub-buy-order-type" class="form-input" onchange="updateHubOrderPreview()">
                                        <option value="market">Market Order</option>
                                        <option value="limit">Limit Order</option>
                                        <option value="stop">Stop Order</option>
                                    </select>
                                </div>
                                <div class="form-group" id="hub-buy-limit-price-group" style="display: none;">
                                    <label>Limit Price ($/kg)</label>
                                    <input type="number" id="hub-buy-limit-price" class="form-input" placeholder="0.00" step="0.01" onchange="updateHubOrderPreview()">
                                </div>
                                <div class="form-group">
                                    <label>Quantity (kg)</label>
                                    <input type="number" id="hub-buy-quantity" class="form-input" placeholder="Enter amount" min="1" oninput="updateHubOrderPreview()">
                                    <div class="quick-amounts">
                                        <button type="button" onclick="setHubQuickAmount('buy', 100)">100</button>
                                        <button type="button" onclick="setHubQuickAmount('buy', 500)">500</button>
                                        <button type="button" onclick="setHubQuickAmount('buy', 1000)">1K</button>
                                        <button type="button" onclick="setHubQuickAmount('buy', 5000)">5K</button>
                                    </div>
                                </div>
                                <div class="order-preview">
                                    <div class="preview-row">
                                        <span>Est. Price</span>
                                        <span id="hub-buy-est-price">$0.00</span>
                                    </div>
                                    <div class="preview-row">
                                        <span>Total Cost</span>
                                        <span id="hub-buy-total-cost">$0.00</span>
                                    </div>
                                    <div class="preview-row">
                                        <span>Commission</span>
                                        <span id="hub-buy-commission">$0.00</span>
                                    </div>
                                </div>
                                <button class="trade-button buy" onclick="executeHubTrade('buy')">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
                                    Place Buy Order
                                </button>
                            </div>
                            
                            <div class="trade-form" id="hub-sell-form" style="display: none;">
                                <div class="form-group">
                                    <label>Symbol</label>
                                    <select id="hub-sell-symbol" class="form-input" onchange="updateHubOrderPreview()">
                                        <option value="TEA-KE">TEA-KE (Kenya)</option>
                                        <option value="TEA-LK">TEA-LK (Sri Lanka)</option>
                                        <option value="TEA-IN">TEA-IN (India)</option>
                                        <option value="TEA-CN">TEA-CN (China)</option>
                                        <option value="TEA-JP">TEA-JP (Japan)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Order Type</label>
                                    <select id="hub-sell-order-type" class="form-input" onchange="updateHubOrderPreview()">
                                        <option value="market">Market Order</option>
                                        <option value="limit">Limit Order</option>
                                        <option value="stop">Stop Order</option>
                                    </select>
                                </div>
                                <div class="form-group" id="hub-sell-limit-price-group" style="display: none;">
                                    <label>Limit Price ($/kg)</label>
                                    <input type="number" id="hub-sell-limit-price" class="form-input" placeholder="0.00" step="0.01" onchange="updateHubOrderPreview()">
                                </div>
                                <div class="form-group">
                                    <label>Quantity (kg)</label>
                                    <input type="number" id="hub-sell-quantity" class="form-input" placeholder="Enter amount" min="1" oninput="updateHubOrderPreview()">
                                    <div class="quick-amounts">
                                        <button type="button" onclick="setHubQuickAmount('sell', 100)">100</button>
                                        <button type="button" onclick="setHubQuickAmount('sell', 500)">500</button>
                                        <button type="button" onclick="setHubQuickAmount('sell', 1000)">1K</button>
                                        <button type="button" onclick="setHubQuickAmount('sell', 5000)">5K</button>
                                    </div>
                                </div>
                                <div class="order-preview">
                                    <div class="preview-row">
                                        <span>Est. Price</span>
                                        <span id="hub-sell-est-price">$0.00</span>
                                    </div>
                                    <div class="preview-row">
                                        <span>Total Value</span>
                                        <span id="hub-sell-total-cost">$0.00</span>
                                    </div>
                                    <div class="preview-row">
                                        <span>Commission</span>
                                        <span id="hub-sell-commission">$0.00</span>
                                    </div>
                                </div>
                                <button class="trade-button sell" onclick="executeHubTrade('sell')">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><path d="M12 5v14M5 12l7 7 7-7"/></svg>
                                    Place Sell Order
                                </button>
                            </div>
                        </div>
                        
                        <!-- Position Summary in Hub -->
                        <div class="position-summary-hub" style="padding: 16px; border-top: 1px solid var(--border);">
                            <h4 style="font-size: 12px; color: var(--text-muted); margin-bottom: 12px; text-transform: uppercase;">Your Position</h4>
                            <div id="hub-position-info" style="font-size: 13px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span style="color: var(--text-muted);">Holdings</span>
                                    <span id="hub-position-qty">â€” kg</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span style="color: var(--text-muted);">Avg Entry</span>
                                    <span id="hub-position-entry">$â€”</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: var(--text-muted);">P&L</span>
                                    <span id="hub-position-pnl">$â€”</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Market Depth Heatmap -->
                <div class="market-depth-container" id="market-depth-container">
                    <div class="market-depth-header">
                        <span class="market-depth-title">Market Depth</span>
                        <span class="market-depth-ratio" id="depth-ratio">Bid/Ask: 1.12</span>
                    </div>
                    <div class="market-depth-bar">
                        <div class="depth-bids" id="depth-bids" style="width: 52%;">
                            <span class="depth-label">BIDS 52%</span>
                        </div>
                        <div class="depth-asks" id="depth-asks" style="width: 48%;">
                            <span class="depth-label">ASKS 48%</span>
                        </div>
                    </div>
                    <div class="market-depth-levels">
                        <span id="depth-bid-volume">Vol: 12,450 kg</span>
                        <span id="depth-mid-price">Mid: $4.82</span>
                        <span id="depth-ask-volume">Vol: 11,200 kg</span>
                    </div>
                </div>
            </div>

            <!-- Flash Quote Board -->
            <div class="quote-board-section">
                <div class="quote-board" id="quote-board">
                    <!-- Populated by JS -->
                </div>
            </div>

            <!-- Auction Data Table -->
            <div class="auction-section">
                <div class="section-header">
                    <div class="section-title">Live Auction Results â€” Mombasa Sale 06/2026</div>
                    <div class="section-filters">
                        <div class="market-toggle">
                            <button class="toggle-btn active" id="toggle-singles" onclick="setMarketView('singles')">Singles</button>
                            <button class="toggle-btn" id="toggle-pairs" onclick="setMarketView('pairs')">Pairs</button>
                        </div>
                        <div class="grade-filters" id="grade-filters">
                            <button class="filter-btn active">All Grades</button>
                            <button class="filter-btn">Orthodox</button>
                            <button class="filter-btn">CTC</button>
                        </div>
                    </div>
                </div>
                <!-- Singles Table -->
                <div id="singles-view">
                <div class="auction-table-wrapper">
                <table class="data-table" id="auction-table">
                    <thead>
                        <tr>
                            <th>Lot #</th>
                            <th>Grade</th>
                            <th>Estate / Factory</th>
                            <th>Origin</th>
                            <th>Qty (kg)</th>
                            <th>Bid $/kg</th>
                            <th>Change</th>
                            <th>Buyer</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="auction-table-body">
                        <!-- Populated dynamically from database -->
                    </tbody>
                </table>
                </div>
                </div>
                <!-- Pairs Table -->
                <div id="pairs-view" style="display: none;">
                <div class="pairs-table-wrapper">
                <table class="data-table" id="pairs-table">
                    <thead>
                        <tr>
                            <th class="sortable" data-sort="pair" onclick="sortPairsTable('pair')">Pair</th>
                            <th class="sortable" data-sort="base" onclick="sortPairsTable('base')">Base</th>
                            <th class="sortable" data-sort="quote" onclick="sortPairsTable('quote')">Quote</th>
                            <th class="sortable" data-sort="ratio" onclick="sortPairsTable('ratio')">Ratio</th>
                            <th class="sortable" data-sort="change" onclick="sortPairsTable('change')">Change</th>
                            <th class="sortable" data-sort="spread" onclick="sortPairsTable('spread')">Spread</th>
                        </tr>
                    </thead>
                    <tbody id="pairs-table-body">
                        <!-- Populated dynamically -->
                    </tbody>
                </table>
                </div>
                </div>
            </div>
        
            <!-- Order History Section -->
            <div class="order-history-section">
                <div class="order-history-header">
                    <div class="order-history-title">
                        Your Confirmed Orders
                        <span class="order-count" id="order-count">0</span>
                    </div>
                    <div class="order-filter-buttons">
                        <button class="filter-btn" id="filter-open" onclick="setOrdersFilter('open')">Open</button>
                        <button class="filter-btn active" id="filter-all" onclick="setOrdersFilter('all')">All</button>
                    </div>
                </div>
                <div class="order-table-wrapper">
                <table class="order-table" id="orders-table">
                    <thead>
                        <tr>
                            <th class="sortable" data-sort="time" onclick="sortOrdersTable('time')">Time</th>
                            <th>Order ID</th>
                            <th class="sortable" data-sort="tea" onclick="sortOrdersTable('tea')">Tea</th>
                            <th>Side</th>
                            <th class="sortable" data-sort="qty" onclick="sortOrdersTable('qty')">Qty (kg)</th>
                            <th class="sortable" data-sort="entry" onclick="sortOrdersTable('entry')">Entry</th>
                            <th class="sortable" data-sort="total" onclick="sortOrdersTable('total')">Total</th>
                            <th class="sortable" data-sort="pnl" onclick="sortOrdersTable('pnl')">P/L</th>
                            <th class="sortable" data-sort="status" onclick="sortOrdersTable('status')">Status</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody id="orders-tbody">
                        <tr>
                            <td colspan="10" style="text-align: center; color: var(--text-muted); padding: 20px;">
                                No orders yet. Start trading!
                            </td>
                        </tr>
                    </tbody>
                    <tfoot id="orders-tfoot" style="display: none;">
                        <tr>
                            <td colspan="4" style="text-align: right; color: var(--text-muted);">OPEN POSITIONS TOTAL</td>
                            <td></td>
                            <td></td>
                            <td id="tfoot-total" class="order-price">$0.00</td>
                            <td id="tfoot-pnl">$0.00</td>
                            <td id="tfoot-count"><span style="color: var(--text-muted);">0 open</span></td>
                            <td></td>
                        </tr>
                    </tfoot>
                </table>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Trading Panel -->
            <div class="panel-section trading-panel">
                <div class="panel-title">
                    Trade
                    <span class="live-badge">PAPER</span>
                </div>
                <div class="trade-form" id="trade-form">
                    <div class="trade-type-toggle">
                        <button type="button" class="trade-type-btn buy active" id="btn-trade-buy" onclick="setTradeType('BUY')">BUY</button>
                        <button type="button" class="trade-type-btn sell" id="btn-trade-sell" onclick="setTradeType('SELL')">SELL</button>
                    </div>
                    <select class="trade-select" id="trade-tea-select" onchange="updateTradeSummary()">
                        <option value="">Select Tea...</option>
                    </select>
                    <div class="trade-input-row">
                        <div class="trade-input-group">
                            <label>Quantity (kg)</label>
                            <input type="number" class="trade-input" id="trade-qty" placeholder="100" min="1" step="1" oninput="updateTradeSummary()">
                        </div>
                        <div class="trade-input-group">
                            <label>Price ($/kg)</label>
                            <input type="number" class="trade-input" id="trade-price" placeholder="3.42" step="0.001" readonly>
                        </div>
                    </div>
                    <div class="trade-summary">
                        <div class="trade-summary-row">
                            <span class="trade-summary-label">Order Value</span>
                            <span class="trade-summary-value" id="trade-value">$0.00</span>
                        </div>
                        <div class="trade-summary-row">
                            <span class="trade-summary-label">Your Balance</span>
                            <span class="trade-summary-value" id="trade-balance">$10,000.00</span>
                        </div>
                    </div>
                    <div class="sltp-section">
                        <div class="sltp-group">
                            <label class="sltp-label"><span class="dot sl"></span>Stop Loss</label>
                            <div class="sltp-input-wrapper">
                                <input type="number" class="sltp-input" id="trade-sl" placeholder="3.20" step="0.01">
                                <div class="sltp-arrows">
                                    <button type="button" class="sltp-arrow" onclick="adjustSlTp('trade-sl', 0.01)">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M18 15l-6-6-6 6"/></svg>
                                    </button>
                                    <button type="button" class="sltp-arrow" onclick="adjustSlTp('trade-sl', -0.01)">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M6 9l6 6 6-6"/></svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="sltp-group">
                            <label class="sltp-label"><span class="dot tp"></span>Take Profit</label>
                            <div class="sltp-input-wrapper">
                                <input type="number" class="sltp-input" id="trade-tp" placeholder="3.80" step="0.01">
                                <div class="sltp-arrows">
                                    <button type="button" class="sltp-arrow" onclick="adjustSlTp('trade-tp', 0.01)">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M18 15l-6-6-6 6"/></svg>
                                    </button>
                                    <button type="button" class="sltp-arrow" onclick="adjustSlTp('trade-tp', -0.01)">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M6 9l6 6 6-6"/></svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="trade-execute-btn buy" id="trade-execute-btn" onclick="executeTrade()">
                        Sign in to Trade
                    </button>
                </div>
            </div>

            <!-- Portfolio Section -->
            <div class="panel-section portfolio-section" id="portfolio-section" style="display: none;">
                <div class="panel-title">Your Portfolio</div>
                <div class="portfolio-tabs">
                    <button class="portfolio-tab active" onclick="switchPortfolioTab('positions')">Positions</button>
                    <button class="portfolio-tab" onclick="switchPortfolioTab('history')">History</button>
                </div>
                <div id="portfolio-positions" class="trade-log-container active">
                    <div class="portfolio-header">
                        <div>
                            <div class="portfolio-value" id="portfolio-value">$10,000.00</div>
                            <div class="portfolio-pnl up" id="portfolio-pnl">+$0.00 (0.00%)</div>
                        </div>
                    </div>
                    <div id="positions-list">
                        <div style="color: var(--text-muted); font-size: 12px; padding: 20px 0; text-align: center;">
                            No positions yet. Start trading!
                        </div>
                    </div>
                </div>
                <div id="portfolio-history" class="trade-log-container">
                    <div class="trade-log-stats">
                        <div class="trade-stat">
                            <div class="trade-stat-value up" id="stat-total-pnl">+$0.00</div>
                            <div class="trade-stat-label">Total P&L</div>
                        </div>
                        <div class="trade-stat">
                            <div class="trade-stat-value" id="stat-win-rate">0%</div>
                            <div class="trade-stat-label">Win Rate</div>
                        </div>
                        <div class="trade-stat">
                            <div class="trade-stat-value" id="stat-trades">0</div>
                            <div class="trade-stat-label">Total Trades</div>
                        </div>
                        <div class="trade-stat">
                            <div class="trade-stat-value" id="stat-avg-hold">â€”</div>
                            <div class="trade-stat-label">Avg Hold</div>
                        </div>
                    </div>
                    <table class="trade-log-table">
                        <thead>
                            <tr>
                                <th>Tea</th>
                                <th>Type</th>
                                <th>Entry</th>
                                <th>Exit</th>
                                <th>P&L</th>
                                <th>Hold</th>
                            </tr>
                        </thead>
                        <tbody id="trade-log-body">
                            <tr>
                                <td colspan="6" style="text-align: center; color: var(--text-muted); padding: 20px;">No closed trades yet</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Leaderboard Section -->
            <div class="panel-section leaderboard-section">
                <div class="panel-title">
                    Leaderboard
                    <span style="font-size: 10px; color: var(--accent-orange);">FEB 2026</span>
                </div>
                <div id="leaderboard-list">
                    <div class="leaderboard-item">
                        <div class="leaderboard-rank gold">1</div>
                        <div class="leaderboard-name">tea_magnate</div>
                        <div class="leaderboard-return up">+24.5%</div>
                    </div>
                    <div class="leaderboard-item">
                        <div class="leaderboard-rank silver">2</div>
                        <div class="leaderboard-name">ceylon_king</div>
                        <div class="leaderboard-return up">+18.2%</div>
                    </div>
                    <div class="leaderboard-item">
                        <div class="leaderboard-rank bronze">3</div>
                        <div class="leaderboard-name">mombasa_trader</div>
                        <div class="leaderboard-return up">+15.7%</div>
                    </div>
                    <div class="leaderboard-item">
                        <div class="leaderboard-rank">4</div>
                        <div class="leaderboard-name">darjeeling_pro</div>
                        <div class="leaderboard-return up">+12.1%</div>
                    </div>
                    <div class="leaderboard-item">
                        <div class="leaderboard-rank">5</div>
                        <div class="leaderboard-name">assam_bull</div>
                        <div class="leaderboard-return up">+9.8%</div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">
                    Market News
                    <span class="live-badge">LIVE</span>
                </div>
                <div class="news-feed">
                    <div class="news-item">
                        <div class="news-time">14:32 UTC</div>
                        <div class="news-headline">
                            <span class="news-tag kenya">KENYA</span>
                            Mombasa auction sees record volume as BP1 grades surge 4.2%
                        </div>
                    </div>
                    <div class="news-item">
                        <div class="news-time">14:18 UTC</div>
                        <div class="news-headline">
                            <span class="news-tag india">INDIA</span>
                            Darjeeling first flush arrives early; quality reports exceptional
                        </div>
                    </div>
                    <div class="news-item">
                        <div class="news-time">13:45 UTC</div>
                        <div class="news-headline">
                            <span class="news-tag sri-lanka">SRI LANKA</span>
                            Ceylon tea exports up 8% YoY as European demand strengthens
                        </div>
                    </div>
                    <div class="news-item">
                        <div class="news-time">12:20 UTC</div>
                        <div class="news-headline">
                            <span class="news-tag china">CHINA</span>
                            Yunnan Pu-erh vintage releases fetch premium at Kunming fair
                        </div>
                    </div>
                    <div class="news-item">
                        <div class="news-time">11:05 UTC</div>
                        <div class="news-headline">
                            <span class="news-tag kenya">KENYA</span>
                            Weather outlook favorable for Q1 harvest across Rift Valley
                        </div>
                    </div>
                </div>
            </div>

            <!-- Order Book / Depth of Market -->
            <div class="panel-section order-book-section">
                <div class="panel-title">
                    Order Book (Mombasa BP1)
                    <span class="live-badge">LIVE</span>
                </div>
                
                <div class="order-book-container">
                    <div class="ob-row ob-header">
                        <span>Price (USD)</span>
                        <span>Qty (Tons)</span>
                        <span>Total</span>
                    </div>

                    <!-- Asks (Sellers) -->
                    <div class="ob-row">
                        <span class="ob-price-down">3.48</span>
                        <span>12.5</span>
                        <span>45.2</span>
                        <div class="depth-bar ask-bar" style="width: 20%"></div>
                    </div>
                    <div class="ob-row">
                        <span class="ob-price-down">3.47</span>
                        <span>45.0</span>
                        <span>32.7</span>
                        <div class="depth-bar ask-bar" style="width: 60%"></div>
                    </div>
                    <div class="ob-row">
                        <span class="ob-price-down">3.46</span>
                        <span>22.1</span>
                        <span>22.1</span>
                        <div class="depth-bar ask-bar" style="width: 35%"></div>
                    </div>

                    <!-- Spread -->
                    <div class="ob-spread">
                        <span class="ob-spread-label">Spread: 0.02 (0.58%)</span>
                        <div class="ob-spread-price">$3.44</div>
                    </div>

                    <!-- Bids (Buyers) -->
                    <div class="ob-row">
                        <span class="ob-price-up">3.44</span>
                        <span>150.0</span>
                        <span>150.0</span>
                        <div class="depth-bar bid-bar" style="width: 90%"></div>
                    </div>
                    <div class="ob-row">
                        <span class="ob-price-up">3.43</span>
                        <span>80.5</span>
                        <span>230.5</span>
                        <div class="depth-bar bid-bar" style="width: 50%"></div>
                    </div>
                    <div class="ob-row">
                        <span class="ob-price-up">3.42</span>
                        <span>40.2</span>
                        <span>270.7</span>
                        <div class="depth-bar bid-bar" style="width: 30%"></div>
                    </div>
                    <div class="ob-row">
                        <span class="ob-price-up">3.41</span>
                        <span>65.8</span>
                        <span>336.5</span>
                        <div class="depth-bar bid-bar" style="width: 45%"></div>
                    </div>
                    <div class="ob-row">
                        <span class="ob-price-up">3.40</span>
                        <span>28.3</span>
                        <span>364.8</span>
                        <div class="depth-bar bid-bar" style="width: 22%"></div>
                    </div>

                    <!-- Lock Overlay -->
                    <div class="ob-blur-overlay">
                        <div class="ob-lock-content">
                            <div class="ob-lock-icon">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                                    <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                                </svg>
                            </div>
                            <h4>Institutional Data</h4>
                            <p>Real-time bid/ask depth limited to Exchange Partners</p>
                            <button class="ob-btn-access" onclick="document.getElementById('early-access-modal').style.display='flex'">Request Access</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">Top Buyers This Week</div>
                <div style="font-size: 13px;">
                    <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border);">
                        <span>1. Unilever</span>
                        <span style="font-family: 'JetBrains Mono', monospace;">2.4M kg</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border);">
                        <span>2. Tata Global</span>
                        <span style="font-family: 'JetBrains Mono', monospace;">1.8M kg</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border);">
                        <span>3. Finlays</span>
                        <span style="font-family: 'JetBrains Mono', monospace;">1.2M kg</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border);">
                        <span>4. Van Rees</span>
                        <span style="font-family: 'JetBrains Mono', monospace;">980K kg</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                        <span>5. Ekaterra</span>
                        <span style="font-family: 'JetBrains Mono', monospace;">850K kg</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bottom Bar -->
    <div class="bottom-bar">
        <div class="bottom-stat">
            <span>Last Update: <span style="color: var(--text-primary);">14:32:08 UTC</span></span>
            <span>Session: <span style="color: var(--accent-green);">Active</span></span>
            <span>Latency: <span style="color: var(--text-primary);">24ms</span></span>
        </div>
        <div class="bottom-stat">
            <span>Markets: <span style="color: var(--text-primary);">5 Open</span></span>
            <span>Lots Today: <span style="color: var(--text-primary);">847</span></span>
            <span>Â© 2026 TeaTrade Exchange</span>
        </div>
    </div>

    <script>
        // =============================================
        // SUPABASE INITIALIZATION - MUST BE FIRST
        // =============================================
        const SUPABASE_URL = 'https://uznxzyuknigzlxecjgtb.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV6bnh6eXVrbmlnemx4ZWNqZ3RiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA5Mzc5ODUsImV4cCI6MjA4NjUxMzk4NX0.BVOTqZ9kn2KCrNeF5675PNmMi9oJN3F6OoUnTtbpuIg';
        const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // Global State
        let currentUser = null;
        let userProfile = null;
        let teas = [];
        let positions = [];
        
        // Chart state
        let currentTimeframe = '1W';
        let chartType = 'line'; // 'line' or 'candle'
        let chartData = [];
        let teaHistoricalData = {}; // Stores price history per tea symbol
        
        // =============================================
        // UNIFIED PRICE DATA CACHE (DATABASE-FIRST)
        // =============================================
        // All charts MUST use this cache for consistency
        const priceDataCache = {
            data: {},           // symbol -> array of OHLC data
            loaded: {},         // symbol -> boolean (true if loaded from DB)
            lastUpdate: {},     // symbol -> timestamp
            loading: {}         // symbol -> promise (if currently loading)
        };
        
        // Get price history for any symbol - always returns from unified cache
        // This is the ONLY function charts should use for data
        async function getPriceHistory(symbol, symbolType = 'tea') {
            const cacheKey = symbolType === 'index' ? `INDEX_${symbol}` : symbol;
            
            // Return cached data if available and recently updated (within 60s)
            if (priceDataCache.data[cacheKey] && priceDataCache.data[cacheKey].length > 0) {
                const age = Date.now() - (priceDataCache.lastUpdate[cacheKey] || 0);
                if (age < 60000) {
                    return priceDataCache.data[cacheKey];
                }
            }
            
            // If already loading, wait for it
            if (priceDataCache.loading[cacheKey]) {
                return priceDataCache.loading[cacheKey];
            }
            
            // Start loading from database
            priceDataCache.loading[cacheKey] = (async () => {
                try {
                    // Try database first
                    const dbData = await loadChartDataFromHistory(symbol, symbolType);
                    
                    if (dbData && dbData.length >= 10) {
                        priceDataCache.data[cacheKey] = dbData;
                        priceDataCache.loaded[cacheKey] = true;
                        priceDataCache.lastUpdate[cacheKey] = Date.now();
                        console.log(`Loaded ${dbData.length} points for ${cacheKey} from database`);
                        return dbData;
                    }
                    
                    // Database empty - generate FIXED historical data and SAVE to database
                    console.log(`No data for ${cacheKey} - seeding database with historical data...`);
                    let generatedData;
                    if (symbolType === 'index') {
                        generatedData = generateFixedHistoricalData(symbol, symbolType);
                    } else {
                        const tea = teas?.find(t => t.symbol === symbol);
                        generatedData = tea ? generateFixedHistoricalData(symbol, symbolType, tea.current_price) : [];
                    }
                    
                    if (generatedData && generatedData.length > 0) {
                        // SAVE to database immediately so it persists
                        await seedPriceHistoryToDatabase(symbol, symbolType, generatedData);
                        
                        priceDataCache.data[cacheKey] = generatedData;
                        priceDataCache.loaded[cacheKey] = true;
                        priceDataCache.lastUpdate[cacheKey] = Date.now();
                    }
                    
                    return priceDataCache.data[cacheKey] || [];
                } finally {
                    delete priceDataCache.loading[cacheKey];
                }
            })();
            
            return priceDataCache.loading[cacheKey];
        }
        
        // Synchronous version - returns cached data or empty array (use async version when possible)
        function getPriceHistorySync(symbol, symbolType = 'tea') {
            const cacheKey = symbolType === 'index' ? `INDEX_${symbol}` : symbol;
            
            if (priceDataCache.data[cacheKey] && priceDataCache.data[cacheKey].length > 0) {
                return priceDataCache.data[cacheKey];
            }
            
            // If not in cache, trigger async load and return generated fallback
            getPriceHistory(symbol, symbolType).catch(() => {});
            
            // Return from old cache systems for immediate rendering
            if (symbolType === 'index') {
                return indexHistoricalData[symbol] || teaHistoricalData[cacheKey] || [];
            }
            return teaHistoricalData[symbol] || [];
        }
        
        // Update the unified cache with a new price tick (called when prices change)
        function updatePriceCache(symbol, newPrice, symbolType = 'tea') {
            const cacheKey = symbolType === 'index' ? `INDEX_${symbol}` : symbol;
            const data = priceDataCache.data[cacheKey];
            
            if (!data || data.length === 0) return;
            
            const now = new Date();
            const lastCandle = data[data.length - 1];
            const lastCandleTime = lastCandle.date instanceof Date ? lastCandle.date.getTime() : new Date(lastCandle.date).getTime();
            
            // Determine candle interval from data
            const candleInterval = data.length > 1 
                ? (data[1].date instanceof Date ? data[1].date.getTime() : new Date(data[1].date).getTime()) - 
                  (data[0].date instanceof Date ? data[0].date.getTime() : new Date(data[0].date).getTime())
                : 3600000;
            
            if (now.getTime() - lastCandleTime < candleInterval) {
                // Update current candle
                lastCandle.high = Math.max(lastCandle.high, newPrice);
                lastCandle.low = Math.min(lastCandle.low, newPrice);
                lastCandle.close = newPrice;
            } else {
                // Create new candle
                data.push({
                    date: new Date(Math.floor(now.getTime() / candleInterval) * candleInterval),
                    open: lastCandle.close,
                    high: Math.max(lastCandle.close, newPrice),
                    low: Math.min(lastCandle.close, newPrice),
                    close: newPrice,
                    volume: 0
                });
                
                // Keep array at max 1000 candles
                if (data.length > 1000) data.shift();
            }
            
            // Update old cache systems for backward compatibility
            if (symbolType === 'index') {
                teaHistoricalData[cacheKey] = data;
                indexHistoricalData[symbol] = data;
            } else {
                teaHistoricalData[symbol] = data;
            }
        }
        
        // Initialize price cache from database for all known symbols
        async function initializePriceCache() {
            console.log('Initializing price cache from database...');
            const loadPromises = [];
            
            // Load all tea symbols
            if (teas && teas.length > 0) {
                teas.forEach(tea => {
                    loadPromises.push(getPriceHistory(tea.symbol, 'tea'));
                });
            }
            
            // Load all index symbols
            const indexSymbols = ['KENYA', 'INDIA', 'CEYLON', 'CHINA', 'JAPAN', 'AFRICA', 'ASIA', 'MOMBASA', 'KOLKATA', 'COLOMBO', 'FUTURES'];
            indexSymbols.forEach(symbol => {
                loadPromises.push(getPriceHistory(symbol, 'index'));
            });
            
            await Promise.allSettled(loadPromises);
            console.log('Price cache initialized');
        }
        
        // Generate historical data with FIXED timestamps (not relative to current time)
        // This ensures the same data is generated on every page load
        function generateFixedHistoricalData(symbol, symbolType, basePrice = null) {
            // Use FIXED base date - Jan 1, 2025 00:00:00 UTC
            const FIXED_EPOCH = new Date('2025-01-01T00:00:00Z').getTime();
            
            // Seeded random based on symbol for consistency
            const seed = symbol.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            let seededRandom = seed;
            const nextRandom = () => {
                seededRandom = (seededRandom * 9301 + 49297) % 233280;
                return seededRandom / 233280;
            };
            
            // Determine base price
            let startPrice;
            if (basePrice) {
                startPrice = basePrice;
            } else if (symbolType === 'index') {
                // Index base prices
                const indexPrices = {
                    'KENYA': 3.42, 'INDIA': 4.15, 'CEYLON': 3.89, 'CHINA': 2.67, 'JAPAN': 5.23,
                    'AFRICA': 2.95, 'ASIA': 3.45, 'MOMBASA': 2.87, 'KOLKATA': 267.45,
                    'COLOMBO': 3.24, 'FUTURES': 3847
                };
                startPrice = indexPrices[symbol] || 3.50;
            } else {
                // Tea base prices
                const teaPrices = {
                    'KEN-BP1': 3.42, 'KEN-PF1': 2.98, 'KEN-DUST': 2.15,
                    'IND-CTC': 4.12, 'IND-ORTH': 5.67, 'IND-DARJ': 12.45,
                    'SRI-BOP': 3.89, 'SRI-BOPF': 4.23, 'CHN-KEEM': 8.90,
                    'CHN-LONG': 15.60, 'JPN-SENC': 22.30, 'JPN-GYOK': 45.00,
                    'TW-OOLO': 18.75
                };
                startPrice = teaPrices[symbol] || 3.50;
            }
            
            // Generate 720 hourly candles (30 days)
            const data = [];
            let price = startPrice;
            const volatility = symbolType === 'index' ? 0.002 : 0.008;
            
            for (let i = 0; i < 720; i++) {
                const timestamp = FIXED_EPOCH + (i * 3600000); // Each candle = 1 hour
                
                // Generate OHLC with seeded random
                const change = (nextRandom() - 0.5) * 2 * volatility * price;
                const open = price;
                const close = Math.max(0.01, price + change);
                const high = Math.max(open, close) * (1 + nextRandom() * volatility * 0.5);
                const low = Math.min(open, close) * (1 - nextRandom() * volatility * 0.5);
                const volume = Math.round(10000 + nextRandom() * 50000);
                
                data.push({
                    date: new Date(timestamp),
                    open: open,
                    high: high,
                    low: Math.max(0.01, low),
                    close: close,
                    volume: volume
                });
                
                price = close;
            }
            
            return data;
        }
        
        // Save generated historical data to Supabase database
        async function seedPriceHistoryToDatabase(symbol, symbolType, data) {
            if (!supabaseClient || !data || data.length === 0) {
                console.warn(`Cannot seed ${symbol} - no supabase client or data`);
                return;
            }
            
            try {
                console.log(`Seeding ${data.length} candles for ${symbol} to database...`);
                
                // Convert OHLC data to multiple price ticks per candle for proper reconstruction
                // Store 4 ticks per hour: open (0min), high (15min), low (30min), close (45min)
                const records = [];
                data.forEach(candle => {
                    const baseTime = candle.date.getTime();
                    
                    // Open at 0 minutes
                    records.push({
                        symbol: symbol,
                        symbol_type: symbolType,
                        price: candle.open,
                        volume: Math.round((candle.volume || 0) / 4),
                        recorded_at: new Date(baseTime).toISOString()
                    });
                    
                    // High at 15 minutes
                    records.push({
                        symbol: symbol,
                        symbol_type: symbolType,
                        price: candle.high,
                        volume: Math.round((candle.volume || 0) / 4),
                        recorded_at: new Date(baseTime + 15 * 60 * 1000).toISOString()
                    });
                    
                    // Low at 30 minutes
                    records.push({
                        symbol: symbol,
                        symbol_type: symbolType,
                        price: candle.low,
                        volume: Math.round((candle.volume || 0) / 4),
                        recorded_at: new Date(baseTime + 30 * 60 * 1000).toISOString()
                    });
                    
                    // Close at 45 minutes
                    records.push({
                        symbol: symbol,
                        symbol_type: symbolType,
                        price: candle.close,
                        volume: Math.round((candle.volume || 0) / 4),
                        recorded_at: new Date(baseTime + 45 * 60 * 1000).toISOString()
                    });
                });
                
                // Insert in batches of 200 to avoid timeout
                const batchSize = 200;
                for (let i = 0; i < records.length; i += batchSize) {
                    const batch = records.slice(i, i + batchSize);
                    const { error } = await supabaseClient
                        .from('price_history')
                        .upsert(batch, { onConflict: 'symbol,recorded_at' });
                    
                    if (error) {
                        console.error(`Error seeding batch ${i/batchSize + 1} for ${symbol}:`, error);
                        // Continue with other batches even if one fails
                    }
                }
                
                console.log(`Successfully seeded ${records.length} records for ${symbol}`);
            } catch (err) {
                console.error(`Failed to seed ${symbol} to database:`, err);
            }
        }

        // Market indices data structure - tracks current data at each position
        // Prices will be updated dynamically from calculateMarketIndexes()
        let mainChartData = { name: 'Kenyan Tea Price Index', symbol: 'KENYA', basePrice: 3.42, change: 2.4, currency: '$', volume: '8.2M' };
        let cardData = [
            { name: 'Mombasa Auction Index', symbol: 'MOMBASA', basePrice: 2.87, change: 1.8, currency: '$', volume: '6.8M' },
            { name: 'Kolkata Tea Index', symbol: 'KOLKATA', basePrice: 267.45, change: 3.2, currency: 'â‚¹', volume: '4.2M' },
            { name: 'Colombo Index', symbol: 'COLOMBO', basePrice: 3.24, change: -1.8, currency: '$', volume: '5.1M' },
            { name: 'Global Tea Futures', symbol: 'FUTURES', basePrice: 3847, change: 0.7, currency: '$', volume: '12.4M' }
        ];
        let indexHistoricalData = {}; // Stores historical data for each index by symbol
        
        // Calculate market display indexes from real tea data
        function calculateMarketIndexes() {
            if (!teas || teas.length === 0) return null;
            
            const teaMap = {};
            teas.forEach(t => teaMap[t.symbol] = t);
            
            // Helper to calculate average price and change
            const calcIndex = (symbols, currency = '$', multiplier = 1) => {
                const validTeas = symbols.map(s => teaMap[s]).filter(t => t && t.current_price > 0);
                if (validTeas.length === 0) return { price: 0, change: 0 };
                
                const avgPrice = validTeas.reduce((sum, t) => sum + t.current_price, 0) / validTeas.length * multiplier;
                const avgPrevPrice = validTeas.reduce((sum, t) => sum + (t.previous_price || t.current_price), 0) / validTeas.length * multiplier;
                const change = avgPrevPrice > 0 ? ((avgPrice - avgPrevPrice) / avgPrevPrice) * 100 : 0;
                
                return { price: avgPrice, change: change };
            };
            
            // KENYA Index - Kenya teas
            const kenya = calcIndex(['KEN-BP1', 'KEN-PF1', 'KEN-DUST']);
            
            // MOMBASA - Kenya auction (same as Kenya but displayed separately)
            const mombasa = calcIndex(['KEN-BP1', 'KEN-PF1', 'KEN-DUST']);
            
            // KOLKATA - India teas (in Rupees, ~83 INR per USD)
            const kolkata = calcIndex(['IND-ASM', 'IND-DRJ'], 'â‚¹', 83);
            
            // COLOMBO - Sri Lanka teas
            const colombo = calcIndex(['SRI-BOP', 'SRI-PEK']);
            
            // FUTURES - Global composite (all major teas, price per metric ton = price * 1000)
            const allSymbols = ['KEN-BP1', 'IND-ASM', 'SRI-BOP', 'CHN-YUN', 'IND-DRJ'];
            const futures = calcIndex(allSymbols, '$', 1000);
            
            return {
                KENYA: kenya,
                MOMBASA: mombasa,
                KOLKATA: kolkata,
                COLOMBO: colombo,
                FUTURES: futures
            };
        }
        
        // Update all market index displays with real calculated prices
        function updateAllMarketIndexes() {
            const indexes = calculateMarketIndexes();
            if (!indexes) return;
            
            // Update main chart if it's showing KENYA
            if (mainChartData.symbol === 'KENYA' && indexes.KENYA) {
                mainChartData.basePrice = indexes.KENYA.price;
                mainChartData.change = indexes.KENYA.change;
            }
            
            // Update card data
            cardData.forEach((card, i) => {
                const idx = indexes[card.symbol];
                if (idx) {
                    card.basePrice = idx.price;
                    card.change = idx.change;
                }
            });
            
            // Update DOM displays
            const priceEl = document.getElementById('main-chart-price');
            if (priceEl) {
                priceEl.textContent = formatIndexPrice(mainChartData.basePrice, mainChartData.currency);
                priceEl.className = 'chart-stat-value ' + (mainChartData.change >= 0 ? 'up' : 'down');
            }
            
            const changeEl = document.getElementById('main-chart-change');
            if (changeEl) {
                const changeVal = mainChartData.change >= 0 ? '+' : '';
                changeEl.textContent = `${changeVal}${mainChartData.change.toFixed(1)}%`;
            }
            
            // Update market cards
            cardData.forEach((card, i) => {
                const valueEl = document.getElementById(`card-value-${i}`);
                const changeEl = document.getElementById(`card-change-${i}`);
                
                if (valueEl) {
                    valueEl.textContent = formatIndexPrice(card.basePrice, card.currency);
                }
                if (changeEl) {
                    changeEl.textContent = (card.change >= 0 ? 'â–² +' : 'â–¼ ') + Math.abs(card.change).toFixed(1) + '%';
                    changeEl.className = 'market-card-change ' + (card.change >= 0 ? 'up' : 'down');
                }
            });
            
            // Clear cached historical data so charts regenerate with new prices
            indexHistoricalData = {};
        }
        
        // Generate historical data for an index
        function generateIndexHistory(index) {
            if (!index || indexHistoricalData[index.symbol]) return indexHistoricalData[index.symbol] || [];
            
            const currentPrice = index.basePrice;
            const change = index.change;
            const volatility = Math.abs(change) / 100 + 0.015;
            
            const data = [];
            const points = 720;
            const now = new Date();
            
            // Seeded random for consistency
            const seed = (index.symbol || 'INDEX').split('').reduce((a, c) => a + c.charCodeAt(0), 0) + 3000;
            const seededRandom = (i) => {
                const x = Math.sin(seed + i * 9999) * 10000;
                return x - Math.floor(x);
            };
            
            let price = currentPrice * (1 - change / 100); // Start from yesterday's close
            for (let i = points - 1; i >= 0; i--) {
                const date = new Date(now);
                date.setHours(date.getHours() - i);
                
                const trendBias = i < 24 ? (change / 100) / 24 : 0;
                const noise = (seededRandom(i) - 0.5) * volatility * currentPrice;
                
                const open = price;
                price = Math.max(currentPrice * 0.85, Math.min(currentPrice * 1.15, price + noise + trendBias * currentPrice));
                const close = i === 0 ? currentPrice : price;
                const high = Math.max(open, close) * (1 + seededRandom(i + 1000) * 0.008);
                const low = Math.min(open, close) * (1 - seededRandom(i + 2000) * 0.008);
                const volume = Math.round(50000 + seededRandom(i + 3000) * 200000);
                
                data.push({
                    date: date,
                    open: open,
                    high: high,
                    low: low,
                    close: close,
                    volume: volume,
                    change: ((close - open) / open * 100)
                });
            }
            
            indexHistoricalData[index.symbol] = data;
            return data;
        }
        
        // Swap chart with a market card index
        function swapChartIndex(cardIndex) {
            const clickedCardData = cardData[cardIndex];
            if (!clickedCardData) return;
            
            // Store current main chart data
            const previousMainData = { ...mainChartData };
            
            // Animate out
            const chartSection = document.getElementById('chart-section');
            chartSection.style.opacity = '0.7';
            chartSection.style.transform = 'scale(0.98)';
            
            setTimeout(() => {
                // Update main chart with clicked card's data
                mainChartData = { ...clickedCardData };
                document.getElementById('main-chart-title').textContent = mainChartData.name;
                const priceEl = document.getElementById('main-chart-price');
                priceEl.textContent = formatIndexPrice(mainChartData.basePrice, mainChartData.currency);
                priceEl.className = 'chart-stat-value ' + (mainChartData.change >= 0 ? 'up' : 'down');
                
                const changeVal = mainChartData.change >= 0 ? '+' : '';
                document.getElementById('main-chart-change').textContent = `${changeVal}${mainChartData.change.toFixed(1)}%`;
                document.getElementById('main-chart-volume').textContent = mainChartData.volume;
                
                // Update the clicked card with the previous main chart data
                cardData[cardIndex] = previousMainData;
                document.querySelector(`#market-card-${cardIndex} .market-card-label`).textContent = previousMainData.name;
                document.getElementById(`card-value-${cardIndex}`).textContent = formatIndexPrice(previousMainData.basePrice, previousMainData.currency);
                const cardChangeEl = document.getElementById(`card-change-${cardIndex}`);
                cardChangeEl.textContent = (previousMainData.change >= 0 ? 'â–² +' : 'â–¼ ') + Math.abs(previousMainData.change).toFixed(1) + '%';
                cardChangeEl.className = 'market-card-change ' + (previousMainData.change >= 0 ? 'up' : 'down');
                
                // Regenerate chart with new index data
                cachedTimeframe = null;
                chartData = [];
                drawChart();
                
                // Animate back in
                chartSection.style.opacity = '1';
                chartSection.style.transform = 'scale(1)';
            }, 150);
        }
        
        function formatIndexPrice(price, currency) {
            if (price >= 1000) {
                return currency + price.toLocaleString('en-US', { maximumFractionDigits: 0 });
            }
            return currency + price.toFixed(2);
        }
        
        // Generate and cache historical data for a specific tea
        function generateTeaHistory(tea) {
            if (!tea || !tea.symbol) return [];
            
            const symbol = tea.symbol;
            if (teaHistoricalData[symbol]) return teaHistoricalData[symbol];
            
            const currentPrice = tea.current_price || 3.20;
            const change24h = tea.price_change_24h || 0;
            const volatility = Math.abs(change24h) / 100 + 0.02; // More volatile teas have bigger swings
            
            // Generate realistic historical data points (30 days of hourly data = 720 points)
            const data = [];
            const points = 720;
            const now = new Date();
            
            // Seeded random for consistency across page loads
            const seed = symbol.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
            const seededRandom = (i) => {
                const x = Math.sin(seed + i * 9999) * 10000;
                return x - Math.floor(x);
            };
            
            // Work backwards from current price
            let price = currentPrice;
            for (let i = points - 1; i >= 0; i--) {
                const date = new Date(now);
                date.setHours(date.getHours() - i);
                
                // Add some trend based on the 24h change
                const trendBias = i < 24 ? (change24h / 100) / 24 : 0;
                const noise = (seededRandom(i) - 0.5) * volatility * currentPrice;
                
                const open = price;
                price = Math.max(currentPrice * 0.8, Math.min(currentPrice * 1.2, price + noise + trendBias * currentPrice));
                const close = i === 0 ? currentPrice : price; // Last point = current price
                const high = Math.max(open, close) * (1 + seededRandom(i + 1000) * 0.01);
                const low = Math.min(open, close) * (1 - seededRandom(i + 2000) * 0.01);
                const volume = Math.round(50000 + seededRandom(i + 3000) * 200000);
                
                data.push({
                    date: date,
                    open: open,
                    high: high,
                    low: low,
                    close: close,
                    volume: volume,
                    change: ((close - open) / open * 100)
                });
            }
            
            teaHistoricalData[symbol] = data;
            return data;
        }
        
        // Async version that tries to load from database first
        async function loadOrGenerateTeaHistory(tea) {
            if (!tea || !tea.symbol) return [];
            
            const symbol = tea.symbol;
            
            // Check memory cache first
            if (teaHistoricalData[symbol] && teaHistoricalData[symbol].length > 0) {
                return teaHistoricalData[symbol];
            }
            
            // Try to load from database
            const dbData = await loadChartDataFromHistory(symbol, 'tea');
            if (dbData && dbData.length >= 10) {
                teaHistoricalData[symbol] = dbData;
                console.log(`Loaded ${dbData.length} historical points for ${symbol} from database`);
                return dbData;
            }
            
            // Fall back to generated data
            console.log(`No history for ${symbol}, generating synthetic data`);
            return generateTeaHistory(tea);
        }
        
        // Async version for indexes
        async function loadOrGenerateIndexHistory(indexSymbol) {
            const cacheKey = `INDEX_${indexSymbol}`;
            
            // Check memory cache first
            if (teaHistoricalData[cacheKey] && teaHistoricalData[cacheKey].length > 0) {
                return teaHistoricalData[cacheKey];
            }
            
            // Try to load from database
            const dbData = await loadChartDataFromHistory(indexSymbol, 'index');
            if (dbData && dbData.length >= 10) {
                teaHistoricalData[cacheKey] = dbData;
                console.log(`Loaded ${dbData.length} historical points for ${indexSymbol} from database`);
                return dbData;
            }
            
            // Fall back to generated data
            console.log(`No history for ${indexSymbol} index, generating synthetic data`);
            return generateIndexHistoricalData(indexSymbol);
        }
        
        // Generate historical data for a regional index
        function generateIndexHistoricalData(indexSymbol) {
            const cacheKey = `INDEX_${indexSymbol}`;
            if (teaHistoricalData[cacheKey]) return teaHistoricalData[cacheKey];
            
            const indexes = calculateRegionalIndexes();
            const idx = indexes.find(i => i.symbol === indexSymbol);
            if (!idx) return [];
            
            const currentPrice = idx.price;
            const change = idx.change || 0;
            const volatility = Math.abs(change) / 100 + 0.015; // Indexes are slightly less volatile
            
            // Generate historical data (30 days hourly = 720 points)
            const data = [];
            const points = 720;
            const now = new Date();
            
            // Seeded random for consistency across page loads
            const seed = indexSymbol.split('').reduce((a, c) => a + c.charCodeAt(0), 0) + 1000;
            const seededRandom = (i) => {
                const x = Math.sin(seed + i * 9999) * 10000;
                return x - Math.floor(x);
            };
            
            let price = currentPrice;
            for (let i = points - 1; i >= 0; i--) {
                const date = new Date(now);
                date.setHours(date.getHours() - i);
                
                const trendBias = i < 24 ? (change / 100) / 24 : 0;
                const noise = (seededRandom(i) - 0.5) * volatility * currentPrice;
                
                const open = price;
                price = Math.max(currentPrice * 0.85, Math.min(currentPrice * 1.15, price + noise + trendBias * currentPrice));
                const close = i === 0 ? currentPrice : price;
                const high = Math.max(open, close) * (1 + seededRandom(i + 1000) * 0.008);
                const low = Math.min(open, close) * (1 - seededRandom(i + 2000) * 0.008);
                const volume = Math.round(100000 + seededRandom(i + 3000) * 500000);
                
                data.push({
                    date: date,
                    open: open,
                    high: high,
                    low: low,
                    close: close,
                    volume: volume,
                    change: ((close - open) / open * 100)
                });
            }
            
            teaHistoricalData[cacheKey] = data;
            return data;
        }
        let chartMetrics = {};
        let cachedTimeframe = null; // Track which timeframe data was generated for
        const leftMargin = 50;
        const rightMargin = 20;
        const bottomMargin = 25;
        
        // Studies state
        let activeStudies = {
            sma10: false,
            sma20: false,
            sma50: false,
            ema10: false,
            ema20: false,
            bollinger: false,
            rsi: false
        };
        
        const studyColors = {
            sma10: '#facc15',
            sma20: '#f59e0b',
            sma50: '#8b5cf6',
            ema10: '#34d399',
            ema20: '#10b981',
            bollinger: '#60a5fa',
            rsi: '#ec4899'
        };
        
        // Price alerts
        let priceAlerts = {};
        
        // Stop Loss / Take Profit pending orders
        // Structure: { teaId: { sl: number|null, tp: number|null, side: 'BUY'|'SELL', qty: number } }
        let pendingSlTpOrders = {};
        
        const canvas = document.getElementById('priceChart');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('chart-tooltip');
        const chartContainer = document.getElementById('chart-container');
        const crosshair = document.getElementById('chart-crosshair');
        
        // Timeframe configurations - need enough data points for indicators
        const timeframeConfig = {
            '1D': { points: 96, labels: ['00:00', '04:00', '08:00', '12:00', '16:00', '20:00', '24:00'], labelFormat: 'time', baseDate: new Date() },
            '1W': { points: 56, labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'], labelFormat: 'day', baseDate: new Date() },
            '1M': { points: 60, labels: ['W1', 'W2', 'W3', 'W4'], labelFormat: 'week', baseDate: new Date() },
            '3M': { points: 90, labels: ['Jan', 'Feb', 'Mar'], labelFormat: 'month', baseDate: new Date() },
            '1Y': { points: 120, labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], labelFormat: 'month', baseDate: new Date() },
            'ALL': { points: 180, labels: ['2021', '2022', '2023', '2024', '2025', '2026'], labelFormat: 'year', baseDate: new Date() }
        };
        
        function toggleTimeframeMenu() {
            const menu = document.getElementById('timeframe-menu');
            menu.classList.toggle('visible');
        }
        
        function setTimeframe(tf) {
            currentTimeframe = tf;
            
            // Update dropdown label
            document.getElementById('timeframe-label').textContent = tf;
            
            // Update active state in menu
            document.querySelectorAll('.timeframe-item').forEach(item => {
                item.classList.toggle('active', item.textContent === tf);
            });
            
            // Close menu
            document.getElementById('timeframe-menu').classList.remove('visible');
            
            drawChart();
        }
        
        // Close timeframe menu when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.querySelector('.timeframe-dropdown');
            if (dropdown && !dropdown.contains(e.target)) {
                document.getElementById('timeframe-menu').classList.remove('visible');
            }
        });
        
        function setChartType(type) {
            chartType = type;
            document.getElementById('btn-line').classList.toggle('active', type === 'line');
            document.getElementById('btn-candle').classList.toggle('active', type === 'candle');
            drawChart();
        }
        
        function generateChartData(timeframe) {
            const config = timeframeConfig[timeframe];
            if (!config) return generateDefaultChartData({ points: 50 }, timeframe || '1W');
            
            // Check if displaying the default Kenyan index (no tea selected)
            const select = document.getElementById('trade-tea-select');
            const selectedSymbol = select?.value;
            const selectedTea = teas && teas.find(t => t.symbol === selectedSymbol);
            
            // Use UNIFIED PRICE CACHE for consistent data across all charts
            let fullHistory;
            if (selectedTea) {
                // Get tea history from unified cache (DB-first)
                fullHistory = getPriceHistorySync(selectedTea.symbol, 'tea');
                if (!fullHistory || fullHistory.length === 0) {
                    fullHistory = generateTeaHistory(selectedTea);
                }
            } else {
                // Get index history from unified cache (DB-first)
                const indexSymbol = mainChartData?.symbol || 'KENYA';
                fullHistory = getPriceHistorySync(indexSymbol, 'index');
                if (!fullHistory || fullHistory.length === 0) {
                    fullHistory = generateIndexHistory(mainChartData);
                }
            }
            
            return sampleHistoricalData(fullHistory, timeframe, config);
        }
        
        function sampleHistoricalData(fullHistory, timeframe, config) {
            if (!fullHistory || fullHistory.length === 0) {
                return generateDefaultChartData(config, timeframe);
            }
            
            // Include extra points for indicator warm-up (BB needs 20 periods)
            const warmupPeriod = 25;
            let sampledData = [];
            if (timeframe === '1D') {
                sampledData = fullHistory.slice(-(24 + warmupPeriod)); // Extra for BB warm-up
            } else if (timeframe === '1W') {
                // Sample every 4 hours for a week, with extra warm-up
                const startIndex = Math.max(0, fullHistory.length - (168 + warmupPeriod * 4));
                for (let i = startIndex; i < fullHistory.length; i += 4) {
                    sampledData.push(fullHistory[i]);
                }
            } else if (timeframe === '1M') {
                // Sample every 24 hours for a month, with warm-up
                const startIndex = Math.max(0, fullHistory.length - (720 + warmupPeriod * 24));
                for (let i = startIndex; i < fullHistory.length; i += 24) {
                    sampledData.push(fullHistory[i]);
                }
            } else {
                sampledData = fullHistory.slice(-(config.points + warmupPeriod));
            }
            
            return sampledData.length > 0 ? sampledData : generateDefaultChartData(config, timeframe);
        }
        
        function generateDefaultChartData(config, timeframe) {
            const data = [];
            let price = 3.20;
            let volume = 800000;
            const now = new Date();
            
            // Seeded random for consistency based on timeframe
            const seed = (timeframe || 'DEFAULT').split('').reduce((a, c) => a + c.charCodeAt(0), 0) + 2000;
            const seededRandom = (i) => {
                const x = Math.sin(seed + i * 9999) * 10000;
                return x - Math.floor(x);
            };
            
            for (let i = 0; i < config.points; i++) {
                const open = price;
                const change = (seededRandom(i) - 0.48) * 0.06;
                price = Math.max(3.05, Math.min(3.55, price + change));
                const close = price;
                const high = Math.max(open, close) + seededRandom(i + 1000) * 0.03;
                const low = Math.min(open, close) - seededRandom(i + 2000) * 0.03;
                volume = Math.max(500000, volume + (seededRandom(i + 3000) - 0.5) * 200000);
                
                // Generate timestamp based on timeframe
                let date = new Date(now);
                if (timeframe === '1D') date.setHours(date.getHours() - (config.points - i));
                else if (timeframe === '1W') date.setDate(date.getDate() - (config.points - i));
                else if (timeframe === '1M') date.setDate(date.getDate() - (config.points - i));
                else if (timeframe === '3M') date.setDate(date.getDate() - (config.points - i) * 7);
                else if (timeframe === '1Y') date.setMonth(date.getMonth() - (config.points - i));
                else date.setMonth(date.getMonth() - (config.points - i));
                
                data.push({
                    date: date,
                    open: open,
                    high: high,
                    low: low,
                    close: close,
                    volume: Math.round(volume),
                    change: ((close - open) / open * 100)
                });
            }
            return data;
        }
        
        function formatDate(date, timeframe) {
            if (timeframe === '1D') {
                return date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
            } else if (timeframe === '1W' || timeframe === '1M') {
                return date.toLocaleDateString('en-GB', { weekday: 'short', day: 'numeric', month: 'short' });
            } else {
                return date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
            }
        }
        
        function formatVolume(vol) {
            if (vol >= 1000000) return (vol / 1000000).toFixed(1) + 'M';
            if (vol >= 1000) return (vol / 1000).toFixed(0) + 'K';
            return vol.toString();
        }
        
        // =============================================
        // TECHNICAL INDICATOR CALCULATIONS
        // =============================================
        
        function calculateSMA(data, period) {
            const sma = [];
            let firstValue = null;
            
            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    sma.push(null); // Will backfill later
                } else {
                    let sum = 0;
                    for (let j = 0; j < period; j++) {
                        sum += data[i - j].close;
                    }
                    const val = sum / period;
                    if (firstValue === null) firstValue = val;
                    sma.push(val);
                }
            }
            
            // Backfill nulls with first calculated value
            for (let i = 0; i < sma.length; i++) {
                if (sma[i] === null && firstValue !== null) {
                    sma[i] = firstValue;
                } else {
                    break;
                }
            }
            
            return sma;
        }
        
        function calculateEMA(data, period) {
            const ema = [];
            const multiplier = 2 / (period + 1);
            let firstValue = null;
            
            // Start with SMA for first EMA value
            let sum = 0;
            for (let i = 0; i < period && i < data.length; i++) {
                sum += data[i].close;
            }
            let prevEma = sum / Math.min(period, data.length);
            
            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    ema.push(null);
                } else if (i === period - 1) {
                    if (firstValue === null) firstValue = prevEma;
                    ema.push(prevEma);
                } else {
                    const currentEma = (data[i].close - prevEma) * multiplier + prevEma;
                    ema.push(currentEma);
                    prevEma = currentEma;
                }
            }
            
            // Backfill nulls with first calculated value
            for (let i = 0; i < ema.length; i++) {
                if (ema[i] === null && firstValue !== null) {
                    ema[i] = firstValue;
                } else {
                    break;
                }
            }
            
            return ema;
        }
        
        function calculateBollingerBands(data, period = 20, stdDev = 2) {
            const sma = calculateSMA(data, period);
            const upper = [];
            const lower = [];
            let firstUpper = null;
            let firstLower = null;
            
            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    upper.push(null);
                    lower.push(null);
                } else {
                    // Calculate standard deviation
                    let sumSquares = 0;
                    for (let j = 0; j < period; j++) {
                        sumSquares += Math.pow(data[i - j].close - sma[i], 2);
                    }
                    const std = Math.sqrt(sumSquares / period);
                    const u = sma[i] + stdDev * std;
                    const l = sma[i] - stdDev * std;
                    if (firstUpper === null) {
                        firstUpper = u;
                        firstLower = l;
                    }
                    upper.push(u);
                    lower.push(l);
                }
            }
            
            // Backfill nulls
            for (let i = 0; i < upper.length; i++) {
                if (upper[i] === null && firstUpper !== null) {
                    upper[i] = firstUpper;
                    lower[i] = firstLower;
                } else {
                    break;
                }
            }
            
            return { middle: sma, upper, lower };
        }
        
        function calculateRSI(data, period = 14) {
            const rsi = [];
            let gains = [];
            let losses = [];
            let firstValue = null;
            
            for (let i = 0; i < data.length; i++) {
                if (i === 0) {
                    rsi.push(null);
                    continue;
                }
                
                const change = data[i].close - data[i - 1].close;
                const gain = change > 0 ? change : 0;
                const loss = change < 0 ? Math.abs(change) : 0;
                
                gains.push(gain);
                losses.push(loss);
                
                if (i < period) {
                    rsi.push(null);
                } else if (i === period) {
                    const avgGain = gains.reduce((a, b) => a + b, 0) / period;
                    const avgLoss = losses.reduce((a, b) => a + b, 0) / period;
                    const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                    const val = 100 - (100 / (1 + rs));
                    if (firstValue === null) firstValue = val;
                    rsi.push(val);
                } else {
                    // Smoothed averages
                    const prevRsi = rsi[rsi.length - 1];
                    const prevAvgGain = gains.slice(-period - 1, -1).reduce((a, b) => a + b, 0) / period;
                    const prevAvgLoss = losses.slice(-period - 1, -1).reduce((a, b) => a + b, 0) / period;
                    const avgGain = (prevAvgGain * (period - 1) + gain) / period;
                    const avgLoss = (prevAvgLoss * (period - 1) + loss) / period;
                    const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                    rsi.push(100 - (100 / (1 + rs)));
                }
            }
            
            // Backfill nulls with first calculated value
            for (let i = 0; i < rsi.length; i++) {
                if (rsi[i] === null && firstValue !== null) {
                    rsi[i] = firstValue;
                } else if (rsi[i] !== null) {
                    break;
                }
            }
            
            return rsi;
        }
        
        function toggleStudiesMenu() {
            const menu = document.getElementById('studies-menu');
            menu.classList.toggle('visible');
        }
        
        function toggleStudy(study) {
            activeStudies[study] = !activeStudies[study];
            const toggle = document.getElementById('toggle-' + study);
            toggle.classList.toggle('active', activeStudies[study]);
            
            // Update button appearance
            const hasActive = Object.values(activeStudies).some(v => v);
            document.getElementById('studies-btn').classList.toggle('has-active', hasActive);
            
            // Show/hide RSI panel
            if (study === 'rsi') {
                const rsiContainer = document.getElementById('rsi-chart-container');
                rsiContainer.style.display = activeStudies.rsi ? 'block' : 'none';
            }
            
            drawChart();
            
            // Draw RSI if active
            if (activeStudies.rsi) {
                drawRSIChart();
            }
        }
        
        // Close studies menu when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.querySelector('.studies-dropdown');
            if (dropdown && !dropdown.contains(e.target)) {
                document.getElementById('studies-menu').classList.remove('visible');
            }
        });
        
        // =============================================
        // PRICE ALERT SYSTEM
        // =============================================
        
        let currentAlertSymbol = null;
        
        function openPriceAlertModal(symbol, currentPrice) {
            currentAlertSymbol = symbol;
            const modal = document.getElementById('price-alert-modal');
            const existing = priceAlerts[symbol];
            
            document.getElementById('alert-symbol').textContent = symbol;
            document.getElementById('alert-current-price').textContent = `Current: $${currentPrice.toFixed(2)}`;
            document.getElementById('alert-below').value = existing?.below || '';
            document.getElementById('alert-above').value = existing?.above || '';
            document.getElementById('alert-delete-btn').style.display = existing ? 'block' : 'none';
            
            modal.classList.add('active');
        }
        
        function closePriceAlertModal() {
            document.getElementById('price-alert-modal').classList.remove('active');
            currentAlertSymbol = null;
        }
        
        function savePriceAlert() {
            if (!currentAlertSymbol) return;
            
            const below = document.getElementById('alert-below').value ? parseFloat(document.getElementById('alert-below').value) : null;
            const above = document.getElementById('alert-above').value ? parseFloat(document.getElementById('alert-above').value) : null;
            
            if (!below && !above) {
                delete priceAlerts[currentAlertSymbol];
                showToast('Alert Removed', `Price alert for ${currentAlertSymbol} cleared`);
            } else {
                priceAlerts[currentAlertSymbol] = { below, above };
                const alertText = [];
                if (below) alertText.push(`Below $${below.toFixed(2)}`);
                if (above) alertText.push(`Above $${above.toFixed(2)}`);
                showToast('Alert Set!', `${currentAlertSymbol}: ${alertText.join(' | ')}`);
                
                // Request notification permission
                requestNotificationPermission();
            }
            
            closePriceAlertModal();
            updateAuctionTable();
        }
        
        function deletePriceAlert() {
            if (!currentAlertSymbol) return;
            delete priceAlerts[currentAlertSymbol];
            showToast('Alert Deleted', `Price alert for ${currentAlertSymbol} removed`);
            closePriceAlertModal();
            updateAuctionTable();
        }
        
        async function checkPriceAlerts() {
            for (const symbol of Object.keys(priceAlerts)) {
                const alert = priceAlerts[symbol];
                
                // Find the tea (might be actual symbol or display symbol)
                const displayData = teaDisplayData[symbol];
                const priceSymbol = displayData?.priceFrom || symbol;
                const tea = teas.find(t => t.symbol === priceSymbol);
                
                if (!tea) continue;
                
                const currentPrice = tea.current_price;
                let triggered = false;
                let triggerText = '';
                
                if (alert.below && currentPrice <= alert.below) {
                    triggered = true;
                    triggerText = `${symbol} dropped below $${alert.below.toFixed(2)}`;
                } else if (alert.above && currentPrice >= alert.above) {
                    triggered = true;
                    triggerText = `${symbol} rose above $${alert.above.toFixed(2)}`;
                }
                
                if (triggered) {
                    // Remove the alert (one-time trigger)
                    delete priceAlerts[symbol];
                    
                    // Show toast notification
                    showToast('ðŸ”” Price Alert!', `${triggerText} - Now at $${currentPrice.toFixed(2)}`);
                    
                    // Try browser notification
                    if ('Notification' in window && Notification.permission === 'granted') {
                        new Notification('TeaTrade Price Alert', {
                            body: triggerText,
                            icon: '/favicon.ico'
                        });
                    }
                    
                    updateAuctionTable();
                }
            }
        }
        
        // Request notification permission on first alert
        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }
        
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            drawChart();
        }
        
        function drawChart() {
            const w = canvas.offsetWidth;
            const h = canvas.offsetHeight;
            const config = timeframeConfig[currentTimeframe];
            
            if (!config || !w || !h) return;
            
            ctx.clearRect(0, 0, w, h);
            
            // Generate data only when timeframe changes
            if (cachedTimeframe !== currentTimeframe || chartData.length === 0) {
                chartData = generateChartData(currentTimeframe);
                cachedTimeframe = currentTimeframe;
            }
            
            // Guard against empty data
            if (!chartData || chartData.length === 0) {
                chartData = generateDefaultChartData(config, currentTimeframe);
            }
            
            // Final check - if still no data, return
            if (!chartData || chartData.length === 0) return;
            
            const prices = chartData.map(d => d.close);
            if (prices.length === 0) return;
            
            // Y-AXIS STABILIZATION: Calculate stable range to prevent flickering
            const dataMinPrice = Math.min(...chartData.map(d => d.low));
            const dataMaxPrice = Math.max(...chartData.map(d => d.high));
            const dataRange = dataMaxPrice - dataMinPrice;
            const midPrice = (dataMaxPrice + dataMinPrice) / 2;
            
            // Minimum range is 8% of mid price
            const minRange = midPrice * 0.08;
            const stableRange = Math.max(dataRange, minRange);
            
            // Use cached Y-axis bounds if data is within range
            const chartSymbol = document.getElementById('trade-tea-select')?.value || 'MAIN';
            const cacheKey = `main_${chartSymbol}_${currentTimeframe}`;
            if (!window.mainYAxisCache) window.mainYAxisCache = {};
            
            let minPrice, maxPrice;
            if (window.mainYAxisCache[cacheKey]) {
                const cached = window.mainYAxisCache[cacheKey];
                const cachedRange = cached.max - cached.min;
                // Only update if prices exceed 80% of cached range
                if (dataMinPrice >= cached.min + cachedRange * 0.1 && 
                    dataMaxPrice <= cached.max - cachedRange * 0.1) {
                    minPrice = cached.min;
                    maxPrice = cached.max;
                } else {
                    // Update cache with new stable range
                    minPrice = midPrice - (stableRange * 0.65);
                    maxPrice = midPrice + (stableRange * 0.65);
                    window.mainYAxisCache[cacheKey] = { min: minPrice, max: maxPrice };
                }
            } else {
                // First render - cache the bounds
                minPrice = midPrice - (stableRange * 0.65);
                maxPrice = midPrice + (stableRange * 0.65);
                window.mainYAxisCache[cacheKey] = { min: minPrice, max: maxPrice };
            }
            
            const priceRange = maxPrice - minPrice;
            const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
            const highPrice = Math.max(...prices);
            const lowPrice = Math.min(...prices);
            const currentPrice = prices[prices.length - 1];
            const openPrice = chartData[0].open;
            const totalChange = ((currentPrice - openPrice) / openPrice * 100);
            
            chartMetrics = { minPrice, maxPrice, priceRange, avgPrice, highPrice, lowPrice, currentPrice, openPrice, totalChange };
            
            const chartWidth = w - leftMargin - rightMargin;
            const chartHeight = h - bottomMargin - (h * 0.1);
            
            // Draw grid lines and Y-axis labels
            ctx.strokeStyle = '#1a2332';
            ctx.lineWidth = 1;
            ctx.font = '10px JetBrains Mono, monospace';
            ctx.fillStyle = '#6b7280';
            ctx.textAlign = 'right';
            
            for (let i = 0; i <= 5; i++) {
                const y = h * 0.1 + chartHeight * (i / 5);
                const priceLabel = (maxPrice - (priceRange * (i / 5))).toFixed(2);
                
                ctx.beginPath();
                ctx.moveTo(leftMargin, y);
                ctx.lineTo(w - rightMargin, y);
                ctx.stroke();
                
                ctx.fillText('$' + priceLabel, leftMargin - 8, y + 3);
            }
            
            // Draw X-axis labels
            ctx.textAlign = 'center';
            ctx.fillStyle = '#6b7280';
            const labels = config.labels;
            labels.forEach((label, i) => {
                const x = leftMargin + (i / (labels.length - 1)) * chartWidth;
                ctx.fillText(label, x, h - 8);
            });
            
            // Draw average line (dashed)
            const avgY = h * 0.1 + (1 - (avgPrice - minPrice) / priceRange) * chartHeight;
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(leftMargin, avgY);
            ctx.lineTo(w - rightMargin, avgY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            const lastX = leftMargin + chartWidth;
            const lastY = h * 0.1 + (1 - (currentPrice - minPrice) / priceRange) * chartHeight;
            
            if (chartType === 'candle') {
                // Draw candlesticks
                const candleWidth = Math.max(4, Math.min(20, (chartWidth / chartData.length) * 0.7));
                const candleGap = (chartWidth / chartData.length);
                
                chartData.forEach((d, i) => {
                    const x = leftMargin + (i / (chartData.length - 1)) * chartWidth;
                    const openY = h * 0.1 + (1 - (d.open - minPrice) / priceRange) * chartHeight;
                    const closeY = h * 0.1 + (1 - (d.close - minPrice) / priceRange) * chartHeight;
                    const highY = h * 0.1 + (1 - (d.high - minPrice) / priceRange) * chartHeight;
                    const lowY = h * 0.1 + (1 - (d.low - minPrice) / priceRange) * chartHeight;
                    
                    const isUp = d.close >= d.open;
                    const color = isUp ? '#10b981' : '#ef4444';
                    
                    // Draw wick (high-low line)
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, highY);
                    ctx.lineTo(x, lowY);
                    ctx.stroke();
                    
                    // Draw candle body
                    const bodyTop = Math.min(openY, closeY);
                    const bodyHeight = Math.max(1, Math.abs(closeY - openY));
                    
                    if (isUp) {
                        ctx.fillStyle = color;
                        ctx.fillRect(x - candleWidth/2, bodyTop, candleWidth, bodyHeight);
                    } else {
                        ctx.fillStyle = color;
                        ctx.fillRect(x - candleWidth/2, bodyTop, candleWidth, bodyHeight);
                    }
                    
                    // Body border for definition
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x - candleWidth/2, bodyTop, candleWidth, bodyHeight);
                });
            } else {
                // Draw line chart
                ctx.beginPath();
                ctx.strokeStyle = '#1a73e8';
                ctx.lineWidth = 2;
                
                prices.forEach((p, i) => {
                    const x = leftMargin + (i / (prices.length - 1)) * chartWidth;
                    const y = h * 0.1 + (1 - (p - minPrice) / priceRange) * chartHeight;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                
                // Draw area fill
                ctx.lineTo(lastX, h * 0.1 + chartHeight);
                ctx.lineTo(leftMargin, h * 0.1 + chartHeight);
                ctx.closePath();
                ctx.fillStyle = 'rgba(26, 115, 232, 0.15)';
                ctx.fill();
            }
            
            // =============================================
            // DRAW TECHNICAL INDICATORS
            // =============================================
            
            function drawIndicatorLine(values, color, lineWidth = 2) {
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                let started = false;
                
                values.forEach((val, i) => {
                    if (val === null) return;
                    const x = leftMargin + (i / (values.length - 1)) * chartWidth;
                    const y = h * 0.1 + (1 - (val - minPrice) / priceRange) * chartHeight;
                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
            }
            
            // SMA 10
            if (activeStudies.sma10) {
                const sma10 = calculateSMA(chartData, 10);
                drawIndicatorLine(sma10, studyColors.sma10, 1.5);
            }
            
            // SMA 20
            if (activeStudies.sma20) {
                const sma20 = calculateSMA(chartData, 20);
                drawIndicatorLine(sma20, studyColors.sma20, 1.5);
            }
            
            // SMA 50
            if (activeStudies.sma50) {
                const sma50 = calculateSMA(chartData, 50);
                drawIndicatorLine(sma50, studyColors.sma50, 1.5);
            }
            
            // EMA 10
            if (activeStudies.ema10) {
                const ema10 = calculateEMA(chartData, 10);
                drawIndicatorLine(ema10, studyColors.ema10, 1.5);
            }
            
            // EMA 20
            if (activeStudies.ema20) {
                const ema20 = calculateEMA(chartData, 20);
                drawIndicatorLine(ema20, studyColors.ema20, 1.5);
            }
            
            // Bollinger Bands
            if (activeStudies.bollinger) {
                const bb = calculateBollingerBands(chartData, 20, 2);
                
                // Draw upper band
                drawIndicatorLine(bb.upper, studyColors.bollinger, 1);
                
                // Draw lower band
                drawIndicatorLine(bb.lower, studyColors.bollinger, 1);
                
                // Draw middle band (SMA)
                ctx.setLineDash([4, 4]);
                drawIndicatorLine(bb.middle, studyColors.bollinger, 1);
                ctx.setLineDash([]);
                
                // Fill between bands
                ctx.beginPath();
                let started = false;
                bb.upper.forEach((val, i) => {
                    if (val === null) return;
                    const x = leftMargin + (i / (bb.upper.length - 1)) * chartWidth;
                    const y = h * 0.1 + (1 - (val - minPrice) / priceRange) * chartHeight;
                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                for (let i = bb.lower.length - 1; i >= 0; i--) {
                    if (bb.lower[i] === null) continue;
                    const x = leftMargin + (i / (bb.lower.length - 1)) * chartWidth;
                    const y = h * 0.1 + (1 - (bb.lower[i] - minPrice) / priceRange) * chartHeight;
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fillStyle = 'rgba(96, 165, 250, 0.1)';
                ctx.fill();
            }
            
            // High/Low markers (line chart only)
            if (chartType === 'line') {
                const highIndex = prices.indexOf(highPrice);
                const highX = leftMargin + (highIndex / (prices.length - 1)) * chartWidth;
                const highY = h * 0.1 + (1 - (highPrice - minPrice) / priceRange) * chartHeight;
                ctx.fillStyle = '#10b981';
                ctx.beginPath();
                ctx.arc(highX, highY, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = '9px JetBrains Mono, monospace';
                ctx.fillStyle = '#10b981';
                ctx.textAlign = 'center';
                ctx.fillText('H $' + highPrice.toFixed(2), highX, highY - 10);
                
                const lowIndex = prices.indexOf(lowPrice);
                const lowX = leftMargin + (lowIndex / (prices.length - 1)) * chartWidth;
                const lowY = h * 0.1 + (1 - (lowPrice - minPrice) / priceRange) * chartHeight;
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.arc(lowX, lowY, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ef4444';
                ctx.fillText('L $' + lowPrice.toFixed(2), lowX, lowY + 16);
                
                // Current price marker
                ctx.fillStyle = '#1a73e8';
                ctx.beginPath();
                ctx.arc(lastX, lastY, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
            
            // Average label
            ctx.font = '9px JetBrains Mono, monospace';
            ctx.fillStyle = '#f59e0b';
            ctx.textAlign = 'left';
            ctx.fillText('AVG $' + avgPrice.toFixed(2), leftMargin + 5, avgY - 5);
            
            // =============================================
            // LIVE PRICE CALLOUT (Trading212 style)
            // =============================================
            drawPriceCallout(ctx, w, h, currentPrice, lastY, priceRange > 0);
            
            // =============================================
            // DRAW ORDER POSITION LINES (Trading212 style)
            // =============================================
            drawOrderAnnotations(ctx, w, h, chartWidth, chartHeight, minPrice, maxPrice, priceRange, currentPrice);
            
            // Draw RSI if active
            if (activeStudies.rsi) {
                drawRSIChart();
            }
        }
        
        // =============================================
        // LIVE PRICE CALLOUT BOX
        // =============================================
        let lastLivePrice = null;
        let livePriceDirection = 0; // 1 = up, -1 = down, 0 = neutral
        
        function drawPriceCallout(ctx, w, h, price, priceY, isValid) {
            if (!isValid || !price) return;
            
            // Determine direction from last price
            if (lastLivePrice !== null && lastLivePrice !== price) {
                livePriceDirection = price > lastLivePrice ? 1 : -1;
            }
            lastLivePrice = price;
            
            const boxWidth = 70;
            const boxHeight = 22;
            const boxX = w - boxWidth - 5;
            const boxY = Math.max(20, Math.min(h - boxHeight - 30, priceY - boxHeight / 2));
            
            // Determine color based on direction
            const bgColor = livePriceDirection > 0 ? '#10b981' : livePriceDirection < 0 ? '#ef4444' : '#1a73e8';
            
            // Draw connecting line from price point to callout
            ctx.strokeStyle = bgColor;
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.moveTo(w - 60, priceY);
            ctx.lineTo(boxX, boxY + boxHeight / 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw callout box with rounded corners
            ctx.fillStyle = bgColor;
            ctx.beginPath();
            ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 4);
            ctx.fill();
            
            // Draw price text
            ctx.font = 'bold 11px JetBrains Mono, monospace';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.fillText('$' + price.toFixed(2), boxX + boxWidth / 2, boxY + boxHeight / 2 + 4);
            
            // Draw small arrow indicator
            const arrowX = boxX + 8;
            const arrowY = boxY + boxHeight / 2;
            ctx.fillStyle = '#ffffff';
            if (livePriceDirection > 0) {
                // Up arrow
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY + 3);
                ctx.lineTo(arrowX - 4, arrowY + 3);
                ctx.lineTo(arrowX - 2, arrowY - 4);
                ctx.closePath();
                ctx.fill();
            } else if (livePriceDirection < 0) {
                // Down arrow
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY - 3);
                ctx.lineTo(arrowX - 4, arrowY - 3);
                ctx.lineTo(arrowX - 2, arrowY + 4);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        // =============================================
        // LIVE PRICE SIMULATION
        // =============================================
        let livePriceUpdateInterval = null;
        
        function startLivePriceSimulation() {
            if (livePriceUpdateInterval) return;
            
            livePriceUpdateInterval = setInterval(() => {
                simulateLivePriceMovements();
            }, 2500); // Update every 2.5 seconds
        }
        
        function simulateLivePriceMovements() {
            if (!teas || teas.length === 0) return;
            
            let chartNeedsRedraw = false;
            
            // Update each tea with small random price movements
            teas.forEach(tea => {
                const volatility = 0.002; // 0.2% max change per tick
                const change = (Math.random() - 0.5) * 2 * volatility * tea.current_price;
                const oldPrice = tea.current_price;
                
                // Apply change with bounds
                tea.current_price = Math.max(0.01, tea.current_price + change);
                
                // Update unified price cache for this tea
                updatePriceCache(tea.symbol, tea.current_price, 'tea');
                
                // Update 24h change slightly
                if (Math.random() > 0.7) {
                    tea.price_change_24h = (tea.price_change_24h || 0) + (Math.random() - 0.5) * 0.1;
                }
                
                // Track if the selected tea changed for chart redraw
                const select = document.getElementById('trade-tea-select');
                if (select && select.value === tea.symbol) {
                    chartNeedsRedraw = true;
                }
            });
            
            // Update the main chart index price
            const indexChange = (Math.random() - 0.5) * 0.01;
            mainChartData.basePrice = Math.max(0.01, mainChartData.basePrice + indexChange);
            mainChartData.change = mainChartData.change + (Math.random() - 0.5) * 0.02;
            
            // Update unified cache for main index
            updatePriceCache(mainChartData.symbol || 'KENYA', mainChartData.basePrice, 'index');
            
            // Invalidate chart cache to show new price
            if (chartData && chartData.length > 0) {
                const lastCandle = chartData[chartData.length - 1];
                const priceMove = (Math.random() - 0.5) * 0.02;
                lastCandle.close = Math.max(0.01, lastCandle.close + priceMove);
                lastCandle.high = Math.max(lastCandle.high, lastCandle.close);
                lastCandle.low = Math.min(lastCandle.low, lastCandle.close);
            }
            
            // Update hub chart incrementally from unified cache
            const hubSymbol = document.getElementById('hub-buy-symbol')?.value || 'KENYA';
            const isHubIndex = ['KENYA', 'KENYAN', 'INDIA', 'CEYLON', 'CHINA', 'JAPAN', 'AFRICA', 'ASIA'].includes(hubSymbol);
            const hubLookupSymbol = hubSymbol === 'KENYAN' ? 'KENYA' : hubSymbol;
            const hubCacheKey = isHubIndex ? `INDEX_${hubLookupSymbol}` : hubLookupSymbol;
            
            // Get hub chart data from unified cache
            if (priceDataCache.data[hubCacheKey] && priceDataCache.data[hubCacheKey].length > 0) {
                hubChartData = priceDataCache.data[hubCacheKey];
            }
            
            // Redraw charts
            drawChart();
            
            // Update quote board
            updateQuoteBoard();
            
            // Update main chart header stats
            updateMainChartStats();
            
            // Update quick quote modal if open
            if (quickQuoteTea) {
                updateQuickQuoteLivePrice();
            }
            
            // Update multi-chart panels
            updateMultiChartPrices();
        }
        
        function updateMainChartStats() {
            const priceEl = document.getElementById('main-chart-price');
            const changeEl = document.getElementById('main-chart-change');
            
            if (priceEl && mainChartData) {
                const price = mainChartData.basePrice;
                const change = mainChartData.change;
                const isUp = change >= 0;
                
                priceEl.textContent = '$' + price.toFixed(2);
                priceEl.className = 'chart-stat-value ' + (isUp ? 'up' : 'down');
                
                if (changeEl) {
                    const changeAmt = (price * change / 100).toFixed(2);
                    changeEl.textContent = `${isUp ? '+' : ''}$${changeAmt} (${isUp ? '+' : ''}${change.toFixed(1)}%)`;
                    changeEl.style.color = isUp ? 'var(--accent-green)' : 'var(--accent-red)';
                }
            }
        }
        
        function updateQuickQuoteLivePrice() {
            if (!quickQuoteTea) return;
            
            // Find updated tea data
            const tea = teas.find(t => t.id === quickQuoteTea.id);
            if (tea) {
                quickQuoteTea = tea; // Update reference
                
                // Update modal header
                const priceEl = document.getElementById('qq-current-price');
                const changeEl = document.getElementById('qq-change');
                
                if (priceEl) {
                    const oldPrice = parseFloat(priceEl.textContent.replace('$', ''));
                    const newPrice = tea.current_price;
                    
                    priceEl.textContent = '$' + newPrice.toFixed(2);
                    
                    // Flash effect
                    if (oldPrice !== newPrice) {
                        priceEl.style.transition = 'color 0.1s';
                        priceEl.style.color = newPrice > oldPrice ? '#10b981' : '#ef4444';
                        setTimeout(() => {
                            const isUp = (tea.price_change_24h || 0) >= 0;
                            priceEl.style.color = isUp ? 'var(--accent-green)' : 'var(--accent-red)';
                        }, 500);
                    }
                }
                
                if (changeEl) {
                    const change = tea.price_change_24h || 0;
                    const isUp = change >= 0;
                    changeEl.textContent = `${isUp ? '+' : ''}${change.toFixed(1)}%`;
                    changeEl.className = 'quick-quote-change ' + (isUp ? 'up' : 'down');
                }
                
                // Redraw modal chart
                drawQuickQuoteChart(tea);
                
                // Update trade summary
                updateQuickTradeSummary();
                
                // Update mobile trade bar price
                const mobilePriceEl = document.getElementById('qq-mobile-trade-price');
                if (mobilePriceEl) mobilePriceEl.textContent = `$${tea.current_price.toFixed(2)}`;
            }
        }
        
        function updateMultiChartPrices() {
            multiChartPanels.forEach((panel, index) => {
                if (!panel || !panel.tea) return;
                
                // Find updated tea
                const tea = teas.find(t => t.id === panel.tea.id);
                if (tea) {
                    panel.tea = tea;
                    
                    // Redraw panel
                    drawMultiChartPanel(index, tea);
                }
            });
        }
        
        // Start live price simulation when page loads
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(startLivePriceSimulation, 3000); // Start after 3 seconds
        });
        
        // Draw order position annotations on chart
        function drawOrderAnnotations(ctx, w, h, chartWidth, chartHeight, minPrice, maxPrice, priceRange, currentPrice) {
            if (!positions || positions.length === 0) return;
            
            // Get the currently selected tea from trade form
            const select = document.getElementById('trade-tea-select');
            const selectedTeaId = select?.value ? parseInt(select.value) : null;
            
            positions.forEach(position => {
                // Only show positions for the currently selected tea (or all if none selected)
                if (selectedTeaId && position.tea_id !== selectedTeaId) return;
                
                const entryPrice = position.avg_entry_price;
                if (!entryPrice || entryPrice < minPrice || entryPrice > maxPrice) return;
                
                // Get current price for this tea
                const tea = teas.find(t => t.id === position.tea_id);
                if (!tea) return;
                
                const teaCurrentPrice = tea.current_price;
                
                // Calculate P/L
                const pnl = (teaCurrentPrice - entryPrice) * position.quantity;
                const pnlPercent = ((teaCurrentPrice - entryPrice) / entryPrice * 100);
                const isProfit = pnl >= 0;
                
                // Calculate Y position
                const entryY = h * 0.1 + (1 - (entryPrice - minPrice) / priceRange) * chartHeight;
                
                // Draw dotted line
                ctx.strokeStyle = isProfit ? '#10b981' : '#ef4444';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(leftMargin, entryY);
                ctx.lineTo(w - rightMargin, entryY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw entry marker (small triangle on left)
                ctx.fillStyle = isProfit ? '#10b981' : '#ef4444';
                ctx.beginPath();
                ctx.moveTo(leftMargin - 6, entryY);
                ctx.lineTo(leftMargin, entryY - 4);
                ctx.lineTo(leftMargin, entryY + 4);
                ctx.closePath();
                ctx.fill();
                
                // Draw P/L label on right side
                const pnlText = `${isProfit ? '+' : ''}$${pnl.toFixed(2)} (${isProfit ? '+' : ''}${pnlPercent.toFixed(1)}%)`;
                ctx.font = 'bold 10px JetBrains Mono, monospace';
                ctx.fillStyle = isProfit ? '#10b981' : '#ef4444';
                ctx.textAlign = 'right';
                
                // Background for P/L label
                const textWidth = ctx.measureText(pnlText).width;
                ctx.fillStyle = 'rgba(13, 17, 23, 0.85)';
                ctx.fillRect(w - rightMargin - textWidth - 12, entryY - 16, textWidth + 8, 14);
                
                // P/L text
                ctx.fillStyle = isProfit ? '#10b981' : '#ef4444';
                ctx.fillText(pnlText, w - rightMargin - 8, entryY - 6);
                
                // Entry price label on left
                ctx.font = '9px JetBrains Mono, monospace';
                ctx.textAlign = 'left';
                ctx.fillStyle = isProfit ? '#10b981' : '#ef4444';
                ctx.fillText('ENTRY $' + entryPrice.toFixed(2), leftMargin + 5, entryY - 6);
            });
        }
        
        // =============================================
        // RSI SUB-CHART
        // =============================================
        
        function drawRSIChart() {
            const rsiCanvas = document.getElementById('rsiChart');
            if (!rsiCanvas) return;
            
            const rsiCtx = rsiCanvas.getContext('2d');
            
            // Set canvas size
            rsiCanvas.width = rsiCanvas.offsetWidth * window.devicePixelRatio;
            rsiCanvas.height = rsiCanvas.offsetHeight * window.devicePixelRatio;
            rsiCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const w = rsiCanvas.offsetWidth;
            const h = rsiCanvas.offsetHeight;
            const chartWidth = w - leftMargin - rightMargin;
            const topPadding = 20;
            const bottomPadding = 5;
            const chartHeight = h - topPadding - bottomPadding;
            
            // Clear
            rsiCtx.clearRect(0, 0, w, h);
            
            // Calculate RSI
            const rsiData = calculateRSI(chartData, 14);
            
            // Update RSI value display
            const currentRSI = rsiData[rsiData.length - 1];
            const rsiValueEl = document.getElementById('rsi-value');
            if (currentRSI !== null) {
                let rsiColor = '#fff';
                if (currentRSI >= 70) rsiColor = '#ef4444';
                else if (currentRSI <= 30) rsiColor = '#10b981';
                rsiValueEl.textContent = currentRSI.toFixed(1);
                rsiValueEl.style.color = rsiColor;
            }
            
            // Draw background bands
            // Overbought zone (70-100)
            rsiCtx.fillStyle = 'rgba(239, 68, 68, 0.1)';
            rsiCtx.fillRect(leftMargin, topPadding, chartWidth, chartHeight * 0.3);
            
            // Oversold zone (0-30)
            rsiCtx.fillStyle = 'rgba(16, 185, 129, 0.1)';
            rsiCtx.fillRect(leftMargin, topPadding + chartHeight * 0.7, chartWidth, chartHeight * 0.3);
            
            // Draw horizontal reference lines
            rsiCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            rsiCtx.lineWidth = 1;
            
            // 70 line (overbought)
            const y70 = topPadding + chartHeight * 0.3;
            rsiCtx.beginPath();
            rsiCtx.setLineDash([4, 4]);
            rsiCtx.moveTo(leftMargin, y70);
            rsiCtx.lineTo(w - rightMargin, y70);
            rsiCtx.stroke();
            
            // 50 line (middle)
            const y50 = topPadding + chartHeight * 0.5;
            rsiCtx.beginPath();
            rsiCtx.moveTo(leftMargin, y50);
            rsiCtx.lineTo(w - rightMargin, y50);
            rsiCtx.stroke();
            
            // 30 line (oversold)
            const y30 = topPadding + chartHeight * 0.7;
            rsiCtx.beginPath();
            rsiCtx.moveTo(leftMargin, y30);
            rsiCtx.lineTo(w - rightMargin, y30);
            rsiCtx.stroke();
            
            rsiCtx.setLineDash([]);
            
            // Draw Y-axis labels
            rsiCtx.font = '9px JetBrains Mono, monospace';
            rsiCtx.fillStyle = '#6b7280';
            rsiCtx.textAlign = 'right';
            rsiCtx.fillText('70', leftMargin - 5, y70 + 3);
            rsiCtx.fillText('50', leftMargin - 5, y50 + 3);
            rsiCtx.fillText('30', leftMargin - 5, y30 + 3);
            
            // Draw RSI line
            rsiCtx.beginPath();
            rsiCtx.strokeStyle = studyColors.rsi;
            rsiCtx.lineWidth = 1.5;
            
            let started = false;
            rsiData.forEach((val, i) => {
                if (val === null) return;
                
                const x = leftMargin + (i / (rsiData.length - 1)) * chartWidth;
                const y = topPadding + (1 - val / 100) * chartHeight;
                
                if (!started) {
                    rsiCtx.moveTo(x, y);
                    started = true;
                } else {
                    rsiCtx.lineTo(x, y);
                }
            });
            rsiCtx.stroke();
            
            // Draw fill under line
            if (started) {
                rsiCtx.lineTo(w - rightMargin, topPadding + chartHeight);
                rsiCtx.lineTo(leftMargin, topPadding + chartHeight);
                rsiCtx.closePath();
                rsiCtx.fillStyle = 'rgba(236, 72, 153, 0.1)';
                rsiCtx.fill();
            }
        }
        
        // RSI Chart hover functionality
        let rsiData = []; // Store RSI data for hover
        
        function setupRSIHover() {
            const rsiCanvas = document.getElementById('rsiChart');
            const rsiContainer = document.getElementById('rsi-chart-container');
            const rsiTooltip = document.getElementById('rsi-tooltip');
            const rsiCrosshair = document.getElementById('rsi-crosshair');
            
            if (!rsiCanvas || !rsiContainer) return;
            
            rsiCanvas.addEventListener('mousemove', function(e) {
                if (!activeStudies.rsi) return;
                
                const rect = rsiCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const w = rsiCanvas.offsetWidth;
                const h = rsiCanvas.offsetHeight;
                const chartWidth = w - leftMargin - rightMargin;
                const topPadding = 20;
                const bottomPadding = 5;
                const chartHeight = h - topPadding - bottomPadding;
                
                // Check if mouse is in chart area
                if (x < leftMargin || x > w - rightMargin || y < topPadding || y > topPadding + chartHeight) {
                    rsiTooltip.classList.remove('visible');
                    rsiCrosshair.style.display = 'none';
                    return;
                }
                
                // Calculate RSI data if needed
                const currentRsiData = calculateRSI(chartData, 14);
                
                // Find data point
                const relX = x - leftMargin;
                const index = Math.round((relX / chartWidth) * (chartData.length - 1));
                const dataPoint = chartData[Math.max(0, Math.min(index, chartData.length - 1))];
                const rsiValue = currentRsiData[Math.max(0, Math.min(index, currentRsiData.length - 1))];
                
                if (!dataPoint || rsiValue === null) {
                    rsiTooltip.classList.remove('visible');
                    rsiCrosshair.style.display = 'none';
                    return;
                }
                
                // Show crosshair
                rsiCrosshair.style.display = 'block';
                rsiCrosshair.querySelector('.crosshair-v').style.left = x + 'px';
                rsiCrosshair.querySelector('.crosshair-h').style.top = y + 'px';
                
                // Determine RSI condition
                let rsiCondition = '';
                let rsiColor = '#fff';
                if (rsiValue >= 70) {
                    rsiCondition = 'Overbought';
                    rsiColor = '#ef4444';
                } else if (rsiValue <= 30) {
                    rsiCondition = 'Oversold';
                    rsiColor = '#10b981';
                } else {
                    rsiCondition = 'Neutral';
                    rsiColor = '#9ca3af';
                }
                
                // Build tooltip
                rsiTooltip.innerHTML = `
                    <div style="color: ${rsiColor}; font-weight: 600;">RSI: ${rsiValue.toFixed(1)}</div>
                    <div style="color: ${rsiColor}; font-size: 9px;">${rsiCondition}</div>
                `;
                
                // Position tooltip
                let tooltipX = x + 15;
                let tooltipY = y - 30;
                
                if (tooltipX + 100 > w) tooltipX = x - 100;
                if (tooltipY < 0) tooltipY = y + 20;
                
                rsiTooltip.style.left = tooltipX + 'px';
                rsiTooltip.style.top = tooltipY + 'px';
                rsiTooltip.classList.add('visible');
            });
            
            rsiCanvas.addEventListener('mouseleave', function() {
                rsiTooltip.classList.remove('visible');
                rsiCrosshair.style.display = 'none';
            });
        }
        
        // Initialize RSI hover after DOM is ready
        document.addEventListener('DOMContentLoaded', setupRSIHover);
        
        // Hover functionality
        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const w = canvas.offsetWidth;
            const h = canvas.offsetHeight;
            const chartWidth = w - leftMargin - rightMargin;
            const chartHeight = h - bottomMargin - (h * 0.1);
            
            // Check if mouse is in chart area
            if (x < leftMargin || x > w - rightMargin || y < h * 0.1 || y > h * 0.1 + chartHeight) {
                tooltip.classList.remove('visible');
                crosshair.style.display = 'none';
                return;
            }
            
            // Find data point
            const relX = x - leftMargin;
            const index = Math.round((relX / chartWidth) * (chartData.length - 1));
            const dataPoint = chartData[Math.max(0, Math.min(index, chartData.length - 1))];
            
            if (!dataPoint) return;
            
            // Show crosshair
            crosshair.style.display = 'block';
            crosshair.querySelector('.crosshair-v').style.left = x + 'px';
            crosshair.querySelector('.crosshair-h').style.top = y + 'px';
            
            // Build tooltip content (Bloomberg style)
            const changeClass = dataPoint.change >= 0 ? 'up' : 'down';
            const changeSign = dataPoint.change >= 0 ? '+' : '';
            
            tooltip.innerHTML = `
                <div class="tooltip-date">${formatDate(dataPoint.date, currentTimeframe)}</div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Open</span>
                    <span class="tooltip-value">$${dataPoint.open.toFixed(3)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">High</span>
                    <span class="tooltip-value up">$${dataPoint.high.toFixed(3)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Low</span>
                    <span class="tooltip-value down">$${dataPoint.low.toFixed(3)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Close</span>
                    <span class="tooltip-value">$${dataPoint.close.toFixed(3)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Change</span>
                    <span class="tooltip-value ${changeClass}">${changeSign}${dataPoint.change.toFixed(2)}%</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Volume</span>
                    <span class="tooltip-value">${formatVolume(dataPoint.volume)} kg</span>
                </div>
            `;
            
            // Position tooltip
            let tooltipX = x + 15;
            let tooltipY = y - 10;
            
            // Keep tooltip in bounds
            if (tooltipX + 180 > w) tooltipX = x - 175;
            if (tooltipY + 160 > h) tooltipY = y - 150;
            if (tooltipY < 0) tooltipY = 10;
            
            tooltip.style.left = tooltipX + 'px';
            tooltip.style.top = tooltipY + 'px';
            tooltip.classList.add('visible');
        });
        
        canvas.addEventListener('mouseleave', function() {
            tooltip.classList.remove('visible');
            crosshair.style.display = 'none';
        });
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Early Access form submission - sends to Kit
        function submitEarlyAccess(e) {
            e.preventDefault();
            const email = document.getElementById('early-access-email').value;
            const form = document.getElementById('early-access-form');
            const btn = document.getElementById('early-access-btn');
            
            // Secret passphrase to view site
            if (email.toLowerCase().trim() === 'betty the best auctioneer') {
                document.getElementById('early-access-modal').style.display = 'none';
                return;
            }
            
            // Validate email format
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                alert('Please enter a valid email address.');
                return;
            }
            
            btn.disabled = true;
            btn.textContent = 'Submitting...';
            
            const formData = new FormData();
            formData.append('email_address', email);
            
            fetch('https://app.kit.com/forms/9066752/subscriptions', {
                method: 'POST',
                body: formData,
                mode: 'no-cors'
            })
            .then(() => {
                form.innerHTML = `
                    <div class="early-access-success">
                        <div class="early-access-success-icon">&#10003;</div>
                        <p>You're on the list! We'll notify you at <strong>${email}</strong> when TeaTrade Exchange launches.</p>
                    </div>
                `;
            })
            .catch(() => {
                btn.disabled = false;
                btn.textContent = 'Get Early Access';
                alert('Something went wrong. Please try again.');
            });
        }

        // Dynamic Market Status based on Mombasa/Kenya time (EAT = UTC+3)
        function updateMarketStatus() {
            const now = new Date();
            // Get Kenya time (UTC+3)
            const kenyaOffset = 3 * 60; // minutes
            const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
            const kenyaTime = new Date(utc + (kenyaOffset * 60000));
            
            const hour = kenyaTime.getHours();
            const day = kenyaTime.getDay(); // 0 = Sunday, 6 = Saturday
            
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');
            
            // Mombasa Tea Auction: Tuesday sales, but market hours roughly 9am-5pm EAT weekdays
            const isWeekday = day >= 1 && day <= 5;
            const isMarketHours = hour >= 9 && hour < 17;
            
            if (isWeekday && isMarketHours) {
                statusDot.classList.remove('closed');
                statusText.textContent = 'Mombasa OPEN';
            } else {
                statusDot.classList.add('closed');
                const nextOpen = isWeekday ? '09:00 EAT' : 'Monday 09:00 EAT';
                statusText.textContent = 'CLOSED';
            }
        }
        
        updateMarketStatus();
        setInterval(updateMarketStatus, 60000); // Update every minute

        // =============================================
        // PRICE HISTORY - TIME SERIES DATA PERSISTENCE
        // =============================================
        
        // Throttle price recording to prevent API overload
        let lastPriceRecordTime = 0;
        const PRICE_RECORD_INTERVAL = 60000; // Only record every 60 seconds minimum
        
        // Record price ticks for all teas (batched single insert)
        async function recordAllPriceTicks() {
            if (!supabaseClient || !teas || teas.length === 0) return;
            
            // Throttle: don't record more often than once per minute
            const now = Date.now();
            if (now - lastPriceRecordTime < PRICE_RECORD_INTERVAL) {
                return;
            }
            lastPriceRecordTime = now;
            
            const timestamp = new Date().toISOString();
            const records = [];
            
            // Collect tea prices
            for (const tea of teas) {
                if (tea.current_price > 0) {
                    records.push({
                        symbol: tea.symbol,
                        symbol_type: 'tea',
                        price: tea.current_price,
                        volume: 0,
                        recorded_at: timestamp
                    });
                }
            }
            
            // Collect index prices
            const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
            for (const idx of indexes) {
                if (idx.price > 0) {
                    records.push({
                        symbol: idx.symbol,
                        symbol_type: 'index',
                        price: idx.price,
                        volume: 0,
                        recorded_at: timestamp
                    });
                }
            }
            
            // Single batched insert
            if (records.length > 0) {
                try {
                    const { error } = await supabaseClient
                        .from('price_history')
                        .insert(records);
                    
                    if (error) {
                        console.debug('Price history batch insert:', error.message);
                    } else {
                        console.log(`Recorded ${records.length} price ticks`);
                    }
                } catch (e) {
                    console.debug('Price tick recording skipped:', e.message);
                }
            }
        }
        
        // Load historical price data from database
        async function loadPriceHistory(symbol, limit = 200) {
            if (!supabaseClient) return null;
            
            try {
                const { data, error } = await supabaseClient
                    .from('price_history')
                    .select('price, recorded_at, volume')
                    .eq('symbol', symbol)
                    .order('recorded_at', { ascending: true })
                    .limit(limit);
                
                if (error) {
                    console.debug('Price history load:', error.message);
                    return null;
                }
                
                return data;
            } catch (e) {
                console.debug('Price history load skipped:', e.message);
                return null;
            }
        }
        
        // Convert raw price ticks to OHLC candles for charting
        function convertToOHLC(priceData, intervalMinutes = 60) {
            if (!priceData || priceData.length === 0) return [];
            
            const candles = [];
            const intervalMs = intervalMinutes * 60 * 1000;
            
            let currentBucket = null;
            let bucketData = [];
            
            priceData.forEach(tick => {
                const tickTime = new Date(tick.recorded_at).getTime();
                const bucketStart = Math.floor(tickTime / intervalMs) * intervalMs;
                
                if (currentBucket !== bucketStart) {
                    // Save previous bucket
                    if (bucketData.length > 0) {
                        const prices = bucketData.map(d => d.price);
                        candles.push({
                            date: new Date(currentBucket),
                            open: prices[0],
                            high: Math.max(...prices),
                            low: Math.min(...prices),
                            close: prices[prices.length - 1],
                            volume: bucketData.reduce((sum, d) => sum + (d.volume || 0), 0)
                        });
                    }
                    currentBucket = bucketStart;
                    bucketData = [];
                }
                
                bucketData.push({ price: tick.price, volume: tick.volume || 0 });
            });
            
            // Don't forget the last bucket
            if (bucketData.length > 0) {
                const prices = bucketData.map(d => d.price);
                candles.push({
                    date: new Date(currentBucket),
                    open: prices[0],
                    high: Math.max(...prices),
                    low: Math.min(...prices),
                    close: prices[prices.length - 1],
                    volume: bucketData.reduce((sum, d) => sum + (d.volume || 0), 0)
                });
            }
            
            return candles;
        }
        
        // Load chart data from database, with fallback to generated data
        async function loadChartDataFromHistory(symbol, symbolType = 'tea') {
            const rawData = await loadPriceHistory(symbol, 500);
            
            if (rawData && rawData.length >= 10) {
                // We have real historical data - convert to OHLC
                const intervalMap = {
                    '1D': 5,      // 5-minute candles
                    '1W': 60,     // 1-hour candles
                    '1M': 240,    // 4-hour candles
                    '3M': 1440,   // Daily candles
                    '1Y': 1440,   // Daily candles
                    'ALL': 10080  // Weekly candles
                };
                const interval = intervalMap[currentTimeframe] || 60;
                return convertToOHLC(rawData, interval);
            }
            
            // Not enough historical data - return null to trigger fallback
            return null;
        }
        
        // Append a new price tick to existing chart data (real-time update)
        function appendPriceToChart(chartDataArray, newPrice, timestamp = new Date()) {
            if (!chartDataArray || chartDataArray.length === 0) return chartDataArray;
            
            const lastCandle = chartDataArray[chartDataArray.length - 1];
            const lastCandleTime = lastCandle.date.getTime();
            const newTime = timestamp.getTime();
            
            // Determine candle interval from existing data
            const candleInterval = chartDataArray.length > 1 
                ? chartDataArray[1].date.getTime() - chartDataArray[0].date.getTime()
                : 3600000; // Default 1 hour
            
            if (newTime - lastCandleTime < candleInterval) {
                // Update current candle
                lastCandle.high = Math.max(lastCandle.high, newPrice);
                lastCandle.low = Math.min(lastCandle.low, newPrice);
                lastCandle.close = newPrice;
            } else {
                // Create new candle
                const newCandle = {
                    date: new Date(Math.floor(newTime / candleInterval) * candleInterval),
                    open: lastCandle.close,
                    high: Math.max(lastCandle.close, newPrice),
                    low: Math.min(lastCandle.close, newPrice),
                    close: newPrice,
                    volume: 0
                };
                chartDataArray.push(newCandle);
                
                // Keep array at reasonable length
                if (chartDataArray.length > 500) {
                    chartDataArray.shift();
                }
            }
            
            return chartDataArray;
        }

        // =============================================
        // TEATRADE EXCHANGE - PAPER TRADING SYSTEM
        // =============================================

        let tradeType = 'BUY';

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async () => {
            await checkAuthState();
            await loadTeas();
            
            // Initialize unified price cache from database (ensures all charts use same data)
            await initializePriceCache();
            
            await loadTeaPairs();
            await loadLeaderboard();
            await loadUserTrades();
            initPriceVolatility(); // Start random price updates
            
            // Price history recording is handled inside triggerPriceUpdate
            // with throttling to prevent API overload (max once per 60 seconds)
        });

        // =============================================
        // AUTH FUNCTIONS
        // =============================================

        async function checkAuthState() {
            try {
                const { data: { user } } = await supabaseClient.auth.getUser();
                if (user) {
                    currentUser = user;
                    await loadUserProfile();
                    updateUIForLoggedInUser();
                }
            } catch (error) {
                console.error('Auth check error:', error);
            }
        }

        function openAuthModal() {
            document.getElementById('auth-modal').classList.add('visible');
        }

        function closeAuthModal() {
            document.getElementById('auth-modal').classList.remove('visible');
            // Clear errors
            document.getElementById('signup-error').classList.remove('visible');
            document.getElementById('login-error').classList.remove('visible');
        }

        function switchAuthTab(tab) {
            document.getElementById('tab-signup').classList.toggle('active', tab === 'signup');
            document.getElementById('tab-login').classList.toggle('active', tab === 'login');
            document.getElementById('signup-form-container').style.display = tab === 'signup' ? 'block' : 'none';
            document.getElementById('login-form-container').style.display = tab === 'login' ? 'block' : 'none';
        }

        async function handleSignup(e) {
            e.preventDefault();
            const btn = document.getElementById('signup-btn');
            const errorDiv = document.getElementById('signup-error');
            
            const username = document.getElementById('signup-username').value.trim().toLowerCase();
            const email = document.getElementById('signup-email').value.trim();
            const password = document.getElementById('signup-password').value;

            // Validate username
            if (!/^[a-z0-9_]+$/.test(username)) {
                errorDiv.textContent = 'Username can only contain letters, numbers, and underscores';
                errorDiv.classList.add('visible');
                return;
            }

            btn.disabled = true;
            btn.textContent = 'Creating Account...';
            errorDiv.classList.remove('visible');

            try {
                const { data, error } = await supabaseClient.auth.signUp({
                    email,
                    password,
                    options: {
                        data: {
                            username: username,
                            display_name: username
                        }
                    }
                });

                if (error) throw error;

                currentUser = data.user;
                await loadUserProfile();
                updateUIForLoggedInUser();
                closeAuthModal();
                showToast('Welcome to TeaTrade!', `You have $10,000 virtual cash to start trading.`);

            } catch (error) {
                console.error('Signup error:', error);
                errorDiv.textContent = error.message || 'Signup failed. Please try again.';
                errorDiv.classList.add('visible');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Create Account & Start Trading';
            }
        }

        async function handleLogin(e) {
            e.preventDefault();
            const btn = document.getElementById('login-btn');
            const errorDiv = document.getElementById('login-error');
            
            const email = document.getElementById('login-email').value.trim();
            const password = document.getElementById('login-password').value;

            btn.disabled = true;
            btn.textContent = 'Logging in...';
            errorDiv.classList.remove('visible');

            try {
                const { data, error } = await supabaseClient.auth.signInWithPassword({
                    email,
                    password
                });

                if (error) throw error;

                currentUser = data.user;
                await loadUserProfile();
                updateUIForLoggedInUser();
                closeAuthModal();
                showToast('Welcome back!', `Good to see you, ${userProfile?.username || 'trader'}!`);

            } catch (error) {
                console.error('Login error:', error);
                errorDiv.textContent = error.message || 'Login failed. Please check your credentials.';
                errorDiv.classList.add('visible');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Log In';
            }
        }

        async function handleLogout() {
            if (!confirm('Are you sure you want to log out?')) return;
            
            try {
                await supabaseClient.auth.signOut();
                currentUser = null;
                userProfile = null;
                positions = [];
                updateUIForLoggedOutUser();
            } catch (error) {
                console.error('Logout error:', error);
            }
        }

        async function loadUserProfile() {
            if (!currentUser) return;

            try {
                const { data, error } = await supabaseClient
                    .from('profiles')
                    .select('*')
                    .eq('id', currentUser.id)
                    .single();

                if (error) throw error;
                userProfile = data;
                await loadPositions();
                await loadIndexPositions();
            } catch (error) {
                console.error('Profile load error:', error);
            }
        }

        function updateUIForLoggedInUser() {
            document.getElementById('logged-out-ui').style.display = 'none';
            document.getElementById('logged-in-ui').style.display = 'flex';
            document.getElementById('portfolio-section').style.display = 'block';

            // Update balance display
            const balance = userProfile?.cash_balance || 10000;
            document.getElementById('user-balance').textContent = '$' + balance.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
            document.getElementById('trade-balance').textContent = '$' + balance.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});

            // Update avatar
            const initials = (userProfile?.username || 'TT').substring(0, 2).toUpperCase();
            document.getElementById('user-avatar').textContent = initials;

            // Update trade button
            updateTradeButton();
            
            // Update portfolio
            updatePortfolioDisplay();
        }

        function updateUIForLoggedOutUser() {
            document.getElementById('logged-out-ui').style.display = 'block';
            document.getElementById('logged-in-ui').style.display = 'none';
            document.getElementById('portfolio-section').style.display = 'none';
            
            document.getElementById('trade-balance').textContent = '$10,000.00';
            const tradeBtn = document.getElementById('trade-execute-btn');
            tradeBtn.textContent = 'Sign in to Trade';
            tradeBtn.disabled = false;
            tradeBtn.classList.add('signin-prompt');
        }

        // =============================================
        // TRADING FUNCTIONS
        // =============================================

        // Tea display data mapping (symbol -> auction display info with fixed buyer/status)
        // soldPrice: final price when sold, soldTime: timestamp for ordering
        const teaDisplayData = {
            // BIDDING lots - live price updates (10 from DB + additional display-only)
            'CHN-YUN': { grade: 'YUN', estate: 'Yunnan Gold', origin: 'China', lot: 24601, qty: 12400, buyer: 'â€”', status: 'BIDDING' },
            'IND-ASM': { grade: 'ASM', estate: 'Assam Orthodox', origin: 'India', lot: 24602, qty: 8200, buyer: 'â€”', status: 'BIDDING' },
            'IND-DRJ': { grade: 'DRJ', estate: 'Darjeeling First Flush', origin: 'India', lot: 24603, qty: 15600, buyer: 'â€”', status: 'BIDDING' },
            'KEN-BP1': { grade: 'BP1', estate: 'Kenya BP1', origin: 'Kenya', lot: 24604, qty: 22000, buyer: 'â€”', status: 'BIDDING' },
            'KEN-DUST': { grade: 'DUST', estate: 'Kenya Dust', origin: 'Kenya', lot: 24605, qty: 5400, buyer: 'â€”', status: 'BIDDING' },
            'KEN-PF1': { grade: 'PF1', estate: 'Kenya PF1', origin: 'Kenya', lot: 24606, qty: 18900, buyer: 'â€”', status: 'BIDDING' },
            'MLW-BP1': { grade: 'BP1', estate: 'Malawi BP1', origin: 'Malawi', lot: 24607, qty: 9800, buyer: 'â€”', status: 'BIDDING' },
            'RWA-OP': { grade: 'OP', estate: 'Rwanda OP', origin: 'Rwanda', lot: 24608, qty: 6200, buyer: 'â€”', status: 'BIDDING' },
            'SRI-BOP': { grade: 'BOP', estate: 'Ceylon BOP', origin: 'Sri Lanka', lot: 24609, qty: 14500, buyer: 'â€”', status: 'BIDDING' },
            'SRI-PEK': { grade: 'PEK', estate: 'Ceylon Pekoe', origin: 'Sri Lanka', lot: 24610, qty: 8700, buyer: 'â€”', status: 'BIDDING' },
            // Additional lots using same DB prices with different lot numbers
            'CHN-YUN-2': { grade: 'YUN', estate: 'Yunnan Special Reserve', origin: 'China', lot: 24611, qty: 6300, buyer: 'â€”', status: 'BIDDING', priceFrom: 'CHN-YUN' },
            'IND-DRJ-2': { grade: 'DRJ', estate: 'Darjeeling Second Flush', origin: 'India', lot: 24612, qty: 11200, buyer: 'â€”', status: 'BIDDING', priceFrom: 'IND-DRJ' },
            'KEN-BP1-2': { grade: 'BP1', estate: 'Kenya Premium BP1', origin: 'Kenya', lot: 24613, qty: 19500, buyer: 'â€”', status: 'BIDDING', priceFrom: 'KEN-BP1' },
            'IND-ASM-2': { grade: 'ASM', estate: 'Assam Golden Tips', origin: 'India', lot: 24614, qty: 4800, buyer: 'â€”', status: 'BIDDING', priceFrom: 'IND-ASM' },
            'SRI-PEK-2': { grade: 'PEK', estate: 'Ceylon Highland Pekoe', origin: 'Sri Lanka', lot: 24615, qty: 9200, buyer: 'â€”', status: 'BIDDING', priceFrom: 'SRI-PEK' },
            'KEN-PF1-2': { grade: 'PF1', estate: 'Kenya Estate PF1', origin: 'Kenya', lot: 24616, qty: 16400, buyer: 'â€”', status: 'BIDDING', priceFrom: 'KEN-PF1' },
            'MLW-BP1-2': { grade: 'BP1', estate: 'Malawi Estate BP1', origin: 'Malawi', lot: 24617, qty: 7600, buyer: 'â€”', status: 'BIDDING', priceFrom: 'MLW-BP1' },
            // SOLD lots at the bottom
            'SRI-BOP-SOLD': { grade: 'BOP', estate: 'Ceylon Vintage BOP', origin: 'Sri Lanka', lot: 24500, qty: 7800, buyer: 'Tata Global', status: 'SOLD', soldPrice: 4.65, soldTime: 3, priceFrom: 'SRI-BOP' },
            'KEN-BP1-SOLD': { grade: 'BP1', estate: 'Kenya Select BP1', origin: 'Kenya', lot: 24501, qty: 11200, buyer: 'Unilever Tea', status: 'SOLD', soldPrice: 2.94, soldTime: 2, priceFrom: 'KEN-BP1' },
            'IND-DRJ-SOLD': { grade: 'DRJ', estate: 'Darjeeling Reserve', origin: 'India', lot: 24502, qty: 5400, buyer: 'Harrods Ltd', status: 'SOLD', soldPrice: 8.72, soldTime: 1, priceFrom: 'IND-DRJ' }
        };

        async function loadTeas() {
            try {
                const { data, error } = await supabaseClient
                    .from('teas')
                    .select('*')
                    .order('symbol');

                if (error) throw error;
                teas = data;
                populateTeaSelect();
                updateAuctionTable(); // Update live auction results
                updatePairsTable(); // Update pairs with new ratios
                updatePortfolioDisplay(); // Refresh portfolio with new prices
                updateQuoteBoard(); // Update flash quote board
                updateWatchlistTeas(); // Update watchlist with live prices
                populateHubTeaSelects(); // Update trading hub selects
                updateAllMarketIndexes(); // Update all market index prices from real tea data
                updateMainChartWithRealData(); // Regenerate main chart
            } catch (error) {
                console.error('Failed to load teas:', error);
            }
        }
        
        // Update main chart to use real calculated index prices
        function updateMainChartWithRealData() {
            if (!teas || teas.length === 0) return;
            
            const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
            const kenyaIndex = indexes.find(idx => idx.symbol === 'KENYA');
            
            if (kenyaIndex && mainChartData.symbol === 'KENYA') {
                mainChartData.basePrice = kenyaIndex.price;
                mainChartData.change = kenyaIndex.change;
                
                // Update displayed values
                const priceEl = document.getElementById('main-chart-price');
                if (priceEl) {
                    priceEl.textContent = `$${kenyaIndex.price.toFixed(2)}`;
                    priceEl.className = 'chart-stat-value ' + (kenyaIndex.change >= 0 ? 'up' : 'down');
                }
                
                const changeEl = document.getElementById('main-chart-change');
                if (changeEl) {
                    const changeVal = kenyaIndex.change >= 0 ? '+' : '';
                    changeEl.textContent = `${changeVal}${kenyaIndex.change.toFixed(2)}%`;
                }
                
                // Regenerate chart data with correct price
                cachedTimeframe = null;
                teaHistoricalData['INDEX_KENYA'] = null; // Clear cached data
                chartData = generateIndexHistoricalData('KENYA');
                drawChart();
            }
        }
        
        function populateHubTeaSelects() {
            const buySelect = document.getElementById('hub-buy-symbol');
            const sellSelect = document.getElementById('hub-sell-symbol');
            
            if (!buySelect || !sellSelect) return;
            
            // Store current values
            const currentBuy = buySelect.value;
            const currentSell = sellSelect.value;
            
            // Clear and rebuild
            buySelect.innerHTML = '';
            sellSelect.innerHTML = '';
            
            // Add teas
            if (teas && teas.length) {
                const teaOptgroup = document.createElement('optgroup');
                teaOptgroup.label = 'Teas';
                const sellTeaOptgroup = document.createElement('optgroup');
                sellTeaOptgroup.label = 'Teas';
                
                teas.forEach(tea => {
                    const buyOption = document.createElement('option');
                    buyOption.value = tea.symbol;
                    buyOption.textContent = `${tea.symbol} ($${tea.current_price?.toFixed(2) || '0.00'})`;
                    teaOptgroup.appendChild(buyOption);
                    
                    const sellOption = document.createElement('option');
                    sellOption.value = tea.symbol;
                    sellOption.textContent = `${tea.symbol} ($${tea.current_price?.toFixed(2) || '0.00'})`;
                    sellTeaOptgroup.appendChild(sellOption);
                });
                
                buySelect.appendChild(teaOptgroup);
                sellSelect.appendChild(sellTeaOptgroup);
            }
            
            // Add indexes (tradable as composite products)
            const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
            if (indexes && indexes.length > 0) {
                const indexOptgroup = document.createElement('optgroup');
                indexOptgroup.label = 'Indexes';
                const sellIndexOptgroup = document.createElement('optgroup');
                sellIndexOptgroup.label = 'Indexes';
                
                indexes.forEach(idx => {
                    const buyOption = document.createElement('option');
                    buyOption.value = idx.symbol;
                    buyOption.textContent = `${idx.symbol} Index ($${idx.price?.toFixed(2) || '0.00'})`;
                    indexOptgroup.appendChild(buyOption);
                    
                    const sellOption = document.createElement('option');
                    sellOption.value = idx.symbol;
                    sellOption.textContent = `${idx.symbol} Index ($${idx.price?.toFixed(2) || '0.00'})`;
                    sellIndexOptgroup.appendChild(sellOption);
                });
                
                buySelect.appendChild(indexOptgroup);
                sellSelect.appendChild(sellIndexOptgroup);
            }
            
            // Restore selections if valid
            if (currentBuy && [...buySelect.options].some(o => o.value === currentBuy)) {
                buySelect.value = currentBuy;
            }
            if (currentSell && [...sellSelect.options].some(o => o.value === currentSell)) {
                sellSelect.value = currentSell;
            }
            
            updateHubOrderPreview();
        }

        // Track previous auction prices for flash detection (only for BIDDING lots)
        let previousAuctionPrices = {};

        function updateAuctionTable() {
            const tbody = document.getElementById('auction-table-body');
            if (!tbody || !teas.length) return;

            // Build tea lookup map
            const teaMap = {};
            teas.forEach(tea => teaMap[tea.symbol] = tea);

            // Build auction items from display data
            const auctionItems = Object.entries(teaDisplayData).map(([symbol, displayData]) => {
                // Get price source - either this symbol or priceFrom reference
                const priceSymbol = displayData.priceFrom || symbol;
                const tea = teaMap[priceSymbol] || { 
                    symbol: priceSymbol, 
                    current_price: displayData.soldPrice || 0, 
                    previous_price: displayData.soldPrice || 0 
                };
                return { symbol, tea, displayData };
            });

            // Sort: BIDDING first, then PENDING, then SOLD (by soldTime desc)
            const statusOrder = { 'BIDDING': 0, 'PENDING': 1, 'SOLD': 2 };
            auctionItems.sort((a, b) => {
                const statusDiff = statusOrder[a.displayData.status] - statusOrder[b.displayData.status];
                if (statusDiff !== 0) return statusDiff;
                // Within SOLD, sort by soldTime descending (most recent first)
                if (a.displayData.status === 'SOLD') {
                    return (b.displayData.soldTime || 0) - (a.displayData.soldTime || 0);
                }
                return 0;
            });

            // Detect price changes only for BIDDING lots
            const changedTeas = {};
            auctionItems.forEach(({ symbol, tea, displayData }) => {
                if (displayData.status === 'BIDDING') {
                    const trackKey = symbol; // Track by display symbol, not DB symbol
                    if (previousAuctionPrices[trackKey] !== undefined && 
                        previousAuctionPrices[trackKey] !== tea.current_price) {
                        changedTeas[symbol] = tea.current_price > previousAuctionPrices[trackKey] ? 'up' : 'down';
                    }
                    previousAuctionPrices[trackKey] = tea.current_price;
                }
            });

            tbody.innerHTML = auctionItems.map(({ symbol, tea, displayData }) => {
                const status = displayData.status;
                const buyer = displayData.buyer;

                // Determine price to display
                let displayPrice;
                let changeStr;
                let changeClass = '';
                let flashClass = '';

                if (status === 'SOLD') {
                    // Fixed sold price, no change
                    displayPrice = displayData.soldPrice || tea.current_price;
                    changeStr = 'â€”';
                } else if (status === 'PENDING') {
                    // Fixed price, no change (not being bid on yet)
                    displayPrice = tea.current_price;
                    changeStr = 'â€”';
                } else {
                    // BIDDING - live price with changes
                    displayPrice = tea.current_price;
                    const change = tea.previous_price 
                        ? ((tea.current_price - tea.previous_price) / tea.previous_price * 100)
                        : 0;
                    changeStr = change !== 0 ? `${change >= 0 ? '+' : ''}${change.toFixed(1)}%` : 'â€”';
                    changeClass = change > 0 ? 'up' : change < 0 ? 'down' : '';
                    flashClass = changedTeas[symbol] ? `flash-${changedTeas[symbol]}` : '';
                }

                let statusColor;
                if (status === 'SOLD') {
                    statusColor = 'var(--accent-green)';
                } else if (status === 'BIDDING') {
                    statusColor = 'var(--accent-orange)';
                } else {
                    statusColor = 'var(--text-muted)';
                }

                return `
                    <tr>
                        <td style="font-family: 'JetBrains Mono', monospace;">#${displayData.lot}</td>
                        <td><span class="grade-badge">${displayData.grade}</span></td>
                        <td>${displayData.estate}</td>
                        <td class="auction-center">${displayData.origin}</td>
                        <td>${displayData.qty.toLocaleString()}</td>
                        <td class="price-cell ${changeClass} ${flashClass}" data-tea="${symbol}">
                            <span>$${displayPrice.toFixed(2)}</span>
                            <button class="price-alert-btn ${priceAlerts[symbol] ? 'has-alert' : ''}" onclick="event.stopPropagation(); openPriceAlertModal('${symbol}', ${displayPrice})" title="Set price alert">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                                    <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
                                </svg>
                            </button>
                        </td>
                        <td class="${changeClass}">${changeStr}</td>
                        <td>${buyer}</td>
                        <td><span style="color: ${statusColor};">${status}</span></td>
                    </tr>
                `;
            }).join('');
        }

        // Random price volatility system
        async function triggerPriceUpdate() {
            try {
                const { error } = await supabaseClient.rpc('update_tea_prices');
                if (error) throw error;
                console.log('Prices updated');
                await loadTeas(); // Reload prices after update
                await loadUserTrades(); // Refresh P/L on orders
                
                // Record price ticks to history database
                recordAllPriceTicks();
                
                // Update chart data incrementally (append new tick, don't regenerate)
                updateChartsWithNewPrices();
                
                // Check SL/TP triggers
                if (currentUser) {
                    await checkSlTpOrders();
                }
                
                // Check price alerts
                await checkPriceAlerts();
            } catch (error) {
                console.error('Failed to update prices:', error);
            }
        }
        
        // Update charts incrementally with new price data
        function updateChartsWithNewPrices() {
            // Update main chart if showing a tea or index
            if (chartData && chartData.length > 0) {
                let newPrice = null;
                
                if (mainChartData.isTea) {
                    const tea = teas?.find(t => t.symbol === mainChartData.symbol);
                    newPrice = tea?.current_price;
                } else if (mainChartData.isIndex || mainChartData.symbol) {
                    const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
                    const idx = indexes.find(i => i.symbol === mainChartData.symbol);
                    newPrice = idx?.price || mainChartData.basePrice;
                }
                
                if (newPrice && newPrice > 0) {
                    appendPriceToChart(chartData, newPrice);
                    mainChartData.basePrice = newPrice;
                    
                    // Update displayed price
                    const priceEl = document.getElementById('main-chart-price');
                    if (priceEl) {
                        priceEl.textContent = formatIndexPrice(newPrice, mainChartData.currency || '$');
                    }
                    
                    drawChart(); // Redraw with updated data
                }
            }
            
            // Update hub chart if panel is open
            if (hubChartData && hubChartData.length > 0 && maximizedPanel?.classList.contains('panel-maximized')) {
                const symbol = document.getElementById('hub-buy-symbol')?.value;
                if (symbol) {
                    const indexSymbols = ['KENYA', 'KENYAN', 'INDIA', 'CEYLON', 'CHINA', 'JAPAN', 'AFRICA', 'ASIA'];
                    const lookupSymbol = symbol === 'KENYAN' ? 'KENYA' : symbol;
                    const isIndex = indexSymbols.includes(symbol);
                    
                    let newPrice;
                    if (isIndex) {
                        const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
                        const index = indexes.find(idx => idx.symbol === lookupSymbol);
                        newPrice = index?.price;
                    } else {
                        const tea = teas?.find(t => t.symbol === symbol);
                        newPrice = tea?.current_price;
                    }
                    
                    if (newPrice && newPrice > 0) {
                        appendPriceToChart(hubChartData, newPrice);
                        drawHubChart();
                    }
                }
            }
        }
        
        // Check and execute Stop Loss / Take Profit orders
        async function checkSlTpOrders() {
            for (const teaId of Object.keys(pendingSlTpOrders)) {
                const order = pendingSlTpOrders[teaId];
                const tea = teas.find(t => t.id === parseInt(teaId));
                if (!tea) continue;
                
                const currentPrice = tea.current_price;
                let triggered = false;
                let triggerType = '';
                
                // For a BUY position:
                // - Stop Loss triggers when price falls below SL (sell to limit loss)
                // - Take Profit triggers when price rises above TP (sell to lock in profit)
                if (order.side === 'BUY') {
                    if (order.sl && currentPrice <= order.sl) {
                        triggered = true;
                        triggerType = 'Stop Loss';
                    } else if (order.tp && currentPrice >= order.tp) {
                        triggered = true;
                        triggerType = 'Take Profit';
                    }
                }
                
                if (triggered) {
                    // Execute the closing trade
                    await executeSlTpClose(parseInt(teaId), order, currentPrice, triggerType);
                }
            }
        }
        
        // Execute SL/TP close order
        async function executeSlTpClose(teaId, order, currentPrice, triggerType) {
            const tea = teas.find(t => t.id === teaId);
            if (!tea) return;
            
            const position = positions.find(p => p.tea_id === teaId);
            if (!position) {
                // Position no longer exists, remove pending order
                delete pendingSlTpOrders[teaId];
                return;
            }
            
            // Close the position at current price
            const qty = Math.min(order.qty, position.quantity);
            const total = currentPrice * qty;
            
            try {
                // Update cash balance
                const newBalance = userProfile.cash_balance + total;
                const { error: balanceError } = await supabaseClient
                    .from('profiles')
                    .update({ cash_balance: newBalance })
                    .eq('id', currentUser.id);
                if (balanceError) throw balanceError;
                
                // Update position
                const newQty = position.quantity - qty;
                if (newQty <= 0) {
                    const { error: posError } = await supabaseClient
                        .from('positions')
                        .delete()
                        .eq('id', position.id);
                    if (posError) throw posError;
                } else {
                    const { error: posError } = await supabaseClient
                        .from('positions')
                        .update({ 
                            quantity: newQty,
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', position.id);
                    if (posError) throw posError;
                }
                
                // Record trade
                const { error: tradeError } = await supabaseClient
                    .from('trades')
                    .insert({
                        user_id: currentUser.id,
                        tea_id: teaId,
                        side: 'SELL',
                        quantity: qty,
                        price: currentPrice,
                        total_value: total
                    });
                if (tradeError) throw tradeError;
                
                // Calculate P/L
                const pnl = (currentPrice - order.entryPrice) * qty;
                const pnlText = pnl >= 0 ? `+$${pnl.toFixed(2)}` : `-$${Math.abs(pnl).toFixed(2)}`;
                
                // Remove pending order
                delete pendingSlTpOrders[teaId];
                
                // Update UI
                userProfile.cash_balance = newBalance;
                await loadPositions();
                updateUIForLoggedInUser();
                
                // Show notification
                showToast(`${triggerType} Triggered!`, `${order.symbol} closed at $${currentPrice.toFixed(2)} (${pnlText})`);
                
            } catch (error) {
                console.error('SL/TP execution error:', error);
                showToast('SL/TP Error', error.message, true);
            }
        }

        // Check if prices need updating and set up periodic updates
        async function initPriceVolatility() {
            // Trigger first price update immediately for testing
            await triggerPriceUpdate();

            // Set up random intervals for price updates (2-5 seconds for testing)
            schedulePriceUpdate();
        }

        function schedulePriceUpdate() {
            // Random interval between 2 and 5 seconds (for testing)
            const interval = Math.floor(Math.random() * 3000) + 2000; // 2-5 seconds
            setTimeout(async () => {
                await triggerPriceUpdate();
                schedulePriceUpdate(); // Schedule next update
            }, interval);
        }

        // Track if user is actively interacting with trade form
        let isTradeFormActive = false;
        
        // Set up focus tracking on trade form inputs
        document.addEventListener('DOMContentLoaded', () => {
            const tradeFormInputs = ['trade-tea-select', 'trade-qty', 'trade-price', 'sl-input', 'tp-input'];
            tradeFormInputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('focus', () => { isTradeFormActive = true; });
                    el.addEventListener('blur', () => { 
                        // Small delay to allow for tab navigation between fields
                        setTimeout(() => {
                            const activeEl = document.activeElement;
                            if (!tradeFormInputs.includes(activeEl?.id)) {
                                isTradeFormActive = false;
                            }
                        }, 100);
                    });
                }
            });
        });
        
        // Update watchlist with live tea data
        function updateWatchlistTeas() {
            const container = document.getElementById('watchlist-teas');
            if (!container || !teas || teas.length === 0) return;
            
            // Show top 5 teas with most volume/activity (or just first 5)
            const watchlistTeas = teas.slice(0, 5);
            
            let html = '';
            watchlistTeas.forEach(tea => {
                const change = tea.previous_price > 0 
                    ? ((tea.current_price - tea.previous_price) / tea.previous_price) * 100 
                    : (tea.price_change_24h || 0);
                const isUp = change >= 0;
                const shortSymbol = tea.symbol.split('-')[1] || tea.symbol;
                const origin = tea.symbol.split('-')[0] || '';
                
                html += `
                    <div class="watchlist-item" onclick="openWatchlistChart('${tea.symbol}')" data-symbol="${tea.symbol}">
                        <div>
                            <div class="watchlist-name">${tea.name || shortSymbol}</div>
                            <div class="watchlist-grade">${origin} ${tea.grade || shortSymbol}</div>
                        </div>
                        <div class="watchlist-price">
                            <div class="watchlist-value">$${tea.current_price.toFixed(2)}</div>
                            <div class="watchlist-change ${isUp ? 'up' : 'down'}">${isUp ? '+' : ''}${change.toFixed(1)}%</div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        // Open chart modal from watchlist click
        function openWatchlistChart(symbol) {
            const tea = teas.find(t => t.symbol === symbol);
            if (tea) {
                openQuickQuoteModal(tea);
            }
        }

        function populateTeaSelect() {
            const select = document.getElementById('trade-tea-select');
            
            // Preserve current selection
            const currentValue = select.value;
            const currentQty = document.getElementById('trade-qty')?.value;
            
            // Skip full rebuild if user is actively using the form
            if (isTradeFormActive && currentValue) {
                // Just update the prices in existing options without rebuilding
                teas.forEach(tea => {
                    const option = select.querySelector(`option[value="${tea.id}"]`);
                    if (option) {
                        const change = tea.previous_price ? ((tea.current_price - tea.previous_price) / tea.previous_price * 100).toFixed(1) : '0.0';
                        const changeSign = change >= 0 ? '+' : '';
                        option.textContent = `${tea.symbol} - $${tea.current_price.toFixed(2)} (${changeSign}${change}%)`;
                        option.dataset.price = tea.current_price;
                    }
                });
                
                // ALSO update index prices (crucial for live trading)
                const indexes = calculateRegionalIndexes();
                if (indexes && indexes.length > 0) {
                    indexes.forEach(idx => {
                        const option = select.querySelector(`option[value="INDEX_${idx.symbol}"]`);
                        if (option) {
                            const changeSign = idx.change >= 0 ? '+' : '';
                            option.textContent = `${idx.symbol} Index - $${idx.price.toFixed(2)} (${changeSign}${idx.change.toFixed(1)}%)`;
                            option.dataset.price = idx.price;
                        }
                    });
                }
                
                // Update the trade summary with new price
                updateTradeSummary();
                return;
            }
            
            select.innerHTML = '<option value="">Select Tea...</option>';
            
            // Add teas
            const teaOptgroup = document.createElement('optgroup');
            teaOptgroup.label = 'Teas';
            teas.forEach(tea => {
                const change = tea.previous_price ? ((tea.current_price - tea.previous_price) / tea.previous_price * 100).toFixed(1) : '0.0';
                const changeSign = change >= 0 ? '+' : '';
                const option = document.createElement('option');
                option.value = tea.id;
                option.textContent = `${tea.symbol} - $${tea.current_price.toFixed(2)} (${changeSign}${change}%)`;
                option.dataset.price = tea.current_price;
                option.dataset.type = 'tea';
                teaOptgroup.appendChild(option);
            });
            select.appendChild(teaOptgroup);
            
            // Add regional indexes
            const indexes = calculateRegionalIndexes();
            if (indexes && indexes.length > 0) {
                const indexOptgroup = document.createElement('optgroup');
                indexOptgroup.label = 'Indexes';
                indexes.forEach(idx => {
                    const changeSign = idx.change >= 0 ? '+' : '';
                    const option = document.createElement('option');
                    option.value = `INDEX_${idx.symbol}`;
                    option.textContent = `${idx.symbol} Index - $${idx.price.toFixed(2)} (${changeSign}${idx.change.toFixed(1)}%)`;
                    option.dataset.price = idx.price;
                    option.dataset.type = 'index';
                    indexOptgroup.appendChild(option);
                });
                select.appendChild(indexOptgroup);
            }
            
            // Restore selection if it still exists
            if (currentValue) {
                select.value = currentValue;
                // Only restore qty if we had a selection
                if (currentQty && document.getElementById('trade-qty')) {
                    document.getElementById('trade-qty').value = currentQty;
                }
                updateTradeSummary();
            }
        }

        function setTradeType(type) {
            tradeType = type;
            document.getElementById('btn-trade-buy').classList.toggle('active', type === 'BUY');
            document.getElementById('btn-trade-sell').classList.toggle('active', type === 'SELL');
            
            const btn = document.getElementById('trade-execute-btn');
            btn.classList.remove('buy', 'sell');
            btn.classList.add(type.toLowerCase());
            
            updateTradeButton();
        }
        
        function adjustSlTp(inputId, delta) {
            const input = document.getElementById(inputId);
            const currentVal = parseFloat(input.value) || 0;
            const newVal = Math.max(0, currentVal + delta);
            input.value = newVal.toFixed(2);
        }

        function updateTradeSummary() {
            const select = document.getElementById('trade-tea-select');
            const qtyInput = document.getElementById('trade-qty');
            const priceInput = document.getElementById('trade-price');
            const valueEl = document.getElementById('trade-value');
            
            const selectedOption = select.options[select.selectedIndex];
            const price = selectedOption?.dataset?.price ? parseFloat(selectedOption.dataset.price) : 0;
            const qty = parseFloat(qtyInput.value) || 0;
            
            priceInput.value = price > 0 ? price.toFixed(3) : '';
            const total = price * qty;
            valueEl.textContent = '$' + total.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
            
            updateTradeButton();
        }

        function updateTradeButton() {
            const btn = document.getElementById('trade-execute-btn');
            const select = document.getElementById('trade-tea-select');
            const qty = parseFloat(document.getElementById('trade-qty').value) || 0;
            const price = parseFloat(document.getElementById('trade-price').value) || 0;
            const total = price * qty;

            if (!currentUser) {
                btn.textContent = 'Sign in to Trade';
                btn.disabled = false; // Keep enabled so it opens auth modal
                btn.classList.add('signin-prompt');
                return;
            }
            
            btn.classList.remove('signin-prompt');

            if (!select.value) {
                btn.textContent = 'Select a Tea';
                btn.disabled = true;
                return;
            }

            if (qty <= 0) {
                btn.textContent = 'Enter Quantity';
                btn.disabled = true;
                return;
            }

            if (tradeType === 'BUY') {
                if (total > (userProfile?.cash_balance || 0)) {
                    btn.textContent = 'Insufficient Balance';
                    btn.disabled = true;
                    return;
                }
                btn.textContent = `BUY ${qty.toLocaleString()} kg for $${total.toFixed(2)}`;
            } else {
                // Check if user has enough to sell
                // Handle both tea IDs and index symbols
                const selectValue = select.value;
                const isIndex = selectValue.startsWith('INDEX_');
                
                if (isIndex) {
                    // For indexes, we don't track holdings - allow sell if balance allows
                    btn.textContent = `SELL ${qty.toLocaleString()} kg for $${total.toFixed(2)}`;
                } else {
                    const teaId = parseInt(selectValue);
                    const position = positions.find(p => p.tea_id === teaId);
                    if (!position || position.quantity < qty) {
                        btn.textContent = 'Insufficient Holdings';
                        btn.disabled = true;
                        return;
                    }
                    btn.textContent = `SELL ${qty.toLocaleString()} kg for $${total.toFixed(2)}`;
                }
            }
            btn.disabled = false;
        }

        async function executeTrade() {
            if (!currentUser) {
                openAuthModal();
                return;
            }

            const btn = document.getElementById('trade-execute-btn');
            const select = document.getElementById('trade-tea-select');
            const selectValue = select.value;
            const qty = parseFloat(document.getElementById('trade-qty').value);
            const price = parseFloat(document.getElementById('trade-price').value);
            const total = price * qty;
            
            // Get SL/TP values
            const slInput = document.getElementById('trade-sl');
            const tpInput = document.getElementById('trade-tp');
            const stopLoss = slInput.value ? parseFloat(slInput.value) : null;
            const takeProfit = tpInput.value ? parseFloat(tpInput.value) : null;
            
            // Check if this is an index trade (value starts with INDEX_)
            const isIndexTrade = selectValue.startsWith('INDEX_');
            let tea = null;
            let teaId = null;
            let indexSymbol = null;
            let productName = '';
            
            if (isIndexTrade) {
                indexSymbol = selectValue.replace('INDEX_', '');
                const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
                const index = indexes.find(idx => idx.symbol === indexSymbol);
                if (!index) {
                    showToast('Index not found', 'error', true);
                    return;
                }
                productName = index.name || indexSymbol + ' Index';
                // Use first underlying tea for database reference
                tea = teas?.find(t => index.teas?.includes(t.symbol));
                teaId = tea?.id || null;
            } else {
                teaId = parseInt(selectValue);
                tea = teas.find(t => t.id === teaId);
                if (!tea) return;
                productName = tea.name || tea.symbol;
            }

            btn.disabled = true;
            btn.textContent = 'Executing...';

            try {
                if (isIndexTrade) {
                    // INDEX TRADE HANDLING
                    if (tradeType === 'BUY') {
                        if (total > userProfile.cash_balance) {
                            throw new Error('Insufficient balance');
                        }
                        
                        // Update cash balance
                        const newBalance = userProfile.cash_balance - total;
                        const { error: balanceError } = await supabaseClient
                            .from('profiles')
                            .update({ cash_balance: newBalance })
                            .eq('id', currentUser.id);
                        if (balanceError) throw balanceError;
                        userProfile.cash_balance = newBalance;
                        
                        // Update index position in database
                        if (typeof updateIndexPosition === 'function') {
                            await updateIndexPosition(indexSymbol, qty, price, 'BUY');
                        }
                        
                        showToast('Trade Executed!', `Bought ${qty.toLocaleString()} kg of ${productName} at $${price.toFixed(2)}/kg`);
                        
                    } else {
                        // SELL index
                        const indexPos = typeof getIndexPosition === 'function' ? getIndexPosition(indexSymbol) : null;
                        if (!indexPos || indexPos.quantity < qty) {
                            throw new Error('Insufficient index holdings');
                        }
                        
                        // Update cash balance
                        const newBalance = userProfile.cash_balance + total;
                        const { error: balanceError } = await supabaseClient
                            .from('profiles')
                            .update({ cash_balance: newBalance })
                            .eq('id', currentUser.id);
                        if (balanceError) throw balanceError;
                        userProfile.cash_balance = newBalance;
                        
                        // Update index position in database
                        if (typeof updateIndexPosition === 'function') {
                            await updateIndexPosition(indexSymbol, qty, price, 'SELL');
                        }
                        
                        const pnl = (price - indexPos.avg_entry_price) * qty;
                        const pnlText = pnl >= 0 ? `Profit: +$${pnl.toFixed(2)}` : `Loss: -$${Math.abs(pnl).toFixed(2)}`;
                        showToast('Trade Executed!', `Sold ${qty.toLocaleString()} kg of ${productName}. ${pnlText}`);
                    }
                    
                    // Record trade with index_symbol in database
                    const { error: tradeError } = await supabaseClient
                        .from('trades')
                        .insert({
                            user_id: currentUser.id,
                            tea_id: teaId,
                            side: tradeType,
                            quantity: qty,
                            price: price,
                            total_value: total,
                            index_symbol: indexSymbol
                        });
                    if (tradeError) throw tradeError;
                    
                } else if (tradeType === 'BUY') {
                    // Check balance
                    if (total > userProfile.cash_balance) {
                        throw new Error('Insufficient balance');
                    }

                    // Update cash balance
                    const newBalance = userProfile.cash_balance - total;
                    const { error: balanceError } = await supabaseClient
                        .from('profiles')
                        .update({ cash_balance: newBalance })
                        .eq('id', currentUser.id);
                    if (balanceError) throw balanceError;

                    // Update or create position
                    const existingPosition = positions.find(p => p.tea_id === teaId);
                    if (existingPosition) {
                        // Calculate new average price
                        const totalQty = existingPosition.quantity + qty;
                        const newAvgPrice = ((existingPosition.avg_entry_price * existingPosition.quantity) + (price * qty)) / totalQty;
                        
                        const { error: posError } = await supabaseClient
                            .from('positions')
                            .update({ 
                                quantity: totalQty, 
                                avg_entry_price: newAvgPrice,
                                updated_at: new Date().toISOString()
                            })
                            .eq('id', existingPosition.id);
                        if (posError) throw posError;
                    } else {
                        const { error: posError } = await supabaseClient
                            .from('positions')
                            .insert({
                                user_id: currentUser.id,
                                tea_id: teaId,
                                quantity: qty,
                                avg_entry_price: price
                            });
                        if (posError) throw posError;
                    }

                    // Record trade
                    const { error: tradeError } = await supabaseClient
                        .from('trades')
                        .insert({
                            user_id: currentUser.id,
                            tea_id: teaId,
                            side: 'BUY',
                            quantity: qty,
                            price: price,
                            total_value: total
                        });
                    if (tradeError) throw tradeError;

                    userProfile.cash_balance = newBalance;
                    showToast('Trade Executed!', `Bought ${qty.toLocaleString()} kg of ${tea.symbol} at $${price.toFixed(2)}/kg`);
                    
                    // Register SL/TP orders if set
                    if (stopLoss || takeProfit) {
                        pendingSlTpOrders[teaId] = {
                            sl: stopLoss,
                            tp: takeProfit,
                            side: 'BUY', // Original trade side
                            qty: qty,
                            symbol: tea.symbol,
                            entryPrice: price
                        };
                        if (stopLoss && takeProfit) {
                            showToast('SL/TP Set', `SL: $${stopLoss.toFixed(2)} | TP: $${takeProfit.toFixed(2)}`);
                        } else if (stopLoss) {
                            showToast('Stop Loss Set', `Will close at $${stopLoss.toFixed(2)}`);
                        } else {
                            showToast('Take Profit Set', `Will close at $${takeProfit.toFixed(2)}`);
                        }
                    }

                } else {
                    // SELL
                    const existingPosition = positions.find(p => p.tea_id === teaId);
                    if (!existingPosition || existingPosition.quantity < qty) {
                        throw new Error('Insufficient holdings');
                    }

                    // Update cash balance
                    const newBalance = userProfile.cash_balance + total;
                    const { error: balanceError } = await supabaseClient
                        .from('profiles')
                        .update({ cash_balance: newBalance })
                        .eq('id', currentUser.id);
                    if (balanceError) throw balanceError;

                    // Update position
                    const newQty = existingPosition.quantity - qty;
                    if (newQty <= 0) {
                        const { error: posError } = await supabaseClient
                            .from('positions')
                            .delete()
                            .eq('id', existingPosition.id);
                        if (posError) throw posError;
                    } else {
                        const { error: posError } = await supabaseClient
                            .from('positions')
                            .update({ 
                                quantity: newQty,
                                updated_at: new Date().toISOString()
                            })
                            .eq('id', existingPosition.id);
                        if (posError) throw posError;
                    }

                    // Record trade
                    const { error: tradeError } = await supabaseClient
                        .from('trades')
                        .insert({
                            user_id: currentUser.id,
                            tea_id: teaId,
                            side: 'SELL',
                            quantity: qty,
                            price: price,
                            total_value: total
                        });
                    if (tradeError) throw tradeError;

                    userProfile.cash_balance = newBalance;
                    const pnl = (price - existingPosition.avg_entry_price) * qty;
                    const pnlText = pnl >= 0 ? `Profit: +$${pnl.toFixed(2)}` : `Loss: -$${Math.abs(pnl).toFixed(2)}`;
                    showToast('Trade Executed!', `Sold ${qty.toLocaleString()} kg of ${tea.symbol}. ${pnlText}`);
                }

                // Refresh data
                await loadPositions();
                await loadUserTrades();
                updateUIForLoggedInUser();
                
                // Reset form
                document.getElementById('trade-qty').value = '';
                document.getElementById('trade-sl').value = '';
                document.getElementById('trade-tp').value = '';
                updateTradeSummary();

            } catch (error) {
                console.error('Trade error:', error);
                showToast('Trade Failed', error.message, true);
            }

            updateTradeButton();
        }

        async function closePosition(teaId, quantity, teaSymbol) {
            if (!currentUser) {
                openAuthModal();
                return;
            }

            const tea = teas.find(t => t.id === teaId);
            if (!tea) {
                showToast('Error', 'Tea not found', true);
                return;
            }

            // Find the user's position
            const position = positions.find(p => p.tea_id === teaId);
            if (!position || position.quantity < quantity) {
                showToast('Error', 'Position not found or insufficient quantity', true);
                return;
            }

            const price = tea.current_price;
            const total = price * quantity;

            try {
                // Update cash balance
                const newBalance = userProfile.cash_balance + total;
                const { error: balanceError } = await supabaseClient
                    .from('profiles')
                    .update({ cash_balance: newBalance })
                    .eq('id', currentUser.id);
                if (balanceError) throw balanceError;

                // Update or delete position
                const newQty = position.quantity - quantity;
                if (newQty <= 0) {
                    const { error: posError } = await supabaseClient
                        .from('positions')
                        .delete()
                        .eq('id', position.id);
                    if (posError) throw posError;
                } else {
                    const { error: posError } = await supabaseClient
                        .from('positions')
                        .update({ 
                            quantity: newQty,
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', position.id);
                    if (posError) throw posError;
                }

                // Record the closing trade
                const { error: tradeError } = await supabaseClient
                    .from('trades')
                    .insert({
                        user_id: currentUser.id,
                        tea_id: teaId,
                        side: 'SELL',
                        quantity: quantity,
                        price: price,
                        total_value: total
                    });
                if (tradeError) throw tradeError;

                userProfile.cash_balance = newBalance;
                const pnl = (price - position.avg_entry_price) * quantity;
                const pnlText = pnl >= 0 ? `Profit: +$${pnl.toFixed(2)}` : `Loss: -$${Math.abs(pnl).toFixed(2)}`;
                showToast('Position Closed!', `Sold ${quantity.toLocaleString()} kg of ${teaSymbol}. ${pnlText}`);

                // Record to trade history log
                recordClosedTrade({
                    ...position,
                    symbol: teaSymbol,
                    quantity: quantity,
                    type: 'long'
                }, price);

                // Refresh data
                await loadPositions();
                await loadUserTrades();
                updateUIForLoggedInUser();

            } catch (error) {
                console.error('Close position error:', error);
                showToast('Error', error.message, true);
            }
        }

        async function closeIndexPosition(indexSymbol, quantity, tradeId) {
            if (!currentUser) {
                openAuthModal();
                return;
            }

            // Get current index price
            const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
            const index = indexes.find(idx => idx.symbol === indexSymbol);
            if (!index) {
                showToast('Error', 'Index not found', true);
                return;
            }

            // Find the user's index position
            const position = indexPositions[indexSymbol];
            if (!position || position.quantity < quantity) {
                showToast('Error', 'Index position not found or insufficient quantity', true);
                return;
            }

            const price = index.price;
            const total = price * quantity;

            try {
                // Update cash balance
                const newBalance = userProfile.cash_balance + total;
                const { error: balanceError } = await supabaseClient
                    .from('profiles')
                    .update({ cash_balance: newBalance })
                    .eq('id', currentUser.id);
                if (balanceError) throw balanceError;

                // Update or delete index position
                await updateIndexPosition(indexSymbol, quantity, price, 'SELL');

                // Record the closing trade in trades table
                const { error: tradeError } = await supabaseClient
                    .from('trades')
                    .insert({
                        user_id: currentUser.id,
                        tea_id: null,
                        index_symbol: indexSymbol,
                        side: 'SELL',
                        quantity: quantity,
                        price: price,
                        total_value: total
                    });
                if (tradeError) throw tradeError;

                userProfile.cash_balance = newBalance;
                const pnl = (price - position.avg_entry_price) * quantity;
                const pnlText = pnl >= 0 ? `Profit: +$${pnl.toFixed(2)}` : `Loss: -$${Math.abs(pnl).toFixed(2)}`;
                showToast('Position Closed!', `Sold ${quantity.toLocaleString()} kg of ${indexSymbol} Index. ${pnlText}`);

                // Refresh data
                await loadIndexPositions();
                await loadUserTrades();
                updateUIForLoggedInUser();

            } catch (error) {
                console.error('Close index position error:', error);
                showToast('Error', error.message, true);
            }
        }

        async function closePairPosition(tradeId) {
            if (!currentUser) {
                openAuthModal();
                return;
            }

            try {
                // Get the original trade
                const { data: trade, error: fetchError } = await supabaseClient
                    .from('trades')
                    .select('*')
                    .eq('id', tradeId)
                    .single();
                
                if (fetchError) throw fetchError;
                if (!trade || !trade.is_pair_trade) {
                    showToast('Error', 'Pair trade not found', true);
                    return;
                }

                // Find the pair
                const pair = teaPairs.find(p => p.id === trade.pair_id);
                if (!pair) {
                    showToast('Error', 'Pair not found', true);
                    return;
                }

                // Calculate current ratio and P/L
                const teaMap = {};
                teas.forEach(t => teaMap[t.symbol] = t);
                const baseTea = teaMap[pair.base_symbol];
                const quoteTea = teaMap[pair.quote_symbol];

                if (!baseTea || !quoteTea) {
                    showToast('Error', 'Could not get current prices', true);
                    return;
                }

                const currentRatio = baseTea.current_price / quoteTea.current_price;
                const entryRatio = trade.price;
                const ratioChange = (currentRatio - entryRatio) / entryRatio;
                const direction = trade.side === 'BUY' ? 1 : -1; // LONG = BUY, SHORT = SELL
                const leverage = trade.leverage || 1;
                const margin = trade.quantity;
                const pnl = margin * ratioChange * leverage * direction;

                // Return margin + P/L to user
                const returnAmount = margin + pnl;
                const newBalance = userProfile.cash_balance + returnAmount;

                const { error: balanceError } = await supabaseClient
                    .from('profiles')
                    .update({ cash_balance: newBalance })
                    .eq('id', currentUser.id);
                if (balanceError) throw balanceError;

                // Record the closing trade
                const { error: closeError } = await supabaseClient
                    .from('trades')
                    .insert({
                        user_id: currentUser.id,
                        tea_id: trade.tea_id,
                        side: trade.side === 'BUY' ? 'SELL' : 'BUY', // Opposite side to close
                        quantity: margin,
                        price: currentRatio,
                        total_value: returnAmount,
                        pair_id: trade.pair_id,
                        leverage: leverage,
                        is_pair_trade: true
                    });
                if (closeError) throw closeError;

                userProfile.cash_balance = newBalance;

                const baseShort = pair.base_symbol.split('-')[1] || pair.base_symbol;
                const quoteShort = pair.quote_symbol.split('-')[1] || pair.quote_symbol;
                const pnlText = pnl >= 0 ? `Profit: +$${pnl.toFixed(2)}` : `Loss: -$${Math.abs(pnl).toFixed(2)}`;
                const posType = trade.side === 'BUY' ? 'LONG' : 'SHORT';
                
                showToast('Pair Position Closed!', `Closed ${posType} ${baseShort}/${quoteShort} ${leverage}x. ${pnlText}`);

                // Record to trade history log
                recordClosedTrade({
                    symbol: `${baseShort}/${quoteShort}`,
                    type: trade.side === 'BUY' ? 'long' : 'short',
                    quantity: margin,
                    avg_price: entryRatio,
                    created_at: trade.created_at
                }, currentRatio);

                // Refresh data
                await loadUserTrades();
                updateUIForLoggedInUser();

            } catch (error) {
                console.error('Close pair position error:', error);
                showToast('Error', error.message, true);
            }
        }

        // =============================================
        // PORTFOLIO FUNCTIONS
        // =============================================

        async function loadPositions() {
            if (!currentUser) return;

            try {
                const { data, error } = await supabaseClient
                    .from('positions')
                    .select('*, teas(*)')
                    .eq('user_id', currentUser.id);

                if (error) throw error;
                positions = data || [];
                updatePortfolioDisplay();
            } catch (error) {
                console.error('Failed to load positions:', error);
            }
        }

        function updatePortfolioDisplay() {
            const listEl = document.getElementById('positions-list');
            const valueEl = document.getElementById('portfolio-value');
            const pnlEl = document.getElementById('portfolio-pnl');
            
            // Use index positions loaded from Supabase (already in memory)
            const indexPositionsData = indexPositions || {};
            const hasIndexPositions = Object.keys(indexPositionsData).length > 0;

            if (positions.length === 0 && !hasIndexPositions) {
                listEl.innerHTML = `
                    <div style="color: var(--text-muted); font-size: 12px; padding: 20px 0; text-align: center;">
                        No positions yet. Start trading!
                    </div>
                `;
                const totalValue = userProfile?.cash_balance || 10000;
                valueEl.textContent = '$' + totalValue.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                const pnl = totalValue - 10000;
                const pnlPct = (pnl / 10000 * 100).toFixed(2);
                pnlEl.textContent = `${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pnlPct}%)`;
                pnlEl.className = 'portfolio-pnl ' + (pnl >= 0 ? 'up' : 'down');
                return;
            }

            let holdingsValue = 0;
            let html = '';

            // Display tea positions
            positions.forEach(pos => {
                const tea = pos.teas || teas.find(t => t.id === pos.tea_id);
                if (!tea) return;

                const currentValue = pos.quantity * tea.current_price;
                const costBasis = pos.quantity * pos.avg_entry_price;
                const pnl = currentValue - costBasis;
                const pnlPct = (pnl / costBasis * 100).toFixed(1);
                holdingsValue += currentValue;

                html += `
                    <div class="position-item">
                        <div>
                            <div class="position-tea">${tea.symbol}</div>
                            <div class="position-qty">${pos.quantity.toLocaleString()} kg @ $${pos.avg_entry_price.toFixed(2)}</div>
                        </div>
                        <div class="position-value">
                            <div class="position-current">$${currentValue.toFixed(2)}</div>
                            <div class="position-pnl ${pnl >= 0 ? 'up' : 'down'}">${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pnlPct}%)</div>
                        </div>
                    </div>
                `;
            });
            
            // Display index positions
            const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
            Object.entries(indexPositionsData).forEach(([symbol, pos]) => {
                const index = indexes.find(idx => idx.symbol === symbol);
                if (!index || !pos || pos.quantity <= 0) return;
                
                const currentValue = pos.quantity * index.price;
                const costBasis = pos.quantity * pos.avg_entry_price;
                const pnl = currentValue - costBasis;
                const pnlPct = costBasis > 0 ? (pnl / costBasis * 100).toFixed(1) : 0;
                holdingsValue += currentValue;

                html += `
                    <div class="position-item">
                        <div>
                            <div class="position-tea">${symbol} <span style="color: var(--accent-purple); font-size: 10px;">IDX</span></div>
                            <div class="position-qty">${pos.quantity.toLocaleString()} kg @ $${pos.avg_entry_price.toFixed(2)}</div>
                        </div>
                        <div class="position-value">
                            <div class="position-current">$${currentValue.toFixed(2)}</div>
                            <div class="position-pnl ${pnl >= 0 ? 'up' : 'down'}">${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pnlPct}%)</div>
                        </div>
                    </div>
                `;
            });

            listEl.innerHTML = html;

            const totalValue = (userProfile?.cash_balance || 0) + holdingsValue;
            valueEl.textContent = '$' + totalValue.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
            
            const totalPnl = totalValue - 10000;
            const totalPnlPct = (totalPnl / 10000 * 100).toFixed(2);
            pnlEl.textContent = `${totalPnl >= 0 ? '+' : ''}$${totalPnl.toFixed(2)} (${totalPnlPct}%)`;
            pnlEl.className = 'portfolio-pnl ' + (totalPnl >= 0 ? 'up' : 'down');
        }

        // =============================================
        // ORDER HISTORY FUNCTIONS
        // =============================================

        let ordersSortColumn = 'time';
        let ordersSortDirection = 'desc';
        let currentTradesData = [];
        let ordersFilter = 'all'; // 'all' or 'open'

        function setOrdersFilter(filter) {
            ordersFilter = filter;
            // Update button states
            document.getElementById('filter-all').classList.toggle('active', filter === 'all');
            document.getElementById('filter-open').classList.toggle('active', filter === 'open');
            // Re-display with filter
            displayUserTrades(currentTradesData);
        }

        function sortOrdersTable(column) {
            // Toggle direction if same column, otherwise default desc
            if (ordersSortColumn === column) {
                ordersSortDirection = ordersSortDirection === 'desc' ? 'asc' : 'desc';
            } else {
                ordersSortColumn = column;
                ordersSortDirection = 'desc';
            }

            // Update header indicators
            document.querySelectorAll('#orders-table th.sortable').forEach(th => {
                th.classList.remove('asc', 'desc');
                if (th.dataset.sort === column) {
                    th.classList.add(ordersSortDirection);
                }
            });

            // Re-display with new sort
            displayUserTrades(currentTradesData);
        }

        async function loadUserTrades() {
            if (!currentUser) {
                displayUserTrades([]);
                return;
            }

            try {
                const { data, error } = await supabaseClient
                    .from('trades')
                    .select('*')
                    .eq('user_id', currentUser.id)
                    .order('id', { ascending: false })
                    .limit(20);

                if (error) throw error;
                currentTradesData = data || [];
                displayUserTrades(currentTradesData);
            } catch (error) {
                console.error('Failed to load trades:', error);
            }
        }

        function displayUserTrades(trades) {
            const tbody = document.getElementById('orders-tbody');
            const countEl = document.getElementById('order-count');
            
            if (!tbody) return;

            // Separate BUY and SELL trades
            const buyTrades = trades.filter(t => t.side === 'BUY');
            const sellTrades = trades.filter(t => t.side === 'SELL');

            // Match SELL trades to BUY trades (closing trades)
            const closedBuyIds = new Set();
            const closingInfo = {}; // buyTradeId -> { sellPrice, sellTime }

            // For each SELL, find the most recent BUY of the same tea that hasn't been closed
            sellTrades.forEach(sell => {
                const matchingBuy = buyTrades.find(buy => 
                    buy.tea_id === sell.tea_id && 
                    buy.quantity === sell.quantity &&
                    !closedBuyIds.has(buy.id) &&
                    buy.id < sell.id // SELL must come after BUY
                );
                if (matchingBuy) {
                    closedBuyIds.add(matchingBuy.id);
                    closingInfo[matchingBuy.id] = {
                        sellPrice: sell.price,
                        sellTime: sell.created_at
                    };
                }
            });

            // Filter based on current filter setting
            let displayTrades = buyTrades;
            if (ordersFilter === 'open') {
                displayTrades = buyTrades.filter(t => !closedBuyIds.has(t.id));
            }
            countEl.textContent = displayTrades.length;

            if (displayTrades.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" style="text-align: center; color: var(--text-muted); padding: 20px;">
                            ${ordersFilter === 'open' ? 'No open positions.' : 'No orders yet. Start trading!'}
                        </td>
                    </tr>
                `;
                return;
            }

            // Build processed trade data for sorting
            let processedTrades = displayTrades.map(trade => {
                const time = trade.created_at 
                    ? new Date(trade.created_at)
                    : new Date(0);
                const timeStr = trade.created_at 
                    ? time.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })
                    : '--:--';
                const orderId = '#' + String(trade.id).substring(0, 5).toUpperCase();
                const tea = teas.find(t => t.id === trade.tea_id);
                
                const isClosed = closedBuyIds.has(trade.id);
                const closing = closingInfo[trade.id];
                
                // Handle pair trades differently
                const isPairTrade = trade.is_pair_trade || false;
                const leverage = trade.leverage || 1;
                
                // Check if this is an index trade via database column
                const isIndexTrade = !!trade.index_symbol;
                
                let teaSymbol, total, pnl, pnlPct;
                
                if (isPairTrade && trade.pair_id) {
                    // Find the pair
                    const pair = teaPairs.find(p => p.id === trade.pair_id);
                    if (pair) {
                        const baseShort = pair.base_symbol.split('-')[1] || pair.base_symbol;
                        const quoteShort = pair.quote_symbol.split('-')[1] || pair.quote_symbol;
                        teaSymbol = `${baseShort}/${quoteShort} ${leverage}x`;
                        
                        // For pairs: quantity = margin, price = entry ratio
                        total = trade.quantity; // Margin amount
                        const entryRatio = trade.price;
                        
                        // Get current ratio
                        const teaMap = {};
                        teas.forEach(t => teaMap[t.symbol] = t);
                        const baseTea = teaMap[pair.base_symbol];
                        const quoteTea = teaMap[pair.quote_symbol];
                        
                        if (baseTea && quoteTea && quoteTea.current_price > 0) {
                            const currentRatio = baseTea.current_price / quoteTea.current_price;
                            const ratioChange = (currentRatio - entryRatio) / entryRatio;
                            // LONG profits when ratio goes up, SHORT profits when ratio goes down
                            const direction = trade.side === 'BUY' ? 1 : -1;
                            pnl = total * ratioChange * leverage * direction;
                            pnlPct = ratioChange * 100 * leverage * direction;
                        } else {
                            pnl = 0;
                            pnlPct = 0;
                        }
                    } else {
                        teaSymbol = 'PAIR';
                        total = trade.quantity;
                        pnl = 0;
                        pnlPct = 0;
                    }
                } else if (isIndexTrade) {
                    // Index trade - use symbol from database
                    const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
                    const index = indexes.find(idx => idx.symbol === trade.index_symbol);
                    teaSymbol = trade.index_symbol + ' IDX';
                    total = trade.quantity * trade.price;
                    
                    if (index) {
                        pnl = (index.price - trade.price) * trade.quantity;
                        pnlPct = ((index.price - trade.price) / trade.price * 100);
                    } else {
                        pnl = 0;
                        pnlPct = 0;
                    }
                } else {
                    // Regular single tea trade
                    teaSymbol = tea?.symbol || 'Unknown';
                    total = trade.quantity * trade.price;
                    
                    if (isClosed && closing) {
                        pnl = (closing.sellPrice - trade.price) * trade.quantity;
                        pnlPct = ((closing.sellPrice - trade.price) / trade.price * 100);
                    } else if (tea) {
                        pnl = (tea.current_price - trade.price) * trade.quantity;
                        pnlPct = ((tea.current_price - trade.price) / trade.price * 100);
                    } else {
                        pnl = 0;
                        pnlPct = 0;
                    }
                }
                
                const status = isClosed ? 'CLOSED' : 'OPEN';
                
                return {
                    trade,
                    time,
                    timeStr,
                    orderId,
                    tea,
                    teaSymbol,
                    total,
                    isClosed,
                    closing,
                    pnl,
                    pnlPct,
                    status,
                    isPairTrade,
                    isIndexTrade,
                    leverage
                };
            });

            // Sort based on current sort settings
            processedTrades.sort((a, b) => {
                let comparison = 0;
                switch (ordersSortColumn) {
                    case 'time':
                        comparison = a.time.getTime() - b.time.getTime();
                        break;
                    case 'tea':
                        comparison = a.teaSymbol.localeCompare(b.teaSymbol);
                        break;
                    case 'qty':
                        comparison = a.trade.quantity - b.trade.quantity;
                        break;
                    case 'entry':
                        comparison = a.trade.price - b.trade.price;
                        break;
                    case 'total':
                        comparison = a.total - b.total;
                        break;
                    case 'pnl':
                        comparison = a.pnl - b.pnl;
                        break;
                    case 'status':
                        comparison = a.status.localeCompare(b.status);
                        break;
                    default:
                        comparison = a.time.getTime() - b.time.getTime();
                }
                return ordersSortDirection === 'desc' ? -comparison : comparison;
            });

            let html = '';
            let openCount = 0;
            let openTotalValue = 0;
            let openTotalPnl = 0;

            processedTrades.forEach(({ trade, timeStr, orderId, tea, teaSymbol, total, isClosed, pnl, pnlPct, status, isPairTrade, isIndexTrade, leverage }) => {
                const pnlClass = pnl >= 0 ? 'up' : 'down';
                const pnlSign = pnl >= 0 ? '+' : '';
                const statusClass = isClosed ? 'closed' : 'filled';
                
                // Different close action for pairs vs singles vs indexes
                let actionBtn;
                if (isClosed) {
                    actionBtn = `<span style="color: var(--text-muted);">\u2014</span>`;
                } else if (isPairTrade) {
                    actionBtn = `<button class="close-position-btn" onclick="closePairPosition('${trade.id}')">Close</button>`;
                } else if (isIndexTrade) {
                    actionBtn = `<button class="close-position-btn" onclick="closeIndexPosition('${trade.index_symbol}', ${trade.quantity}, ${trade.id})">Close</button>`;
                } else {
                    actionBtn = `<button class="close-position-btn" onclick="closePosition(${trade.tea_id}, ${trade.quantity}, '${teaSymbol}')">Close</button>`;
                }

                if (!isClosed) {
                    openCount++;
                    openTotalValue += total;
                    openTotalPnl += pnl;
                }

                // Different display for pair trades
                let sideLabel, sideClass, entryDisplay, qtyDisplay;
                if (isPairTrade) {
                    const isLong = trade.side === 'BUY';
                    sideLabel = isLong ? 'LONG' : 'SHORT';
                    sideClass = isLong ? 'buy-side' : 'sell-side';
                    entryDisplay = trade.price.toFixed(4); // Ratio with 4 decimals
                    qtyDisplay = '$' + trade.quantity.toLocaleString(); // Margin amount
                } else {
                    sideLabel = 'BUY';
                    sideClass = 'buy-side';
                    entryDisplay = '$' + trade.price.toFixed(2);
                    qtyDisplay = trade.quantity.toLocaleString();
                }

                html += `
                    <tr>
                        <td>${timeStr}</td>
                        <td style="font-family: 'JetBrains Mono', monospace;">${orderId}</td>
                        <td>${teaSymbol}</td>
                        <td><span class="order-side ${sideClass}">${sideLabel}</span></td>
                        <td class="order-qty">${qtyDisplay}</td>
                        <td class="order-price">${entryDisplay}</td>
                        <td class="order-price">$${parseFloat(total.toFixed(2)).toLocaleString()}</td>
                        <td class="${pnlClass}">${pnlSign}$${pnl.toFixed(2)} (${pnlPct.toFixed(1)}%)</td>
                        <td><span class="order-status ${statusClass}">${status}</span></td>
                        <td>${actionBtn}</td>
                    </tr>
                `;
            });

            // Update totals in tfoot
            const tfoot = document.getElementById('orders-tfoot');
            const tfootTotal = document.getElementById('tfoot-total');
            const tfootPnl = document.getElementById('tfoot-pnl');
            const tfootCount = document.getElementById('tfoot-count');

            if (openCount > 0) {
                tfoot.style.display = '';
                const openPnlClass = openTotalPnl >= 0 ? 'up' : 'down';
                const openPnlSign = openTotalPnl >= 0 ? '+' : '';
                const openPnlPct = openTotalValue > 0 ? (openTotalPnl / openTotalValue * 100) : 0;
                
                tfootTotal.textContent = '$' + openTotalValue.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                tfootPnl.innerHTML = `<span class="${openPnlClass}">${openPnlSign}$${openTotalPnl.toFixed(2)} (${openPnlPct.toFixed(1)}%)</span>`;
                tfootCount.innerHTML = `<span style="color: var(--text-muted);">${openCount} open</span>`;
            } else {
                tfoot.style.display = 'none';
            }

            tbody.innerHTML = html;
        }

        // =============================================
        // MARKET DEPTH & MACRO FUNCTIONS
        // =============================================

        let marketDepthBids = 52;
        let tradeHistory = [];

        function updateMarketDepth() {
            // Simulate market depth shifting
            const shift = (Math.random() - 0.5) * 4;
            marketDepthBids = Math.max(35, Math.min(65, marketDepthBids + shift));
            const asks = 100 - marketDepthBids;
            
            const bidsEl = document.getElementById('depth-bids');
            const asksEl = document.getElementById('depth-asks');
            const ratioEl = document.getElementById('depth-ratio');
            
            if (bidsEl && asksEl) {
                bidsEl.style.width = `${marketDepthBids}%`;
                bidsEl.querySelector('.depth-label').textContent = `BIDS ${Math.round(marketDepthBids)}%`;
                asksEl.style.width = `${asks}%`;
                asksEl.querySelector('.depth-label').textContent = `ASKS ${Math.round(asks)}%`;
                
                const ratio = (marketDepthBids / asks).toFixed(2);
                ratioEl.textContent = `Bid/Ask: ${ratio}`;
                
                // Update volumes
                const bidVol = Math.round(8000 + marketDepthBids * 100 + Math.random() * 2000);
                const askVol = Math.round(8000 + asks * 100 + Math.random() * 2000);
                document.getElementById('depth-bid-volume').textContent = `Vol: ${bidVol.toLocaleString()} kg`;
                document.getElementById('depth-ask-volume').textContent = `Vol: ${askVol.toLocaleString()} kg`;
                
                // Update mid price based on selected tea
                const select = document.getElementById('trade-tea-select');
                const selectedTea = teas.find(t => t.symbol === select?.value);
                const midPrice = (selectedTea?.current_price || 4.82).toFixed(2);
                document.getElementById('depth-mid-price').textContent = `Mid: $${midPrice}`;
            }
        }

        function switchWatchlistTab(tab) {
            document.querySelectorAll('.watchlist-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            document.getElementById('watchlist-teas').style.display = tab === 'teas' ? 'block' : 'none';
            document.getElementById('watchlist-macro').style.display = tab === 'macro' ? 'block' : 'none';
        }

        function updateMacroIndicators() {
            // Simulate small changes
            const usdkes = 129.45 + (Math.random() - 0.5) * 0.3;
            const oil = 82.40 + (Math.random() - 0.5) * 0.5;
            const bdi = 1842 + Math.round((Math.random() - 0.5) * 20);
            
            const usdkesEl = document.getElementById('macro-usdkes');
            const oilEl = document.getElementById('macro-oil');
            const bdiEl = document.getElementById('macro-bdi');
            
            if (usdkesEl) usdkesEl.textContent = usdkes.toFixed(2);
            if (oilEl) oilEl.textContent = `$${oil.toFixed(2)}`;
            if (bdiEl) bdiEl.textContent = bdi.toLocaleString();
        }

        function switchPortfolioTab(tab) {
            document.querySelectorAll('.portfolio-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            const positionsEl = document.getElementById('portfolio-positions');
            const historyEl = document.getElementById('portfolio-history');
            
            if (positionsEl && historyEl) {
                positionsEl.classList.toggle('active', tab === 'positions');
                historyEl.classList.toggle('active', tab === 'history');
            }
            
            if (tab === 'history') {
                updateTradeLogDisplay();
            }
        }

        function recordClosedTrade(position, exitPrice) {
            const entryPrice = position.avg_price;
            const pnl = position.type === 'long' 
                ? (exitPrice - entryPrice) * position.quantity
                : (entryPrice - exitPrice) * position.quantity;
            const pnlPercent = ((exitPrice - entryPrice) / entryPrice * 100) * (position.type === 'long' ? 1 : -1);
            
            const now = new Date();
            const entryDate = new Date(position.created_at || now);
            const duration = now - entryDate;
            
            const trade = {
                id: Date.now(),
                symbol: position.teas?.symbol || position.symbol,
                type: position.type,
                quantity: position.quantity,
                entryPrice: entryPrice,
                exitPrice: exitPrice,
                pnl: pnl,
                pnlPercent: pnlPercent,
                duration: duration,
                fees: Math.abs(pnl * 0.002), // 0.2% fee simulation
                closedAt: now
            };
            
            tradeHistory.push(trade);
            localStorage.setItem('tradeHistory', JSON.stringify(tradeHistory));
            updateTradeLogDisplay();
        }

        function formatDuration(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) return `${days}d ${hours % 24}h`;
            if (hours > 0) return `${hours}h ${minutes % 60}m`;
            if (minutes > 0) return `${minutes}m`;
            return `${seconds}s`;
        }

        function updateTradeLogDisplay() {
            const tbody = document.getElementById('trade-log-body');
            const statPnl = document.getElementById('stat-total-pnl');
            const statWinRate = document.getElementById('stat-win-rate');
            const statTrades = document.getElementById('stat-trades');
            const statAvgHold = document.getElementById('stat-avg-hold');
            
            if (!tbody) return;
            
            // Build closed trades from currentTradesData (Supabase)
            const closedTrades = [];
            
            if (currentTradesData && currentTradesData.length > 0) {
                const buyTrades = currentTradesData.filter(t => t.side === 'BUY');
                const sellTrades = currentTradesData.filter(t => t.side === 'SELL');
                const closedBuyIds = new Set();
                
                // Match SELL trades to BUY trades
                sellTrades.forEach(sell => {
                    const matchingBuy = buyTrades.find(buy => 
                        buy.tea_id === sell.tea_id && 
                        !closedBuyIds.has(buy.id) &&
                        buy.id < sell.id
                    );
                    if (matchingBuy) {
                        closedBuyIds.add(matchingBuy.id);
                        
                        // Find tea symbol
                        const tea = teas.find(t => t.id === matchingBuy.tea_id);
                        const symbol = tea?.symbol || 'Unknown';
                        
                        const entryPrice = matchingBuy.price;
                        const exitPrice = sell.price;
                        const quantity = Math.min(matchingBuy.quantity, sell.quantity);
                        const pnl = (exitPrice - entryPrice) * quantity;
                        const pnlPercent = ((exitPrice - entryPrice) / entryPrice) * 100;
                        
                        const entryDate = new Date(matchingBuy.created_at);
                        const exitDate = new Date(sell.created_at);
                        const duration = exitDate - entryDate;
                        
                        closedTrades.push({
                            id: sell.id,
                            symbol: symbol,
                            type: 'long',
                            quantity: quantity,
                            entryPrice: entryPrice,
                            exitPrice: exitPrice,
                            pnl: pnl,
                            pnlPercent: pnlPercent,
                            duration: duration,
                            fees: Math.abs(pnl * 0.002),
                            closedAt: exitDate
                        });
                    }
                });
            }
            
            if (closedTrades.length === 0) {
                tbody.innerHTML = `<tr><td colspan="6" style="text-align: center; color: var(--text-muted); padding: 20px;">No closed trades yet</td></tr>`;
                if (statPnl) statPnl.textContent = '+$0.00';
                if (statWinRate) statWinRate.textContent = '0%';
                if (statTrades) statTrades.textContent = '0';
                if (statAvgHold) statAvgHold.textContent = 'â€”';
                return;
            }
            
            // Calculate stats
            const totalPnl = closedTrades.reduce((sum, t) => sum + t.pnl, 0);
            const wins = closedTrades.filter(t => t.pnl > 0).length;
            const winRate = (wins / closedTrades.length * 100).toFixed(0);
            const avgHold = closedTrades.reduce((sum, t) => sum + t.duration, 0) / closedTrades.length;
            
            statPnl.textContent = `${totalPnl >= 0 ? '+' : ''}$${totalPnl.toFixed(2)}`;
            statPnl.className = `trade-stat-value ${totalPnl >= 0 ? 'up' : 'down'}`;
            statWinRate.textContent = `${winRate}%`;
            statTrades.textContent = closedTrades.length;
            statAvgHold.textContent = formatDuration(avgHold);
            
            // Sort by most recent and render table
            closedTrades.sort((a, b) => b.closedAt - a.closedAt);
            tbody.innerHTML = closedTrades.slice(0, 20).map(t => `
                <tr>
                    <td style="font-weight: 500;">${t.symbol}</td>
                    <td><span class="trade-type-badge ${t.type}">${t.type}</span></td>
                    <td style="font-family: 'JetBrains Mono', monospace;">$${t.entryPrice.toFixed(2)}</td>
                    <td style="font-family: 'JetBrains Mono', monospace;">$${t.exitPrice.toFixed(2)}</td>
                    <td class="${t.pnl >= 0 ? 'up' : 'down'}" style="font-family: 'JetBrains Mono', monospace;">
                        ${t.pnl >= 0 ? '+' : ''}$${t.pnl.toFixed(2)}<br>
                        <span style="font-size: 8px; opacity: 0.7;">${t.pnlPercent >= 0 ? '+' : ''}${t.pnlPercent.toFixed(1)}%</span>
                    </td>
                    <td style="color: var(--text-muted); font-size: 9px;">${formatDuration(t.duration)}</td>
                </tr>
            `).join('');
        }

        // =============================================
        // COMMAND LINE / UNIVERSAL SEARCH
        // =============================================

        const commandAliases = {
            // Commands
            'NEWS': { action: 'scrollTo', target: 'news', desc: 'Jump to News' },
            'CHART': { action: 'scrollTo', target: 'chart', desc: 'Jump to Chart' },
            'ORDERS': { action: 'scrollTo', target: 'orders', desc: 'View Orders' },
            'PORTFOLIO': { action: 'showPortfolio', desc: 'Show Portfolio' },
            'HISTORY': { action: 'showHistory', desc: 'Trade History' },
            'PAIRS': { action: 'showPairs', desc: 'View Tea Pairs' },
            'SINGLES': { action: 'showSingles', desc: 'View Single Teas' },
            'MAX': { action: 'maximizeChart', desc: 'Maximize Chart' },
            'CLEAR': { action: 'clearCommand', desc: 'Clear Input' },
        };

        // Regional Indexes calculated from tea prices
        function calculateRegionalIndexes() {
            if (!teas.length) return [];
            
            const teaMap = {};
            teas.forEach(tea => teaMap[tea.symbol] = tea);
            
            const indexes = [
                { 
                    symbol: 'KENYA', 
                    name: 'Kenya Tea Index',
                    teas: ['KEN-BP1', 'KEN-PF1', 'KEN-DUST'],
                    color: 'var(--accent-green)'
                },
                { 
                    symbol: 'INDIA', 
                    name: 'India Tea Index',
                    teas: ['IND-ASM', 'IND-DRJ'],
                    color: 'var(--accent-orange)'
                },
                { 
                    symbol: 'CEYLON', 
                    name: 'Ceylon Tea Index',
                    teas: ['SRI-BOP', 'SRI-PEK'],
                    color: 'var(--accent-purple)'
                },
                { 
                    symbol: 'CHINA', 
                    name: 'China Tea Index',
                    teas: ['CHN-YUN'],
                    color: 'var(--accent-red)'
                },
                { 
                    symbol: 'AFRICA', 
                    name: 'African Tea Index',
                    teas: ['KEN-BP1', 'KEN-PF1', 'MLW-BP1', 'RWA-OP'],
                    color: 'var(--accent-green)'
                },
                { 
                    symbol: 'ASIA', 
                    name: 'Asian Tea Index',
                    teas: ['IND-ASM', 'IND-DRJ', 'SRI-BOP', 'SRI-PEK', 'CHN-YUN'],
                    color: 'var(--accent-blue)'
                }
            ];
            
            return indexes.map(idx => {
                const prices = idx.teas.map(s => teaMap[s]?.current_price || 0).filter(p => p > 0);
                const prevPrices = idx.teas.map(s => teaMap[s]?.previous_price || 0).filter(p => p > 0);
                
                const avgPrice = prices.length > 0 ? prices.reduce((a, b) => a + b, 0) / prices.length : 0;
                const avgPrevPrice = prevPrices.length > 0 ? prevPrices.reduce((a, b) => a + b, 0) / prevPrices.length : avgPrice;
                const change = avgPrevPrice > 0 ? ((avgPrice - avgPrevPrice) / avgPrevPrice) * 100 : 0;
                
                return {
                    ...idx,
                    price: avgPrice,
                    previousPrice: avgPrevPrice,
                    change: change,
                    isIndex: true
                };
            });
        }

        function initCommandLine() {
            const input = document.getElementById('command-line');
            const suggestions = document.getElementById('command-suggestions');
            
            if (!input) return;

            input.addEventListener('input', (e) => {
                const val = e.target.value.trim();
                const valUpper = val.toUpperCase();
                
                if (val.length === 0) {
                    suggestions.classList.remove('active');
                    return;
                }
                
                let html = '';
                
                // Search teas
                const teaMatches = teas.filter(tea => {
                    const searchStr = `${tea.symbol} ${tea.name || ''} ${tea.grade || ''}`.toUpperCase();
                    return searchStr.includes(valUpper);
                }).slice(0, 4);
                
                if (teaMatches.length > 0) {
                    html += '<div class="search-category">Teas</div>';
                    teaMatches.forEach(tea => {
                        const change = tea.previous_price > 0 ? 
                            ((tea.current_price - tea.previous_price) / tea.previous_price) * 100 : 0;
                        const changeClass = change >= 0 ? 'up' : 'down';
                        const changeStr = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                        const shortSymbol = tea.symbol.split('-')[1] || tea.symbol;
                        const origin = tea.symbol.split('-')[0] || '';
                        
                        html += `
                            <div class="command-suggestion" data-type="tea" data-symbol="${tea.symbol}">
                                <div class="search-result-info">
                                    <span class="search-result-symbol"><span class="origin">${origin}</span> ${shortSymbol}</span>
                                    <span class="search-result-name">${tea.name || tea.symbol}</span>
                                </div>
                                <span class="search-result-price ${changeClass}">$${tea.current_price.toFixed(2)} <small>${changeStr}</small></span>
                                <div class="search-result-actions">
                                    <button class="search-action-btn chart" onclick="event.stopPropagation(); openTeaChart('${tea.symbol}')">Chart</button>
                                    <button class="search-action-btn buy" onclick="event.stopPropagation(); quickTrade('${tea.symbol}', 'BUY')">Buy</button>
                                    <button class="search-action-btn sell" onclick="event.stopPropagation(); quickTrade('${tea.symbol}', 'SELL')">Sell</button>
                                </div>
                            </div>
                        `;
                    });
                }
                
                // Search indexes
                const indexes = calculateRegionalIndexes();
                const indexMatches = indexes.filter(idx => 
                    idx.symbol.includes(valUpper) || idx.name.toUpperCase().includes(valUpper)
                ).slice(0, 3);
                
                if (indexMatches.length > 0) {
                    html += '<div class="search-category">Indexes</div>';
                    indexMatches.forEach(idx => {
                        const changeClass = idx.change >= 0 ? 'up' : 'down';
                        const changeStr = `${idx.change >= 0 ? '+' : ''}${idx.change.toFixed(2)}%`;
                        
                        html += `
                            <div class="command-suggestion" data-type="index" data-symbol="${idx.symbol}">
                                <div class="search-result-info">
                                    <span class="search-result-symbol" style="color: ${idx.color};">${idx.symbol}</span>
                                    <span class="search-result-name">${idx.name}</span>
                                </div>
                                <span class="search-result-price ${changeClass}">$${idx.price.toFixed(2)} <small>${changeStr}</small></span>
                                <div class="search-result-actions">
                                    <button class="search-action-btn chart" onclick="event.stopPropagation(); openIndexChart('${idx.symbol}')">Chart</button>
                                </div>
                            </div>
                        `;
                    });
                }
                
                // Search pairs
                if (teaPairs.length > 0) {
                    const pairMatches = teaPairs.filter(pair => {
                        const pairStr = `${pair.base_symbol}/${pair.quote_symbol}`.toUpperCase();
                        return pairStr.includes(valUpper);
                    }).slice(0, 3);
                    
                    if (pairMatches.length > 0) {
                        html += '<div class="search-category">Pairs</div>';
                        pairMatches.forEach(pair => {
                            const baseShort = pair.base_symbol.split('-')[1] || pair.base_symbol;
                            const quoteShort = pair.quote_symbol.split('-')[1] || pair.quote_symbol;
                            
                            html += `
                                <div class="command-suggestion" data-type="pair" data-id="${pair.id}">
                                    <div class="search-result-info">
                                        <span class="search-result-symbol"><span style="color: var(--accent-green);">${baseShort}</span>/<span style="color: var(--accent-red);">${quoteShort}</span></span>
                                        <span class="search-result-name">Tea Pair</span>
                                    </div>
                                    <div class="search-result-actions">
                                        <button class="search-action-btn buy" onclick="event.stopPropagation(); openPairsModal('${pair.id}', 'LONG')">Long</button>
                                        <button class="search-action-btn sell" onclick="event.stopPropagation(); openPairsModal('${pair.id}', 'SHORT')">Short</button>
                                    </div>
                                </div>
                            `;
                        });
                    }
                }
                
                // Search commands
                const cmdMatches = Object.entries(commandAliases)
                    .filter(([key]) => key.includes(valUpper))
                    .slice(0, 3);
                
                if (cmdMatches.length > 0) {
                    html += '<div class="search-category">Commands</div>';
                    cmdMatches.forEach(([key, data]) => {
                        html += `
                            <div class="command-suggestion" data-type="command" data-cmd="${key}">
                                <span class="command-suggestion-cmd">${key}</span>
                                <span class="command-suggestion-desc">${data.desc}</span>
                            </div>
                        `;
                    });
                }
                
                if (html) {
                    suggestions.innerHTML = html;
                    suggestions.classList.add('active');
                } else {
                    suggestions.innerHTML = '<div class="search-category">No results found</div>';
                    suggestions.classList.add('active');
                }
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const firstResult = suggestions.querySelector('.command-suggestion');
                    if (firstResult) {
                        handleSearchResult(firstResult);
                    }
                    input.value = '';
                    suggestions.classList.remove('active');
                } else if (e.key === 'Escape') {
                    input.value = '';
                    suggestions.classList.remove('active');
                    input.blur();
                }
            });

            // Click on suggestion
            suggestions.addEventListener('click', (e) => {
                const item = e.target.closest('.command-suggestion');
                if (item) {
                    handleSearchResult(item);
                    input.value = '';
                    suggestions.classList.remove('active');
                }
            });
            
            // Close on click outside
            document.addEventListener('click', (e) => {
                const commandWrapper = input.closest('.command-line-wrapper');
                if (commandWrapper && !commandWrapper.contains(e.target)) {
                    suggestions.classList.remove('active');
                }
            });
            
            // Close on blur (after short delay to allow clicks)
            input.addEventListener('blur', () => {
                setTimeout(() => {
                    suggestions.classList.remove('active');
                }, 150);
            });

            // Global keyboard shortcut
            document.addEventListener('keydown', (e) => {
                if (e.key === '/' && !e.ctrlKey && !e.metaKey && document.activeElement !== input) {
                    e.preventDefault();
                    input.focus();
                }
            });
        }
        
        function handleSearchResult(item) {
            const type = item.dataset.type;
            
            switch (type) {
                case 'tea':
                    openTeaChart(item.dataset.symbol);
                    break;
                case 'index':
                    openIndexChart(item.dataset.symbol);
                    break;
                case 'pair':
                    openPairsModal(item.dataset.id, 'LONG');
                    break;
                case 'command':
                    executeCommand(item.dataset.cmd);
                    break;
            }
        }
        
        // Open full chart for a tea (opens modal)
        function openTeaChart(symbol) {
            const tea = teas.find(t => t.symbol === symbol);
            if (!tea) {
                showToast('Tea Not Found', 'Could not find tea data', true);
                return;
            }
            
            // Open the professional chart modal
            openQuickQuoteModal(tea);
        }
        
        // Switch main chart to display a specific tea
        function switchToTea(symbol) {
            const tea = teas.find(t => t.symbol === symbol);
            if (!tea) return;
            
            const shortSymbol = symbol.split('-')[1] || symbol;
            const origin = symbol.split('-')[0] || '';
            const change = tea.previous_price > 0 ? 
                ((tea.current_price - tea.previous_price) / tea.previous_price) * 100 : 0;
            
            // Animate transition
            const chartSection = document.getElementById('chart-section');
            chartSection.style.opacity = '0.7';
            chartSection.style.transform = 'scale(0.98)';
            
            setTimeout(() => {
                // Update main chart data
                mainChartData = {
                    name: tea.name || `${origin} ${shortSymbol}`,
                    symbol: symbol,
                    basePrice: tea.current_price,
                    currency: '$',
                    change: change,
                    volume: '12.5K MT',
                    isTea: true
                };
                
                document.getElementById('main-chart-title').textContent = mainChartData.name;
                const priceEl = document.getElementById('main-chart-price');
                priceEl.textContent = `$${tea.current_price.toFixed(2)}`;
                priceEl.className = 'chart-stat-value ' + (change >= 0 ? 'up' : 'down');
                
                const changeVal = change >= 0 ? '+' : '';
                document.getElementById('main-chart-change').textContent = `${changeVal}${change.toFixed(2)}%`;
                
                // Generate tea historical data and redraw chart
                cachedTimeframe = null;
                chartData = generateTeaHistory(tea);
                drawChart();
                
                // Animate back in
                chartSection.style.opacity = '1';
                chartSection.style.transform = 'scale(1)';
                
                showToast('Chart Updated', `Now viewing ${mainChartData.name}`);
            }, 150);
        }
        
        // Open index chart (switch main chart to show index)
        function openIndexChart(indexSymbol) {
            const indexes = calculateRegionalIndexes();
            const idx = indexes.find(i => i.symbol === indexSymbol);
            
            if (!idx) {
                showToast('Index Not Found', 'Could not find index data', true);
                return;
            }
            
            // Animate transition
            const chartSection = document.getElementById('chart-section');
            chartSection.style.opacity = '0.7';
            chartSection.style.transform = 'scale(0.98)';
            
            setTimeout(() => {
                // Update main chart data
                mainChartData = {
                    name: idx.name,
                    symbol: idx.symbol,
                    basePrice: idx.price,
                    currency: '$',
                    change: idx.change,
                    volume: 'â€”',
                    isIndex: true
                };
                
                document.getElementById('main-chart-title').textContent = mainChartData.name;
                const priceEl = document.getElementById('main-chart-price');
                priceEl.textContent = `$${idx.price.toFixed(2)}`;
                priceEl.className = 'chart-stat-value ' + (idx.change >= 0 ? 'up' : 'down');
                
                const changeVal = idx.change >= 0 ? '+' : '';
                document.getElementById('main-chart-change').textContent = `${changeVal}${idx.change.toFixed(2)}%`;
                
                // Generate index historical data
                cachedTimeframe = null;
                chartData = generateIndexHistoricalData(idx.symbol);
                drawChart();
                
                // Animate back in
                chartSection.style.opacity = '1';
                chartSection.style.transform = 'scale(1)';
                
                showToast('Index Chart', `Now viewing ${idx.name}`);
            }, 150);
            
            document.getElementById('chart-section')?.scrollIntoView({ behavior: 'smooth' });
        }
        
        // Quick trade from search
        function quickTrade(symbol, side) {
            if (!currentUser) {
                showToast('Login Required', 'Please sign in to trade', true);
                openAuthModal();
                return;
            }
            
            const tea = teas.find(t => t.symbol === symbol);
            if (!tea) return;
            
            // Set the trade panel to this tea (use tea.id as that's what the select uses)
            const teaSelect = document.getElementById('trade-tea-select');
            if (teaSelect) {
                teaSelect.value = tea.id;
            }
            
            // Set the trade type
            setTradeType(side);
            
            // Update summary
            updateTradeSummary();
            
            // Scroll to trade panel
            document.querySelector('.trade-panel')?.scrollIntoView({ behavior: 'smooth' });
            
            showToast('Trade Ready', `${side} ${tea.name || symbol}`);
        }

        function executeCommand(cmd) {
            const parts = cmd.toUpperCase().trim().split(' ');
            const command = parts[0];
            const arg = parts[1];

            // Check for BUY/SELL
            if (command === 'BUY' || command === 'SELL') {
                const qty = parseInt(arg) || 100;
                const selectedTea = document.getElementById('trade-tea-select')?.value;
                if (selectedTea) {
                    document.getElementById('trade-qty').value = qty;
                    if (command === 'BUY') {
                        setTradeType('BUY');
                    } else {
                        setTradeType('SELL');
                    }
                    updateTradeSummary();
                    showToast('Trade Ready', `${command} ${qty} kg of ${selectedTea}`);
                } else {
                    showToast('Select a tea first', 'Click on a tea in Quick Quotes', true);
                }
                return;
            }

            // Check command aliases
            const alias = commandAliases[command];
            if (alias) {
                switch (alias.action) {
                    case 'selectTea':
                        const tea = teas.find(t => t.symbol === alias.symbol);
                        if (tea) {
                            selectTeaForTrading(tea.symbol);
                            showToast('Selected', alias.desc);
                        }
                        break;
                    case 'scrollTo':
                        if (alias.target === 'chart') {
                            document.getElementById('chart-section')?.scrollIntoView({ behavior: 'smooth' });
                        } else if (alias.target === 'orders') {
                            document.getElementById('orders-section')?.scrollIntoView({ behavior: 'smooth' });
                        }
                        break;
                    case 'showPortfolio':
                        document.getElementById('portfolio-section').style.display = 'block';
                        switchPortfolioTab('positions');
                        break;
                    case 'showHistory':
                        document.getElementById('portfolio-section').style.display = 'block';
                        switchPortfolioTab('history');
                        break;
                    case 'showMacro':
                        switchWatchlistTab('macro');
                        break;
                    case 'setTradeType':
                        setTradeType(alias.type);
                        break;
                    case 'maximizeChart':
                        toggleMaximize('chart-section');
                        break;
                    case 'clearCommand':
                        break;
                }
            } else {
                // Try to find tea by searching
                const foundTea = teas.find(t => 
                    t.symbol.toUpperCase().includes(command) || 
                    t.name.toUpperCase().includes(command)
                );
                if (foundTea) {
                    selectTeaForTrading(foundTea.symbol);
                    showToast('Selected', foundTea.name);
                }
            }
        }

        // =============================================
        // MOBILE MENU FUNCTIONS
        // =============================================
        
        function toggleMobileMenu() {
            const sidebar = document.getElementById('mobile-sidebar');
            const overlay = document.getElementById('mobile-overlay');
            
            if (sidebar.classList.contains('mobile-open')) {
                closeMobileMenu();
            } else {
                sidebar.classList.add('mobile-open');
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }
        
        function closeMobileMenu() {
            const sidebar = document.getElementById('mobile-sidebar');
            const overlay = document.getElementById('mobile-overlay');
            
            sidebar.classList.remove('mobile-open');
            overlay.classList.remove('active');
            document.body.style.overflow = '';
        }
        
        // Close mobile menu on window resize to desktop
        window.addEventListener('resize', () => {
            if (window.innerWidth > 1200) {
                closeMobileMenu();
            }
            
            // Auto-scale for very small screens
            adjustViewportScale();
        });
        
        // Auto-scale the page for screens smaller than minimum designed width
        function adjustViewportScale() {
            const minDesignedWidth = 1200; // Minimum width the design works well at
            const viewportWidth = window.innerWidth;
            
            // For screens wider than design width, no scaling
            if (viewportWidth >= minDesignedWidth) {
                document.body.style.transform = '';
                document.body.style.transformOrigin = '';
                document.body.style.width = '';
                return;
            }
            
            // For mobile breakpoint, let CSS handle it
            if (viewportWidth <= 768) {
                document.body.style.transform = '';
                document.body.style.transformOrigin = '';
                document.body.style.width = '';
                return;
            }
            
            // Scale down for intermediate screens (768px to 1200px)
            // This allows the full layout to be visible on smaller laptops
            const scale = viewportWidth / minDesignedWidth;
            const adjustedScale = Math.max(0.7, scale); // Don't scale below 70%
            
            // Only apply transform scaling if explicitly enabled (can be toggled)
            // By default, let CSS media queries handle it
        }
        
        // Run on page load
        adjustViewportScale();

        // =============================================
        // LIVE CHAT SYSTEM
        // =============================================
        
        let chatMessages = [];
        let chatSubscription = null;
        let onlineUsers = new Set();
        let unreadChatCount = 0;
        
        // Check if chat section is visible in viewport
        function isChatVisible() {
            const chatSection = document.getElementById('chat-section-sidebar');
            if (!chatSection) return false;
            
            const rect = chatSection.getBoundingClientRect();
            const windowHeight = window.innerHeight || document.documentElement.clientHeight;
            const windowWidth = window.innerWidth || document.documentElement.clientWidth;
            
            // Check if element is visible (at least partially)
            return (
                rect.top < windowHeight &&
                rect.bottom > 0 &&
                rect.left < windowWidth &&
                rect.right > 0 &&
                chatSection.offsetParent !== null // Check if not hidden by display:none
            );
        }
        
        // Show/hide chat notification badge
        function updateChatNotificationBadge() {
            const badge = document.getElementById('chat-notification-badge');
            const countEl = document.getElementById('chat-notification-count');
            if (!badge || !countEl) return;
            
            if (unreadChatCount > 0) {
                badge.classList.add('visible');
                countEl.textContent = unreadChatCount > 99 ? '99+' : unreadChatCount;
            } else {
                badge.classList.remove('visible');
            }
        }
        
        // Clear unread count when chat is viewed
        function clearChatNotifications() {
            unreadChatCount = 0;
            updateChatNotificationBadge();
        }
        
        // Scroll to chat section and clear notifications
        function scrollToChatSection() {
            const chatSection = document.getElementById('chat-section-sidebar');
            if (chatSection) {
                // If on mobile, open sidebar first
                if (window.innerWidth <= 1200) {
                    openMobileMenu();
                    setTimeout(() => {
                        chatSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 300);
                } else {
                    chatSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
            clearChatNotifications();
        }
        
        // Initialize chat system
        async function initChat() {
            await loadChatMessages();
            setupChatSubscription();
            setupChatInputListeners();
            updateOnlineCount();
            
            // Simulate some users being online
            setInterval(updateOnlineCount, 30000);
            
            // Set up intersection observer to clear notifications when chat is visible
            const chatSection = document.getElementById('chat-section-sidebar');
            if (chatSection && 'IntersectionObserver' in window) {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && unreadChatCount > 0) {
                            clearChatNotifications();
                        }
                    });
                }, { threshold: 0.3 }); // 30% visible triggers clear
                observer.observe(chatSection);
            }
            
            // Demo: simulate incoming messages periodically
            simulateDemoMessages();
        }
        
        // Simulate demo incoming messages for notification demo
        function simulateDemoMessages() {
            const demoMessages = [
                { sender: 'TRADER_KE', message: 'Looking for premium Assam, any availability?' },
                { sender: 'CEYLON_PRO', message: 'Just got fresh lots from Nuwara Eliya estate.' },
                { sender: 'TEA_MASTER', message: 'Price alert: Kenya BP1 trending up.' },
                { sender: 'AUCTION_BOT', message: 'New auction starting in 10 minutes.' },
                { sender: 'MOMBASA_TEA', message: 'Can anyone confirm current Mombasa rates?' }
            ];
            
            // Send a demo message every 45-90 seconds if not viewing chat
            setInterval(() => {
                if (!isChatVisible() && Math.random() > 0.5) {
                    const demo = demoMessages[Math.floor(Math.random() * demoMessages.length)];
                    const newMsg = {
                        id: Date.now(),
                        sender_email: 'demo@teatrade.exchange',
                        sender_name: demo.sender,
                        message: demo.message,
                        created_at: new Date().toISOString(),
                        is_private: false
                    };
                    chatMessages.push(newMsg);
                    renderChatMessages();
                    unreadChatCount++;
                    updateChatNotificationBadge();
                }
            }, 60000); // Check every 60 seconds
        }
        
        // Load recent chat messages
        async function loadChatMessages() {
            try {
                const { data, error } = await supabaseClient
                    .from('chat_messages')
                    .select('*')
                    .order('created_at', { ascending: true })
                    .limit(50);
                
                if (error) {
                    // Table might not exist yet - show demo messages
                    console.log('Chat table not found, using demo messages');
                    loadDemoChatMessages();
                    return;
                }
                
                chatMessages = data || [];
                renderChatMessages();
            } catch (err) {
                console.error('Error loading chat:', err);
                loadDemoChatMessages();
            }
        }
        
        // Load demo messages for when the table doesn't exist
        function loadDemoChatMessages() {
            const now = new Date();
            chatMessages = [
                { id: 1, sender_email: 'k.muthoni@ktda.co.ke', sender_name: 'TEALEAF_KE', message: 'New lots arriving from Kericho highlands tomorrow. Premium quality expected.', created_at: new Date(now - 35 * 60000).toISOString(), is_private: false },
                { id: 2, sender_email: 'm.wong@ekaterra.com', sender_name: 'WONG_TRADER', message: 'Any visibility on Ceylon OP availability next week?', created_at: new Date(now - 22 * 60000).toISOString(), is_private: false },
                { id: 3, sender_email: 'system', sender_name: 'SYSTEM', message: 'Trade alert: Lot #24608 has been matched.', created_at: new Date(now - 15 * 60000).toISOString(), is_private: false, is_system: true },
                { id: 4, sender_email: 'r.patel@tata.com', sender_name: 'PATEL_TEA', message: 'Can offer 10MT Kenya BP1 at 3.45. Interested?', created_at: new Date(now - 8 * 60000).toISOString(), is_private: true, recipient_email: 'demo@user.com', recipient_name: 'DEMO_USER' },
                { id: 5, sender_email: 'j.harrison@finlays.com', sender_name: 'FINLAY_JH', message: 'Looking for 20MT BP1 Mombasa. Can you source?', created_at: new Date(now - 2 * 60000).toISOString(), is_private: false }
            ];
            renderChatMessages();
        }
        
        // Set up real-time subscription
        function setupChatSubscription() {
            chatSubscription = supabaseClient
                .channel('chat_messages')
                .on('postgres_changes', 
                    { event: 'INSERT', schema: 'public', table: 'chat_messages' },
                    (payload) => {
                        const newMessage = payload.new;
                        // Check if it's a private message for someone else
                        if (newMessage.is_private && newMessage.recipient_email !== currentUser?.email && newMessage.sender_email !== currentUser?.email) {
                            return; // Don't show private messages not meant for us
                        }
                        chatMessages.push(newMessage);
                        renderChatMessages();
                        
                        // Show notification if chat is not visible and it's not our own message
                        if (!isChatVisible() && newMessage.sender_email !== currentUser?.email) {
                            unreadChatCount++;
                            updateChatNotificationBadge();
                        }
                    }
                )
                .subscribe();
        }
        
        // Render chat messages
        function renderChatMessages() {
            const container = document.getElementById('chat-messages');
            if (!container) return;
            
            const currentEmail = currentUser?.email || '';
            
            container.innerHTML = chatMessages.map(msg => {
                const isOwn = msg.sender_email === currentEmail;
                const isPrivate = msg.is_private;
                const isSystem = msg.is_system || msg.sender_name === 'SYSTEM';
                
                let msgClass = 'chat-message';
                if (isOwn) msgClass += ' own';
                if (isPrivate) msgClass += ' private';
                
                let senderClass = 'chat-sender';
                if (isSystem) senderClass += ' system';
                
                const time = formatChatTime(msg.created_at);
                const senderDisplay = isOwn ? 'YOU' : (msg.sender_name || 'ANON').toUpperCase();
                
                let recipientTag = '';
                if (isPrivate && msg.recipient_email) {
                    // Use recipient_name if available, otherwise extract handle (not email)
                    const recipientName = (msg.recipient_name || msg.recipient_email.split('@')[0]).toUpperCase();
                    recipientTag = `<span class="chat-sender dm-target">@${recipientName}</span>`;
                }
                
                return `
                    <div class="${msgClass}">
                        <div class="chat-message-header">
                            <span class="${senderClass}">${senderDisplay}${recipientTag}</span>
                            <span class="chat-time">${time}</span>
                        </div>
                        <div class="chat-text">${escapeHtml(msg.message)}</div>
                    </div>
                `;
            }).join('');
            
            // Scroll to bottom
            container.scrollTop = container.scrollHeight;
        }
        
        // Format chat timestamp
        function formatChatTime(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            
            if (diffMins < 1) return 'now';
            if (diffMins < 60) return `${diffMins}m ago`;
            
            // Show time if today
            if (date.toDateString() === now.toDateString()) {
                return date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
            }
            
            // Show date if older
            return date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Set up input listeners
        function setupChatInputListeners() {
            const input = document.getElementById('chat-input');
            if (!input) return;
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendChatMessage();
                }
            });
        }
        
        // Send a chat message
        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            if (!input) return;
            
            const message = input.value.trim();
            if (!message) return;
            
            // Check if user is logged in
            if (!currentUser) {
                showToast('Login Required', 'Please log in to send messages');
                openAuthModal();
                return;
            }
            
            // Parse for @username (private message) - more flexible regex
            let isPrivate = false;
            let recipientEmail = null;
            let actualMessage = message;
            
            // Match @username followed by optional message
            const dmMatch = message.match(/^@(\S+)(?:\s+(.*))?$/);
            if (dmMatch) {
                const recipientHandle = dmMatch[1].toLowerCase();
                const dmMessage = dmMatch[2]?.trim();
                
                if (!dmMessage) {
                    // Just @username with no message - prompt user
                    showToast('DM Format', 'Use: @username your message');
                    return;
                }
                
                isPrivate = true;
                actualMessage = dmMessage;
                
                // Try to find recipient (for demo, just use the handle as email prefix)
                recipientEmail = recipientHandle.includes('@') ? recipientHandle : `${recipientHandle}@teatrade.exchange`;
            }
            
            // Clear input immediately for responsiveness
            input.value = '';
            
            // Get sender username (not email for privacy)
            const senderUsername = (userProfile?.username || 'trader').toUpperCase();
            
            try {
                const { error } = await supabaseClient
                    .from('chat_messages')
                    .insert({
                        sender_email: currentUser.email,
                        sender_name: senderUsername,
                        message: actualMessage,
                        is_private: isPrivate,
                        recipient_email: recipientEmail
                    });
                
                if (error) {
                    // Table might not exist - add locally for demo
                    console.log('Chat insert error (table may not exist), adding locally');
                    addLocalChatMessage(senderUsername, actualMessage, isPrivate, recipientEmail);
                }
            } catch (err) {
                console.error('Error sending message:', err);
                addLocalChatMessage(senderUsername, actualMessage, isPrivate, recipientEmail);
            }
        }
        
        // Add message locally (for demo/offline mode)
        function addLocalChatMessage(senderName, message, isPrivate, recipientEmail) {
            const newMsg = {
                id: Date.now(),
                sender_email: currentUser?.email || 'demo@user.com',
                sender_name: senderName,
                message: message,
                created_at: new Date().toISOString(),
                is_private: isPrivate,
                recipient_email: recipientEmail
            };
            chatMessages.push(newMsg);
            renderChatMessages();
        }
        
        // Send a blast message (highlighted)
        function sendBlastMessage() {
            const input = document.getElementById('chat-input');
            if (!input) return;
            
            const message = input.value.trim();
            if (!message) {
                showToast('Empty Message', 'Type a message to blast');
                return;
            }
            
            if (!currentUser) {
                showToast('Login Required', 'Please log in to send blasts');
                openAuthModal();
                return;
            }
            
            // Blast is just a highlighted global message
            input.value = `ðŸ”¥ BLAST: ${message}`;
            sendChatMessage();
        }
        
        // Update online user count
        function updateOnlineCount() {
            const countEl = document.getElementById('chat-online-count');
            if (!countEl) return;
            
            // Simulate random online count (2-8)
            const count = 2 + Math.floor(Math.random() * 7);
            countEl.textContent = `${count} online`;
        }
        
        // Initialize chat when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initChat, 1000); // Delay to let auth initialize first
        });

        // =============================================
        // MAXIMIZE FUNCTIONS
        // =============================================

        let maximizedPanel = null;
        let hubChartData = [];
        let hubRsiHeight = 120;
        let hubStudies = { sma10: false, sma20: false, bollinger: false, rsi: false };
        let hubChartType = 'line';
        let hubTimeframe = '1W';
        let tradingHubChart = null;
        let isResizingRsi = false;

        function toggleMaximize(panelId) {
            const panel = document.getElementById(panelId);
            if (!panel) return;

            if (panel.classList.contains('panel-maximized')) {
                // Restore
                panel.classList.remove('panel-maximized');
                document.body.classList.remove('modal-open');
                document.body.style.overflow = '';
                maximizedPanel = null;
            } else {
                // Maximize
                if (maximizedPanel) {
                    maximizedPanel.classList.remove('panel-maximized');
                }
                panel.classList.add('panel-maximized');
                document.body.classList.add('modal-open');
                document.body.style.overflow = 'hidden';
                maximizedPanel = panel;
                
                // Initialize trading hub
                if (panelId === 'chart-section') {
                    initTradingHub();
                }
            }

            // Trigger resize for chart redraw with increased delays for layout computation
            setTimeout(() => {
                window.dispatchEvent(new Event('resize'));
                drawChart();
            }, 100);
            
            if (panelId === 'chart-section' && panel.classList.contains('panel-maximized')) {
                // Multiple redraws to ensure canvas is properly sized after layout
                setTimeout(drawHubChart, 150);
                setTimeout(drawHubChart, 300);
                setTimeout(drawHubChart, 500);
            }
        }
        
        // =============================================
        // TRADING HUB FUNCTIONS
        // =============================================
        
        function initTradingHub() {
            // Load index positions from localStorage
            if (typeof loadIndexPositions === 'function') {
                loadIndexPositions();
            }
            
            // Pre-populate with current chart symbol (keep indexes as-is, they are tradable)
            let currentSymbol = mainChartData?.symbol || '';
            
            // Normalize KENYAN to KENYA for consistency
            if (currentSymbol === 'KENYAN') currentSymbol = 'KENYA';
            
            const buySelect = document.getElementById('hub-buy-symbol');
            const sellSelect = document.getElementById('hub-sell-symbol');
            
            // Ensure selects are populated first
            populateHubTeaSelects();
            
            // Set selects to current symbol - try exact match first, then fallback
            if (buySelect && buySelect.options.length > 0) {
                let matched = false;
                for (let opt of buySelect.options) {
                    if (opt.value === currentSymbol) {
                        buySelect.value = currentSymbol;
                        matched = true;
                        break;
                    }
                }
                // If no match, default to first tea option (skip optgroup)
                if (!matched) {
                    for (let opt of buySelect.options) {
                        if (opt.value) {
                            buySelect.value = opt.value;
                            break;
                        }
                    }
                }
            }
            if (sellSelect && sellSelect.options.length > 0) {
                let matched = false;
                for (let opt of sellSelect.options) {
                    if (opt.value === currentSymbol) {
                        sellSelect.value = currentSymbol;
                        matched = true;
                        break;
                    }
                }
                if (!matched) {
                    for (let opt of sellSelect.options) {
                        if (opt.value) {
                            sellSelect.value = opt.value;
                            break;
                        }
                    }
                }
            }
            
            // Use main chart data if available, otherwise generate
            if (chartData && chartData.length > 0) {
                hubChartData = [...chartData];
            } else {
                hubChartData = generateHubChartData();
            }
            
            // Update hub title to match main chart
            const hubTitle = document.getElementById('hub-chart-title');
            if (hubTitle && mainChartData?.name) {
                hubTitle.textContent = mainChartData.name;
            }
            
            // Sync studies and settings (use defaults if not set)
            hubStudies = { sma10: false, sma20: false, bollinger: false, rsi: false };
            hubChartType = chartType || 'line';
            hubTimeframe = currentTimeframe || '1W';
            
            // Update hub UI to match main chart
            updateHubStudyToggles();
            document.getElementById('hub-timeframe-label').textContent = hubTimeframe;
            
            // Update hub chart type buttons
            document.getElementById('hub-btn-line')?.classList.toggle('active', hubChartType === 'line');
            document.getElementById('hub-btn-candle')?.classList.toggle('active', hubChartType === 'candle');
            
            // Update price display
            updateHubPriceDisplay();
            
            // Update position info
            updateHubPositionInfo();
            
            // Initialize RSI section visibility
            const rsiSection = document.getElementById('hub-rsi-section');
            if (hubStudies.rsi) {
                rsiSection.classList.add('visible');
            } else {
                rsiSection.classList.remove('visible');
            }
            
            // Setup RSI resize handle
            setupRsiResizer();
            
            // Start trade log simulation
            startTradeLogSimulation();
            
            // Force canvas wrapper to have explicit dimensions
            const canvasWrapper = document.getElementById('hub-canvas-wrapper');
            const chartArea = document.querySelector('.trading-hub-chart-area');
            if (canvasWrapper && chartArea) {
                // Force a reflow by reading dimensions
                void chartArea.offsetHeight;
                void canvasWrapper.offsetHeight;
                
                // Calculate available height for the chart
                const viewportHeight = window.innerHeight;
                const logHeight = 160; // Trade log + RSI section
                const padding = 100; // Header + paddings
                const availableHeight = viewportHeight - logHeight - padding;
                
                // Set explicit dimensions
                canvasWrapper.style.height = Math.max(300, availableHeight) + 'px';
                canvasWrapper.style.width = '100%';
            }
            
            // Setup resize observer for the chart canvas
            if (canvasWrapper && typeof ResizeObserver !== 'undefined') {
                const resizeObserver = new ResizeObserver(() => {
                    if (maximizedPanel?.classList.contains('panel-maximized')) {
                        requestAnimationFrame(drawHubChart);
                    }
                });
                resizeObserver.observe(canvasWrapper);
            }
            
            // Draw hub chart with multiple attempts for layout using requestAnimationFrame
            requestAnimationFrame(() => {
                drawHubChart();
                setTimeout(drawHubChart, 100);
                setTimeout(drawHubChart, 300);
                setTimeout(drawHubChart, 600);
                setTimeout(drawHubChart, 1000);
            });
            
            // Setup hub chart crosshair and tooltip events
            setupHubChartCrosshair();
        }
        
        // Hub chart crosshair event handlers
        function setupHubChartCrosshair() {
            const canvas = document.getElementById('hubPriceChart');
            const wrapper = document.getElementById('hub-canvas-wrapper');
            const crosshair = document.getElementById('hub-crosshair');
            const tooltip = document.getElementById('hub-tooltip');
            
            if (!canvas || !wrapper || !crosshair || !tooltip) return;
            
            // Remove old listeners if any (prevent duplicates)
            canvas.removeEventListener('mousemove', hubChartMouseMove);
            canvas.removeEventListener('mouseleave', hubChartMouseLeave);
            wrapper.removeEventListener('mouseleave', hubChartMouseLeave);
            
            // Add event listeners
            canvas.addEventListener('mousemove', hubChartMouseMove);
            canvas.addEventListener('mouseleave', hubChartMouseLeave);
            wrapper.addEventListener('mouseleave', hubChartMouseLeave);
        }
        
        function hubChartMouseMove(e) {
            const canvas = document.getElementById('hubPriceChart');
            const crosshair = document.getElementById('hub-crosshair');
            const tooltip = document.getElementById('hub-tooltip');
            const meta = window.hubChartMeta;
            
            if (!canvas || !crosshair || !tooltip || !meta || !meta.data || meta.data.length === 0) {
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const { padding, chartWidth, chartHeight, width, height, minPrice, maxPrice } = meta;
            
            // Check if mouse is in chart area
            if (x < padding.left || x > width - padding.right || 
                y < padding.top || y > padding.top + chartHeight) {
                crosshair.style.display = 'none';
                tooltip.classList.remove('visible');
                return;
            }
            
            // Find data point
            const relX = x - padding.left;
            const index = Math.round((relX / chartWidth) * (meta.data.length - 1));
            const dataPoint = meta.data[Math.max(0, Math.min(index, meta.data.length - 1))];
            
            if (!dataPoint) return;
            
            // Show crosshair
            crosshair.style.display = 'block';
            crosshair.querySelector('.hub-crosshair-v').style.left = x + 'px';
            crosshair.querySelector('.hub-crosshair-h').style.top = y + 'px';
            
            // Format date
            const date = dataPoint.date instanceof Date ? dataPoint.date : new Date(dataPoint.date);
            const dateStr = date.toLocaleDateString('en-GB', { 
                weekday: 'short', day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' 
            });
            
            // Calculate change
            const change = dataPoint.change || ((dataPoint.close - dataPoint.open) / dataPoint.open * 100);
            const changeClass = change >= 0 ? 'up' : 'down';
            const changeSign = change >= 0 ? '+' : '';
            
            // Build tooltip content
            tooltip.innerHTML = `
                <div class="hub-tooltip-date">${dateStr}</div>
                <div class="hub-tooltip-row">
                    <span class="hub-tooltip-label">Open</span>
                    <span class="hub-tooltip-value">$${dataPoint.open.toFixed(3)}</span>
                </div>
                <div class="hub-tooltip-row">
                    <span class="hub-tooltip-label">High</span>
                    <span class="hub-tooltip-value up">$${dataPoint.high.toFixed(3)}</span>
                </div>
                <div class="hub-tooltip-row">
                    <span class="hub-tooltip-label">Low</span>
                    <span class="hub-tooltip-value down">$${dataPoint.low.toFixed(3)}</span>
                </div>
                <div class="hub-tooltip-row">
                    <span class="hub-tooltip-label">Close</span>
                    <span class="hub-tooltip-value">$${dataPoint.close.toFixed(3)}</span>
                </div>
                <div class="hub-tooltip-row">
                    <span class="hub-tooltip-label">Change</span>
                    <span class="hub-tooltip-value ${changeClass}">${changeSign}${change.toFixed(2)}%</span>
                </div>
                <div class="hub-tooltip-row">
                    <span class="hub-tooltip-label">Volume</span>
                    <span class="hub-tooltip-value">${formatVolume(dataPoint.volume || 0)} kg</span>
                </div>
            `;
            
            // Position tooltip
            let tooltipX = x + 15;
            let tooltipY = y - 10;
            
            // Keep tooltip in bounds
            if (tooltipX + 190 > width) tooltipX = x - 185;
            if (tooltipY + 180 > height) tooltipY = y - 170;
            if (tooltipY < 10) tooltipY = 10;
            
            tooltip.style.left = tooltipX + 'px';
            tooltip.style.top = tooltipY + 'px';
            tooltip.classList.add('visible');
        }
        
        function hubChartMouseLeave() {
            const crosshair = document.getElementById('hub-crosshair');
            const tooltip = document.getElementById('hub-tooltip');
            
            if (crosshair) crosshair.style.display = 'none';
            if (tooltip) tooltip.classList.remove('visible');
        }
        
        // Hub chart uses the UNIFIED PRICE CACHE for consistency with all other charts
        let currentHubSymbol = null;
        
        async function loadOrGenerateHubChartData(symbol) {
            // Hub chart uses unified price cache for consistency
            const indexSymbols = ['KENYA', 'KENYAN', 'INDIA', 'CEYLON', 'CHINA', 'JAPAN', 'AFRICA', 'ASIA'];
            const lookupSymbol = symbol === 'KENYAN' ? 'KENYA' : symbol;
            const isIndex = indexSymbols.includes(symbol);
            const symbolType = isIndex ? 'index' : 'tea';
            
            // Get from unified cache (which loads from DB first)
            const data = await getPriceHistory(lookupSymbol, symbolType);
            return data;
        }
        
        function generateInitialChartData(symbol) {
            // Uses unified cache sync version
            const indexSymbols = ['KENYA', 'KENYAN', 'INDIA', 'CEYLON', 'CHINA', 'JAPAN', 'AFRICA', 'ASIA'];
            const lookupSymbol = symbol === 'KENYAN' ? 'KENYA' : symbol;
            const isIndex = indexSymbols.includes(symbol);
            const symbolType = isIndex ? 'index' : 'tea';
            
            // Get from unified cache (sync version for immediate rendering)
            let data = getPriceHistorySync(lookupSymbol, symbolType);
            
            // Fallback to generation if cache is empty
            if (!data || data.length === 0) {
                let currentPrice;
                if (isIndex) {
                    const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
                    const index = indexes.find(idx => idx.symbol === lookupSymbol);
                    currentPrice = index?.price || 3.50;
                } else {
                    const tea = teas?.find(t => t.symbol === symbol);
                    currentPrice = tea?.current_price || 3.50;
                }
                
                // Generate initial chart data (only done once per symbol until DB has history)
                data = [];
                let price = currentPrice;
                const now = Date.now();
                const dayMs = 24 * 60 * 60 * 1000;
                
                // Use a seeded random based on symbol to ensure consistency
                const seed = symbol.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
                const seededRandom = (i) => {
                    const x = Math.sin(seed + i * 9999) * 10000;
                    return x - Math.floor(x);
                };
                
                for (let i = 100; i >= 0; i--) {
                    const volatility = 0.02;
                    const change = (seededRandom(i) - 0.5) * volatility;
                    price = price * (1 + change);
                    price = Math.max(currentPrice * 0.7, Math.min(currentPrice * 1.3, price));
                    
                    const open = price;
                    const high = price * (1 + seededRandom(i + 1000) * 0.01);
                    const low = price * (1 - seededRandom(i + 2000) * 0.01);
                    const close = i === 0 ? currentPrice : low + seededRandom(i + 3000) * (high - low);
                    
                    data.push({
                        date: new Date(now - (i * dayMs)),
                        open: open,
                        high: high,
                        low: low,
                        close: close,
                        volume: Math.floor(seededRandom(i + 4000) * 100000) + 10000
                    });
                    
                    price = close;
                }
                
                // Store in unified cache for consistency
                const cacheKey = symbolType === 'index' ? `INDEX_${lookupSymbol}` : lookupSymbol;
                priceDataCache.data[cacheKey] = data;
                priceDataCache.lastUpdate[cacheKey] = Date.now();
            }
            
            return data;
        }
        
        // Synchronous fallback for legacy callers - uses unified price cache
        function generateHubChartData() {
            const symbol = document.getElementById('hub-buy-symbol')?.value || 'KENYA';
            
            // Use unified cache sync version (this returns data from DB-first cache)
            const indexSymbols = ['KENYA', 'KENYAN', 'INDIA', 'CEYLON', 'CHINA', 'JAPAN', 'AFRICA', 'ASIA'];
            const lookupSymbol = symbol === 'KENYAN' ? 'KENYA' : symbol;
            const isIndex = indexSymbols.includes(symbol);
            const symbolType = isIndex ? 'index' : 'tea';
            
            let data = getPriceHistorySync(lookupSymbol, symbolType);
            
            // If no cached data, generate initial data
            if (!data || data.length === 0) {
                data = generateInitialChartData(symbol);
            }
            
            return data;
        }
        
        function updateHubPriceDisplay() {
            if (!hubChartData || hubChartData.length === 0) return;
            
            const lastPrice = hubChartData[hubChartData.length - 1].close;
            const firstPrice = hubChartData[0].close;
            const change = ((lastPrice - firstPrice) / firstPrice) * 100;
            
            const priceEl = document.getElementById('hub-chart-price');
            const changeEl = document.getElementById('hub-chart-change');
            
            if (priceEl) {
                priceEl.textContent = `$${lastPrice.toFixed(2)}`;
                priceEl.className = 'trading-hub-price ' + (change >= 0 ? 'up' : 'down');
            }
            
            if (changeEl) {
                changeEl.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                changeEl.className = 'trading-hub-change ' + (change >= 0 ? 'up' : 'down');
            }
        }
        
        function updateHubStudyToggles() {
            Object.keys(hubStudies).forEach(study => {
                const toggle = document.getElementById(`hub-toggle-${study}`);
                if (toggle) {
                    toggle.classList.toggle('active', hubStudies[study]);
                }
            });
        }
        
        function updateHubPositionInfo() {
            // Get current selected symbol
            const symbol = document.getElementById('hub-buy-symbol')?.value || '';
            
            // Check if this is an index
            const indexSymbols = ['KENYA', 'KENYAN', 'INDIA', 'CEYLON', 'CHINA', 'JAPAN', 'AFRICA', 'ASIA'];
            const lookupSymbol = symbol === 'KENYAN' ? 'KENYA' : symbol;
            const isIndex = indexSymbols.includes(symbol);
            
            let position = null;
            let currentPrice = 0;
            
            if (isIndex) {
                // For indexes, use Supabase-backed index positions
                const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
                const index = indexes.find(idx => idx.symbol === lookupSymbol);
                
                if (index) {
                    currentPrice = index.price || 0;
                    
                    // Get index position from Supabase (loaded into memory)
                    const indexPos = typeof getIndexPosition === 'function' ? getIndexPosition(lookupSymbol) : null;
                    if (indexPos && indexPos.quantity > 0) {
                        position = {
                            quantity: indexPos.quantity,
                            avg_entry_price: indexPos.avg_entry_price
                        };
                    }
                }
            } else {
                // For teas, find direct position
                const tea = teas?.find(t => t.symbol === symbol);
                if (tea) {
                    position = positions?.find(p => p.tea_id === tea.id);
                    currentPrice = tea.current_price || 0;
                }
            }
            
            const qtyEl = document.getElementById('hub-position-qty');
            const entryEl = document.getElementById('hub-position-entry');
            const pnlEl = document.getElementById('hub-position-pnl');
            
            // Only show entry price on chart if selected symbol matches the chart symbol
            const chartSymbol = mainChartData?.symbol || '';
            const normalizedChartSymbol = chartSymbol === 'KENYAN' ? 'KENYA' : chartSymbol;
            const normalizedSelectedSymbol = symbol === 'KENYAN' ? 'KENYA' : symbol;
            const symbolMatchesChart = normalizedSelectedSymbol === normalizedChartSymbol;
            
            // Store entry price for chart drawing (only if symbol matches chart)
            window.hubEntryPrice = (symbolMatchesChart && position?.avg_entry_price) ? position.avg_entry_price : null;
            window.hubCurrentPrice = currentPrice;
            
            if (position && position.quantity > 0) {
                const pnl = (currentPrice - position.avg_entry_price) * position.quantity;
                const pnlPercent = position.avg_entry_price > 0 ? ((currentPrice / position.avg_entry_price) - 1) * 100 : 0;
                
                if (qtyEl) qtyEl.textContent = `${position.quantity.toLocaleString()} kg`;
                if (entryEl) entryEl.textContent = `$${position.avg_entry_price.toFixed(2)}`;
                if (pnlEl) {
                    pnlEl.textContent = `${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(1)}%)`;
                    pnlEl.style.color = pnl >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
                }
            } else {
                if (qtyEl) qtyEl.textContent = '0 kg';
                if (entryEl) entryEl.textContent = '$â€”';
                if (pnlEl) {
                    pnlEl.textContent = '$0.00';
                    pnlEl.style.color = 'var(--text-secondary)';
                }
                window.hubEntryPrice = null;
            }
        }
        
        function setupRsiResizer() {
            const handle = document.getElementById('rsi-resize-handle');
            if (!handle) return;
            
            handle.addEventListener('mousedown', (e) => {
                isResizingRsi = true;
                document.body.style.cursor = 'ns-resize';
                document.body.style.userSelect = 'none';
                
                const startY = e.clientY;
                const startHeight = hubRsiHeight;
                
                const onMouseMove = (e) => {
                    if (!isResizingRsi) return;
                    const delta = startY - e.clientY;
                    hubRsiHeight = Math.max(80, Math.min(300, startHeight + delta));
                    const rsiCanvas = document.getElementById('hubRsiChart');
                    if (rsiCanvas) {
                        rsiCanvas.style.height = `${hubRsiHeight}px`;
                    }
                    drawHubChart();
                };
                
                const onMouseUp = () => {
                    isResizingRsi = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }
        
        function drawHubChart() {
            const canvas = document.getElementById('hubPriceChart');
            const wrapper = document.getElementById('hub-canvas-wrapper');
            
            if (!canvas || !wrapper) {
                return;
            }
            
            // Ensure we have data
            if (!hubChartData || hubChartData.length === 0) {
                hubChartData = generateHubChartData();
            }
            
            // Get dimensions - try multiple methods
            let width = wrapper.offsetWidth;
            let height = wrapper.offsetHeight;
            
            // If still no dimensions, use getBoundingClientRect
            if (width < 100 || height < 100) {
                const rect = wrapper.getBoundingClientRect();
                width = rect.width;
                height = rect.height;
            }
            
            // Final fallback - use viewport-based dimensions
            if (width < 100) width = (window.innerWidth - 400) * 0.9;
            if (height < 100) height = 350;
            
            // Set canvas size
            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.floor(width * dpr);
            canvas.height = Math.floor(height * dpr);
            canvas.style.width = Math.floor(width) + 'px';
            canvas.style.height = Math.floor(height) + 'px';
            
            const ctx = canvas.getContext('2d');
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
            
            const padding = { top: 25, right: 65, bottom: 35, left: 25 };
            
            // Clear canvas and fill with background
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Safety check for data validity
            if (!hubChartData || hubChartData.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '14px sans-serif';
                ctx.fillText('No chart data available', width/2 - 80, height/2);
                return;
            }
            
            // Calculate price range with Y-axis stabilization
            let dataMinPrice = Infinity, dataMaxPrice = -Infinity;
            hubChartData.forEach(d => {
                if (d && typeof d.low === 'number' && typeof d.high === 'number') {
                    dataMinPrice = Math.min(dataMinPrice, d.low);
                    dataMaxPrice = Math.max(dataMaxPrice, d.high);
                }
            });
            
            // Expand range to include entry price if user has a position
            if (window.hubEntryPrice && isFinite(window.hubEntryPrice)) {
                dataMinPrice = Math.min(dataMinPrice, window.hubEntryPrice);
                dataMaxPrice = Math.max(dataMaxPrice, window.hubEntryPrice);
            }
            
            // Fallback if prices are invalid
            if (!isFinite(dataMinPrice) || !isFinite(dataMaxPrice) || dataMinPrice === dataMaxPrice) {
                dataMinPrice = 3.0;
                dataMaxPrice = 4.0;
            }
            
            // Y-AXIS STABILIZATION: Use wider, stable range to prevent frequent rescaling
            const dataRange = dataMaxPrice - dataMinPrice;
            const midPrice = (dataMaxPrice + dataMinPrice) / 2;
            
            // Minimum range is 10% of mid price (prevents tiny ranges from zooming in too much)
            const minRange = midPrice * 0.10;
            const stableRange = Math.max(dataRange, minRange);
            
            // Add extra padding (20% on each side) for headroom
            let minPrice = midPrice - (stableRange * 0.7);
            let maxPrice = midPrice + (stableRange * 0.7);
            
            // Use cached Y-axis bounds if data is within 80% of current range (prevents flickering)
            const hubSymbol = document.getElementById('hub-buy-symbol')?.value || 'KENYA';
            if (!window.hubYAxisCache) window.hubYAxisCache = {};
            
            if (window.hubYAxisCache[hubSymbol]) {
                const cached = window.hubYAxisCache[hubSymbol];
                const cachedRange = cached.max - cached.min;
                // Only update if prices would exceed 80% of the cached range
                if (dataMinPrice >= cached.min + cachedRange * 0.1 && 
                    dataMaxPrice <= cached.max - cachedRange * 0.1) {
                    minPrice = cached.min;
                    maxPrice = cached.max;
                } else {
                    // Prices exceeded bounds - update cache with new stable range
                    window.hubYAxisCache[hubSymbol] = { min: minPrice, max: maxPrice };
                }
            } else {
                // First render - cache the bounds
                window.hubYAxisCache[hubSymbol] = { min: minPrice, max: maxPrice };
            }
            
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const getX = (i) => padding.left + (i / (hubChartData.length - 1)) * chartWidth;
            const getY = (price) => padding.top + (1 - (price - minPrice) / (maxPrice - minPrice)) * chartHeight;
            
            // Draw grid
            ctx.strokeStyle = '#1a2332';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (i / 4) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
            }
            
            // Draw average price line (dashed)
            const avgPrice = hubChartData.reduce((sum, d) => sum + d.close, 0) / hubChartData.length;
            const avgY = getY(avgPrice);
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(padding.left, avgY);
            ctx.lineTo(width - padding.right, avgY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw studies
            if (hubStudies.bollinger) {
                // Draw Bollinger Bands
                const period = 20;
                const multiplier = 2;
                
                if (hubChartData.length >= period) {
                    ctx.fillStyle = 'rgba(96, 165, 250, 0.1)';
                    ctx.beginPath();
                    
                    for (let i = period - 1; i < hubChartData.length; i++) {
                        const slice = hubChartData.slice(i - period + 1, i + 1);
                        const avg = slice.reduce((a, b) => a + b.close, 0) / period;
                        const stdDev = Math.sqrt(slice.reduce((a, b) => a + Math.pow(b.close - avg, 2), 0) / period);
                        const upper = avg + multiplier * stdDev;
                        
                        const x = getX(i);
                        if (i === period - 1) {
                            ctx.moveTo(x, getY(upper));
                        } else {
                            ctx.lineTo(x, getY(upper));
                        }
                    }
                    
                    for (let i = hubChartData.length - 1; i >= period - 1; i--) {
                        const slice = hubChartData.slice(i - period + 1, i + 1);
                        const avg = slice.reduce((a, b) => a + b.close, 0) / period;
                        const stdDev = Math.sqrt(slice.reduce((a, b) => a + Math.pow(b.close - avg, 2), 0) / period);
                        const lower = avg - multiplier * stdDev;
                        ctx.lineTo(getX(i), getY(lower));
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            if (hubStudies.sma10) {
                drawHubSMA(ctx, 10, '#facc15', getX, getY);
            }
            
            if (hubStudies.sma20) {
                drawHubSMA(ctx, 20, '#f59e0b', getX, getY);
            }
            
            // Draw price line or candles
            if (hubChartType === 'line') {
                // Draw line chart matching main chart style
                ctx.beginPath();
                hubChartData.forEach((d, i) => {
                    if (i === 0) {
                        ctx.moveTo(getX(i), getY(d.close));
                    } else {
                        ctx.lineTo(getX(i), getY(d.close));
                    }
                });
                ctx.strokeStyle = '#1a73e8';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw subtle area fill matching main chart
                ctx.lineTo(getX(hubChartData.length - 1), height - padding.bottom);
                ctx.lineTo(getX(0), height - padding.bottom);
                ctx.closePath();
                ctx.fillStyle = 'rgba(26, 115, 232, 0.15)';
                ctx.fill();
            } else {
                // Draw candles
                const candleWidth = Math.max(2, (chartWidth / hubChartData.length) - 2);
                
                hubChartData.forEach((d, i) => {
                    const x = getX(i);
                    const isUp = d.close >= d.open;
                    
                    ctx.fillStyle = isUp ? '#10b981' : '#ef4444';
                    ctx.strokeStyle = isUp ? '#10b981' : '#ef4444';
                    
                    // Draw wick
                    ctx.beginPath();
                    ctx.moveTo(x, getY(d.high));
                    ctx.lineTo(x, getY(d.low));
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Draw body
                    const bodyTop = getY(Math.max(d.open, d.close));
                    const bodyBottom = getY(Math.min(d.open, d.close));
                    const bodyHeight = Math.max(1, bodyBottom - bodyTop);
                    ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                });
            }
            
            // Draw price labels on right axis
            ctx.fillStyle = '#9ca3af';
            ctx.font = '10px JetBrains Mono, monospace';
            ctx.textAlign = 'left';
            for (let i = 0; i <= 4; i++) {
                const price = maxPrice - (i / 4) * (maxPrice - minPrice);
                const y = padding.top + (i / 4) * chartHeight;
                ctx.fillText(`$${price.toFixed(2)}`, width - padding.right + 5, y + 3);
            }
            
            // Draw last price callout
            const lastPrice = hubChartData[hubChartData.length - 1].close;
            const lastY = getY(lastPrice);
            const isUp = hubChartData.length > 1 && hubChartData[hubChartData.length - 1].close >= hubChartData[hubChartData.length - 2].close;
            
            ctx.fillStyle = isUp ? '#10b981' : '#ef4444';
            ctx.fillRect(width - padding.right, lastY - 10, padding.right, 20);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 11px JetBrains Mono, monospace';
            ctx.fillText(`$${lastPrice.toFixed(2)}`, width - padding.right + 5, lastY + 4);
            
            // Draw user's entry price line if they have a position
            if (window.hubEntryPrice && window.hubEntryPrice >= minPrice && window.hubEntryPrice <= maxPrice) {
                const entryY = getY(window.hubEntryPrice);
                const isProfit = lastPrice >= window.hubEntryPrice;
                const pnlColor = isProfit ? '#10b981' : '#ef4444';
                
                // Draw dotted entry line
                ctx.strokeStyle = pnlColor;
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(padding.left, entryY);
                ctx.lineTo(width - padding.right, entryY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw entry price label on left side
                const pnlDiff = lastPrice - window.hubEntryPrice;
                const pnlPercent = ((lastPrice / window.hubEntryPrice) - 1) * 100;
                const labelText = `Entry $${window.hubEntryPrice.toFixed(2)}`;
                const pnlText = `${pnlDiff >= 0 ? '+' : ''}${pnlPercent.toFixed(1)}%`;
                
                // Draw label background on left
                ctx.fillStyle = pnlColor;
                const labelWidth = 85;
                ctx.fillRect(0, entryY - 10, labelWidth, 20);
                
                // Draw text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 9px JetBrains Mono, monospace';
                ctx.textAlign = 'left';
                ctx.fillText(labelText, 4, entryY + 3);
                
                // Draw P/L badge on right side of entry line
                ctx.fillStyle = pnlColor;
                ctx.fillRect(width - padding.right, entryY - 10, padding.right, 20);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px JetBrains Mono, monospace';
                ctx.fillText(pnlText, width - padding.right + 8, entryY + 4);
            }
            
            // Draw hub RSI if enabled
            if (hubStudies.rsi) {
                drawHubRsi();
            }
            
            // Store chart metadata for crosshair interaction
            window.hubChartMeta = {
                data: hubChartData,
                padding: padding,
                minPrice: minPrice,
                maxPrice: maxPrice,
                chartWidth: chartWidth,
                chartHeight: chartHeight,
                width: width,
                height: height,
                getX: getX,
                getY: getY
            };
        }
        
        function drawHubSMA(ctx, period, color, getX, getY) {
            if (hubChartData.length < period) return;
            
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            
            let started = false;
            for (let i = period - 1; i < hubChartData.length; i++) {
                const slice = hubChartData.slice(i - period + 1, i + 1);
                const avg = slice.reduce((a, b) => a + b.close, 0) / period;
                
                if (!started) {
                    ctx.moveTo(getX(i), getY(avg));
                    started = true;
                } else {
                    ctx.lineTo(getX(i), getY(avg));
                }
            }
            ctx.stroke();
        }
        
        function drawHubRsi() {
            const canvas = document.getElementById('hubRsiChart');
            if (!canvas || hubChartData.length < 15) return;
            
            const container = canvas.parentElement;
            canvas.style.height = `${hubRsiHeight}px`;
            
            const dpr = window.devicePixelRatio || 1;
            const width = container.offsetWidth;
            const height = hubRsiHeight;
            
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            
            const padding = { top: 10, right: 60, bottom: 10, left: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Calculate RSI values
            const rsiValues = [];
            const period = 14;
            
            for (let i = period; i < hubChartData.length; i++) {
                let gains = 0, losses = 0;
                for (let j = i - period + 1; j <= i; j++) {
                    const change = hubChartData[j].close - hubChartData[j - 1].close;
                    if (change > 0) gains += change;
                    else losses -= change;
                }
                const avgGain = gains / period;
                const avgLoss = losses / period;
                const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                const rsi = 100 - (100 / (1 + rs));
                rsiValues.push({ index: i, rsi });
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'var(--bg-card)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw overbought/oversold zones
            const getY = (rsi) => padding.top + (1 - rsi / 100) * chartHeight;
            const getX = (i) => padding.left + ((i - period) / (hubChartData.length - period - 1)) * chartWidth;
            
            // Overbought zone (70-100)
            ctx.fillStyle = 'rgba(239, 68, 68, 0.1)';
            ctx.fillRect(padding.left, getY(100), chartWidth, getY(70) - getY(100));
            
            // Oversold zone (0-30)
            ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
            ctx.fillRect(padding.left, getY(30), chartWidth, getY(0) - getY(30));
            
            // Draw horizontal lines
            ctx.strokeStyle = '#2a2a3e';
            ctx.lineWidth = 1;
            [30, 50, 70].forEach(level => {
                const y = getY(level);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
                
                ctx.fillStyle = '#6b7280';
                ctx.font = '9px JetBrains Mono';
                ctx.fillText(level.toString(), width - padding.right + 5, y + 3);
            });
            
            // Draw RSI line
            ctx.beginPath();
            ctx.strokeStyle = '#ec4899';
            ctx.lineWidth = 2;
            
            rsiValues.forEach((r, i) => {
                const x = getX(r.index);
                const y = getY(r.rsi);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // Update RSI value display
            if (rsiValues.length > 0) {
                const lastRsi = rsiValues[rsiValues.length - 1].rsi;
                const rsiValueEl = document.getElementById('hub-rsi-value');
                if (rsiValueEl) {
                    rsiValueEl.textContent = lastRsi.toFixed(1);
                    rsiValueEl.style.color = lastRsi >= 70 ? '#ef4444' : lastRsi <= 30 ? '#10b981' : '#9ca3af';
                }
            }
        }
        
        function toggleHubTimeframeMenu() {
            const menu = document.getElementById('hub-timeframe-menu');
            if (menu) {
                menu.classList.toggle('show');
            }
        }
        
        function setHubTimeframe(tf) {
            hubTimeframe = tf;
            document.getElementById('hub-timeframe-label').textContent = tf;
            document.getElementById('hub-timeframe-menu').classList.remove('show');
            
            // Also update main chart timeframe to keep in sync
            setTimeframe(tf);
            hubChartData = [...chartData];
            drawHubChart();
        }
        
        function toggleHubStudiesMenu() {
            const menu = document.getElementById('hub-studies-menu');
            if (menu) {
                menu.classList.toggle('show');
            }
        }
        
        function toggleHubStudy(study) {
            hubStudies[study] = !hubStudies[study];
            updateHubStudyToggles();
            
            // Show/hide RSI section
            if (study === 'rsi') {
                const rsiSection = document.getElementById('hub-rsi-section');
                if (hubStudies.rsi) {
                    rsiSection.classList.add('visible');
                } else {
                    rsiSection.classList.remove('visible');
                }
            }
            
            drawHubChart();
        }
        
        function setHubChartType(type) {
            hubChartType = type;
            document.getElementById('hub-btn-line').classList.toggle('active', type === 'line');
            document.getElementById('hub-btn-candle').classList.toggle('active', type === 'candle');
            drawHubChart();
        }
        
        function switchHubTradeTab(tab) {
            const tabs = document.querySelectorAll('.trading-hub-sidebar .trade-tab');
            const buyForm = document.getElementById('hub-buy-form');
            const sellForm = document.getElementById('hub-sell-form');
            
            tabs.forEach(t => t.classList.remove('active'));
            document.querySelector(`.trading-hub-sidebar .trade-tab[data-tab="${tab}"]`).classList.add('active');
            
            if (tab === 'hub-buy') {
                buyForm.style.display = 'block';
                sellForm.style.display = 'none';
            } else {
                buyForm.style.display = 'none';
                sellForm.style.display = 'block';
            }
        }
        
        function setHubQuickAmount(side, amount) {
            document.getElementById(`hub-${side}-quantity`).value = amount;
            updateHubOrderPreview();
        }
        
        function updateHubOrderPreview() {
            const buyQty = parseFloat(document.getElementById('hub-buy-quantity')?.value) || 0;
            const sellQty = parseFloat(document.getElementById('hub-sell-quantity')?.value) || 0;
            const buySymbol = document.getElementById('hub-buy-symbol')?.value;
            const sellSymbol = document.getElementById('hub-sell-symbol')?.value;
            
            // Helper to get price for symbol (tea or index)
            const getPriceForSymbol = (symbol) => {
                const indexSymbols = ['KENYA', 'KENYAN', 'INDIA', 'CEYLON', 'CHINA', 'JAPAN', 'AFRICA', 'ASIA'];
                if (indexSymbols.includes(symbol)) {
                    const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
                    const lookupSymbol = symbol === 'KENYAN' ? 'KENYA' : symbol;
                    const index = indexes.find(idx => idx.symbol === lookupSymbol);
                    return index?.price || 3.50;
                } else {
                    const tea = teas?.find(t => t.symbol === symbol);
                    return tea?.current_price || 3.50;
                }
            };
            
            const buyPrice = getPriceForSymbol(buySymbol);
            const sellPrice = getPriceForSymbol(sellSymbol);
            
            // Buy preview
            const buyTotal = buyQty * buyPrice;
            const buyCommission = buyTotal * 0.001;
            document.getElementById('hub-buy-est-price').textContent = `$${buyPrice.toFixed(2)}/kg`;
            document.getElementById('hub-buy-total-cost').textContent = `$${buyTotal.toFixed(2)}`;
            document.getElementById('hub-buy-commission').textContent = `$${buyCommission.toFixed(2)}`;
            
            // Sell preview
            const sellTotal = sellQty * sellPrice;
            const sellCommission = sellTotal * 0.001;
            document.getElementById('hub-sell-est-price').textContent = `$${sellPrice.toFixed(2)}/kg`;
            document.getElementById('hub-sell-total-cost').textContent = `$${sellTotal.toFixed(2)}`;
            document.getElementById('hub-sell-commission').textContent = `$${sellCommission.toFixed(2)}`;
            
            // Handle limit price visibility
            const buyOrderType = document.getElementById('hub-buy-order-type')?.value;
            const sellOrderType = document.getElementById('hub-sell-order-type')?.value;
            
            document.getElementById('hub-buy-limit-price-group').style.display = buyOrderType === 'limit' ? 'block' : 'none';
            document.getElementById('hub-sell-limit-price-group').style.display = sellOrderType === 'limit' ? 'block' : 'none';
            
            // Update position display
            updateHubPositionInfo();
            
            // Update chart title to match selected symbol
            const hubTitle = document.getElementById('hub-chart-title');
            const indexSymbols = ['KENYA', 'KENYAN', 'INDIA', 'CEYLON', 'CHINA', 'JAPAN', 'AFRICA', 'ASIA'];
            const isIndex = indexSymbols.includes(buySymbol);
            
            const priceDisplay = document.querySelector('#trading-hub-chart-panel .price-display h3');
            const changeDisplay = document.querySelector('#trading-hub-chart-panel .price-display .change');
            
            if (isIndex) {
                const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
                const lookupSymbol = buySymbol === 'KENYAN' ? 'KENYA' : buySymbol;
                const index = indexes.find(idx => idx.symbol === lookupSymbol);
                if (hubTitle && index) {
                    hubTitle.textContent = index.name || buySymbol;
                }
                if (priceDisplay && index) {
                    priceDisplay.textContent = `$${index.price?.toFixed(2) || '0.00'}`;
                    const change = index.change || 0;
                    if (changeDisplay) {
                        changeDisplay.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                        changeDisplay.className = `change ${change >= 0 ? 'up' : 'down'}`;
                    }
                }
            } else {
                const tea = teas?.find(t => t.symbol === buySymbol);
                if (hubTitle && tea) {
                    hubTitle.textContent = tea.name || buySymbol;
                }
                if (priceDisplay && tea) {
                    priceDisplay.textContent = `$${tea.current_price?.toFixed(2) || '0.00'}`;
                    const change = tea.previous_price ? ((tea.current_price - tea.previous_price) / tea.previous_price * 100) : 0;
                    if (changeDisplay) {
                        changeDisplay.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                        changeDisplay.className = `change ${change >= 0 ? 'up' : 'down'}`;
                    }
                }
            }
            
            // Load chart data for new symbol from cache/DB and redraw
            // Use sync version first, then async load in background if no cache
            hubChartData = generateHubChartData();
            const hubSym = document.getElementById('hub-buy-symbol')?.value || 'KENYA';
            
            // Clear Y-axis cache for this symbol so chart starts fresh with new bounds
            if (window.hubYAxisCache) {
                delete window.hubYAxisCache[hubSym];
            }
            
            loadOrGenerateHubChartData(hubSym).then(data => {
                hubChartData = data;
                if (maximizedPanel?.classList.contains('panel-maximized')) {
                    drawHubChart();
                }
            });
            if (maximizedPanel?.classList.contains('panel-maximized')) {
                drawHubChart();
            }
        }
        
        async function executeHubTrade(side) {
            if (!currentUser) {
                showToast('Please log in to trade', 'error');
                return;
            }
            
            let symbol = document.getElementById(`hub-${side}-symbol`)?.value;
            const quantity = parseFloat(document.getElementById(`hub-${side}-quantity`)?.value);
            const orderType = document.getElementById(`hub-${side}-order-type`)?.value;
            
            if (!quantity || quantity <= 0) {
                showToast('Please enter a valid quantity', 'error');
                return;
            }
            
            // Check if this is an index trade
            const indexSymbols = ['KENYA', 'KENYAN', 'INDIA', 'CEYLON', 'CHINA', 'JAPAN', 'AFRICA', 'ASIA'];
            const lookupSymbol = symbol === 'KENYAN' ? 'KENYA' : symbol;
            const isIndex = indexSymbols.includes(symbol);
            
            let price, productName, teaId = null;
            
            if (isIndex) {
                // INDEX TRADE
                const indexes = typeof calculateRegionalIndexes === 'function' ? calculateRegionalIndexes() : [];
                const index = indexes.find(idx => idx.symbol === lookupSymbol);
                
                if (!index) {
                    showToast('Index not found', 'error');
                    return;
                }
                
                price = orderType === 'limit' 
                    ? parseFloat(document.getElementById(`hub-${side}-limit-price`)?.value)
                    : index.price || 3.50;
                productName = index.name || symbol;
                
                // Use first underlying tea's ID for database reference
                const underlyingTea = teas?.find(t => index.teas?.includes(t.symbol));
                teaId = underlyingTea?.id || null;
                
            } else {
                // TEA TRADE
                const tea = teas?.find(t => t.symbol === symbol);
                if (!tea) {
                    showToast('Product not found. Please select a valid symbol.', 'error');
                    return;
                }
                
                price = orderType === 'limit' 
                    ? parseFloat(document.getElementById(`hub-${side}-limit-price`)?.value)
                    : tea.current_price || 3.50;
                productName = tea.name || symbol;
                teaId = tea.id;
            }
            
            if (orderType === 'limit' && (!price || price <= 0)) {
                showToast('Please enter a valid limit price', 'error');
                return;
            }
            
            try {
                const total = quantity * price;
                
                if (isIndex) {
                    // INDEX POSITION HANDLING (Supabase-backed)
                    if (side === 'buy') {
                        if (!userProfile || total > userProfile.cash_balance) {
                            showToast('Insufficient balance', 'error');
                            return;
                        }
                        
                        // Update cash balance
                        const newBalance = userProfile.cash_balance - total;
                        const { error: balanceError } = await supabaseClient
                            .from('profiles')
                            .update({ cash_balance: newBalance })
                            .eq('id', currentUser.id);
                        if (balanceError) throw balanceError;
                        userProfile.cash_balance = newBalance;
                        
                        // Update index position in database
                        await updateIndexPosition(lookupSymbol, quantity, price, 'BUY');
                        
                    } else {
                        // SELL index
                        const indexPos = getIndexPosition(lookupSymbol);
                        if (!indexPos || indexPos.quantity < quantity) {
                            showToast('Insufficient index holdings to sell', 'error');
                            return;
                        }
                        
                        // Update cash balance
                        const newBalance = userProfile.cash_balance + total;
                        const { error: balanceError } = await supabaseClient
                            .from('profiles')
                            .update({ cash_balance: newBalance })
                            .eq('id', currentUser.id);
                        if (balanceError) throw balanceError;
                        userProfile.cash_balance = newBalance;
                        
                        // Update index position in database
                        await updateIndexPosition(lookupSymbol, quantity, price, 'SELL');
                    }
                    
                    // Record index trade with index_symbol in database
                    const { error } = await supabaseClient
                        .from('trades')
                        .insert({
                            user_id: currentUser.id,
                            tea_id: teaId,
                            side: side.toUpperCase(),
                            quantity: quantity,
                            price: price,
                            total_value: total,
                            index_symbol: lookupSymbol
                        });
                    
                    if (error) throw error;
                    
                } else {
                    // TEA POSITION HANDLING (existing logic)
                    if (side === 'buy') {
                        if (!userProfile || total > userProfile.cash_balance) {
                            showToast('Insufficient balance', 'error');
                            return;
                        }
                        
                        // Update cash balance
                        const newBalance = userProfile.cash_balance - total;
                        const { error: balanceError } = await supabaseClient
                            .from('profiles')
                            .update({ cash_balance: newBalance })
                            .eq('id', currentUser.id);
                        if (balanceError) throw balanceError;
                        userProfile.cash_balance = newBalance;
                        
                        // Update or create position
                        const existingPosition = positions?.find(p => p.tea_id === teaId);
                        if (existingPosition) {
                            const totalQty = existingPosition.quantity + quantity;
                            const newAvgPrice = ((existingPosition.avg_entry_price * existingPosition.quantity) + (price * quantity)) / totalQty;
                            
                            const { error: posError } = await supabaseClient
                                .from('positions')
                                .update({ 
                                    quantity: totalQty, 
                                    avg_entry_price: newAvgPrice,
                                    updated_at: new Date().toISOString()
                                })
                                .eq('id', existingPosition.id);
                            if (posError) throw posError;
                        } else {
                            const { error: posError } = await supabaseClient
                                .from('positions')
                                .insert({
                                    user_id: currentUser.id,
                                    tea_id: teaId,
                                    quantity: quantity,
                                    avg_entry_price: price
                                });
                            if (posError) throw posError;
                        }
                        
                    } else {
                        // SELL tea
                        const existingPosition = positions?.find(p => p.tea_id === teaId);
                        if (!existingPosition || existingPosition.quantity < quantity) {
                            showToast('Insufficient holdings to sell', 'error');
                            return;
                        }
                        
                        // Update cash balance
                        const newBalance = userProfile.cash_balance + total;
                        const { error: balanceError } = await supabaseClient
                            .from('profiles')
                            .update({ cash_balance: newBalance })
                            .eq('id', currentUser.id);
                        if (balanceError) throw balanceError;
                        userProfile.cash_balance = newBalance;
                        
                        // Update or delete position
                        const newQty = existingPosition.quantity - quantity;
                        if (newQty <= 0) {
                            const { error: posError } = await supabaseClient
                                .from('positions')
                                .delete()
                                .eq('id', existingPosition.id);
                            if (posError) throw posError;
                        } else {
                            const { error: posError } = await supabaseClient
                                .from('positions')
                                .update({ 
                                    quantity: newQty,
                                    updated_at: new Date().toISOString()
                                })
                                .eq('id', existingPosition.id);
                            if (posError) throw posError;
                        }
                    }
                    
                    // Record tea trade
                    const { data, error } = await supabaseClient
                        .from('trades')
                        .insert({
                            user_id: currentUser.id,
                            tea_id: teaId,
                            side: side.toUpperCase(),
                            quantity: quantity,
                            price: price,
                            total_value: total
                        })
                        .select()
                        .single();
                    
                    if (error) throw error;
                }
                
                showToast(`${side.toUpperCase()} order placed: ${symbol} ${quantity} kg @ $${price.toFixed(2)}`, 'success');
                
                // Add to trade log
                addTradeToLog({
                    time: new Date(),
                    symbol: symbol,
                    side: side,
                    quantity: quantity,
                    price: price
                });
                
                // Clear form
                document.getElementById(`hub-${side}-quantity`).value = '';
                updateHubOrderPreview();
                
                // Reload positions and trades
                if (typeof loadPositions === 'function') {
                    await loadPositions();
                }
                if (typeof loadIndexPositions === 'function') {
                    await loadIndexPositions();
                }
                if (typeof loadUserTrades === 'function') {
                    loadUserTrades();
                }
                
                // Update position info display and redraw chart to show entry line
                updateHubPositionInfo();
                drawHubChart();
                
            } catch (err) {
                console.error('Trade error:', err);
                showToast('Error placing order: ' + err.message, 'error');
            }
        }
        
        // INDEX POSITION TRACKING (Supabase-backed)
        let indexPositions = {};
        
        async function loadIndexPositions() {
            if (!currentUser) return;
            try {
                const { data, error } = await supabaseClient
                    .from('index_positions')
                    .select('*')
                    .eq('user_id', currentUser.id);
                
                if (error) throw error;
                
                indexPositions = {};
                if (data) {
                    data.forEach(pos => {
                        indexPositions[pos.index_symbol] = {
                            id: pos.id,
                            quantity: parseFloat(pos.quantity),
                            avg_entry_price: parseFloat(pos.avg_entry_price)
                        };
                    });
                }
            } catch (e) {
                console.error('Failed to load index positions:', e);
                indexPositions = {};
            }
        }
        
        function getIndexPosition(indexSymbol) {
            return indexPositions[indexSymbol] || null;
        }
        
        async function updateIndexPosition(indexSymbol, quantity, price, side) {
            if (!currentUser) return;
            
            const existing = indexPositions[indexSymbol];
            
            try {
                if (side === 'BUY') {
                    if (existing) {
                        // Update existing position
                        const totalQty = existing.quantity + quantity;
                        const newAvgPrice = ((existing.avg_entry_price * existing.quantity) + (price * quantity)) / totalQty;
                        
                        const { error } = await supabaseClient
                            .from('index_positions')
                            .update({ 
                                quantity: totalQty, 
                                avg_entry_price: newAvgPrice,
                                updated_at: new Date().toISOString()
                            })
                            .eq('id', existing.id);
                        
                        if (error) throw error;
                        
                        indexPositions[indexSymbol] = {
                            id: existing.id,
                            quantity: totalQty,
                            avg_entry_price: newAvgPrice
                        };
                    } else {
                        // Create new position
                        const { data, error } = await supabaseClient
                            .from('index_positions')
                            .insert({
                                user_id: currentUser.id,
                                index_symbol: indexSymbol,
                                quantity: quantity,
                                avg_entry_price: price
                            })
                            .select()
                            .single();
                        
                        if (error) throw error;
                        
                        indexPositions[indexSymbol] = {
                            id: data.id,
                            quantity: quantity,
                            avg_entry_price: price
                        };
                    }
                } else {
                    // SELL
                    if (existing) {
                        const newQty = existing.quantity - quantity;
                        if (newQty <= 0) {
                            // Delete position
                            const { error } = await supabaseClient
                                .from('index_positions')
                                .delete()
                                .eq('id', existing.id);
                            
                            if (error) throw error;
                            
                            delete indexPositions[indexSymbol];
                        } else {
                            // Update position
                            const { error } = await supabaseClient
                                .from('index_positions')
                                .update({ 
                                    quantity: newQty,
                                    updated_at: new Date().toISOString()
                                })
                                .eq('id', existing.id);
                            
                            if (error) throw error;
                            
                            indexPositions[indexSymbol] = {
                                id: existing.id,
                                quantity: newQty,
                                avg_entry_price: existing.avg_entry_price
                            };
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to update index position:', e);
                throw e;
            }
        }

        // Trade Log Simulation
        let tradeLogEntries = [];
        let tradeLogInterval = null;
        
        function startTradeLogSimulation() {
            // Clear existing
            tradeLogEntries = [];
            if (tradeLogInterval) clearInterval(tradeLogInterval);
            
            // Generate initial entries
            const symbols = ['TEA-KE', 'TEA-LK', 'TEA-IN', 'TEA-CN', 'TEA-JP'];
            for (let i = 0; i < 8; i++) {
                const symbol = symbols[Math.floor(Math.random() * symbols.length)];
                const tea = teas?.find(t => t.symbol === symbol);
                const basePrice = tea?.current_price || (3 + Math.random() * 2);
                
                tradeLogEntries.push({
                    time: new Date(Date.now() - (i * 5000) - Math.random() * 60000),
                    symbol: symbol,
                    side: Math.random() > 0.5 ? 'buy' : 'sell',
                    quantity: Math.round((100 + Math.random() * 900) / 50) * 50,
                    price: basePrice + (Math.random() - 0.5) * 0.1
                });
            }
            
            renderTradeLog();
            
            // Simulate new trades
            tradeLogInterval = setInterval(() => {
                if (!maximizedPanel?.classList.contains('panel-maximized')) {
                    clearInterval(tradeLogInterval);
                    return;
                }
                
                const symbol = symbols[Math.floor(Math.random() * symbols.length)];
                const tea = teas?.find(t => t.symbol === symbol);
                const basePrice = tea?.current_price || (3 + Math.random() * 2);
                
                addTradeToLog({
                    time: new Date(),
                    symbol: symbol,
                    side: Math.random() > 0.5 ? 'buy' : 'sell',
                    quantity: Math.round((100 + Math.random() * 900) / 50) * 50,
                    price: basePrice + (Math.random() - 0.5) * 0.1
                });
            }, 3000 + Math.random() * 5000);
        }
        
        function addTradeToLog(trade) {
            tradeLogEntries.unshift(trade);
            if (tradeLogEntries.length > 20) {
                tradeLogEntries.pop();
            }
            renderTradeLog();
        }
        
        function renderTradeLog() {
            const container = document.getElementById('trade-log-content');
            if (!container) return;
            
            container.innerHTML = tradeLogEntries.map(trade => {
                const time = trade.time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const symbolShort = trade.symbol.split('-')[1] || trade.symbol;
                
                return `
                    <div class="trade-log-item">
                        <span class="trade-log-time">${time}</span>
                        <span class="trade-log-symbol">${symbolShort}</span>
                        <span class="trade-log-side ${trade.side}">${trade.side.toUpperCase()}</span>
                        <span class="trade-log-qty">${trade.quantity.toLocaleString()} kg</span>
                        <span class="trade-log-price">$${trade.price.toFixed(2)}</span>
                    </div>
                `;
            }).join('');
        }

        // Escape key to close maximized panel
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && maximizedPanel) {
                toggleMaximize(maximizedPanel.id);
            }
        });

        // =============================================
        // FLASH QUOTE BOARD FUNCTIONS
        // =============================================

        let previousQuotePrices = {};

        function initQuoteBoard() {
            updateQuoteBoard();
        }

        let selectedQuoteSymbol = null;

        function updateQuoteBoard() {
            const board = document.getElementById('quote-board');
            if (!board || !teas || teas.length === 0) return;

            // Show 10 teas for 2 complete rows of 5
            const topTeas = teas.slice(0, 10);
            
            board.innerHTML = topTeas.map(tea => {
                const symbol = tea.symbol.split('-')[1] || tea.symbol;
                const price = tea.current_price || 0;
                const change = tea.price_change_24h || 0;
                const volume = tea.volume_24h || 0;
                const isUp = change >= 0;
                const prevPrice = previousQuotePrices[tea.symbol];
                let flashClass = '';
                const selectedClass = selectedQuoteSymbol === tea.symbol ? 'selected' : '';
                
                if (prevPrice !== undefined && prevPrice !== price) {
                    flashClass = price > prevPrice ? 'flash-green' : 'flash-red';
                }
                previousQuotePrices[tea.symbol] = price;
                
                const volDisplay = volume >= 1000 ? `${Math.round(volume / 1000)}K` : volume.toString();

                return `
                    <div class="quote-card ${flashClass} ${selectedClass}" onclick="selectTeaForTrading('${tea.symbol}')">
                        <div class="quote-symbol">${symbol}</div>
                        <div class="quote-price ${isUp ? 'up' : 'down'}">$${price.toFixed(2)}</div>
                        <div class="quote-change ${isUp ? 'up' : 'down'}">${isUp ? 'â–²' : 'â–¼'} ${change >= 0 ? '+' : ''}${change.toFixed(1)}%</div>
                        <div class="quote-volume">Vol: ${volDisplay}</div>
                    </div>
                `;
            }).join('');
        }
        
        function selectTeaForTrading(symbol) {
            // Track selected symbol
            selectedQuoteSymbol = symbol;
            
            // Find the tea data
            const tea = teas.find(t => t.symbol === symbol);
            if (!tea) return;
            
            // Open the quick quote modal
            openQuickQuoteModal(tea);
        }
        
        let quickQuoteTradeType = 'BUY';
        let quickQuoteTea = null;
        
        function openQuickQuoteModal(tea) {
            quickQuoteTea = tea;
            const modal = document.getElementById('quick-quote-modal');
            if (!modal) return;
            
            const shortSymbol = tea.symbol.split('-')[1] || tea.symbol;
            const price = tea.current_price || 0;
            const change = tea.price_change_24h || 0;
            const isUp = change >= 0;
            const volume = tea.volume_24h || 0;
            
            // Reset modal state
            qqTimeframe = '1D';
            qqChartType = 'line';
            qqIndicators = { sma: false, ema: false, bollinger: false };
            document.querySelectorAll('.qq-tf-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tf === '1D'));
            document.querySelectorAll('.qq-chart-type-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.type === 'line'));
            document.querySelectorAll('.qq-indicator-btn').forEach(btn => btn.classList.remove('active'));
            
            // Clear SL/TP inputs
            const slInput = document.getElementById('qq-sl');
            const tpInput = document.getElementById('qq-tp');
            if (slInput) slInput.value = '';
            if (tpInput) tpInput.value = '';
            
            // Populate header
            document.getElementById('qq-symbol').textContent = shortSymbol;
            document.getElementById('qq-name').textContent = tea.name;
            
            const priceEl = document.getElementById('qq-price');
            priceEl.textContent = `$${price.toFixed(2)}`;
            priceEl.className = `quick-quote-current-price ${isUp ? 'up' : 'down'}`;
            
            const changeEl = document.getElementById('qq-change');
            changeEl.textContent = `${isUp ? '+' : ''}${change.toFixed(1)}%`;
            changeEl.className = `quick-quote-change ${isUp ? 'up' : 'down'}`;
            
            // Get historical data and compute real stats
            const history = generateTeaHistory(tea);
            const last24h = history.length >= 24 ? history.slice(-24) : history;
            
            // Guard against empty data
            let high24h = price * 1.04;
            let low24h = price * 0.96;
            let avg24h = price;
            let totalVolume = 0;
            
            if (last24h.length > 0) {
                high24h = Math.max(...last24h.map(d => d.high));
                low24h = Math.min(...last24h.map(d => d.low));
                avg24h = last24h.reduce((sum, d) => sum + d.close, 0) / last24h.length;
                totalVolume = last24h.reduce((sum, d) => sum + d.volume, 0);
            }
            
            document.getElementById('qq-high').textContent = `$${high24h.toFixed(2)}`;
            document.getElementById('qq-low').textContent = `$${low24h.toFixed(2)}`;
            document.getElementById('qq-volume').textContent = totalVolume >= 1000000 ? `${Math.round(totalVolume / 1000000)}M` : totalVolume >= 1000 ? `${Math.round(totalVolume / 1000)}K` : totalVolume.toString();
            document.getElementById('qq-avg').textContent = `$${avg24h.toFixed(2)}`;
            
            // Set trade price
            document.getElementById('qq-trade-price').value = price.toFixed(2);
            document.getElementById('qq-qty').value = 100;
            
            // Update mobile trade bar price
            const mobilePriceEl = document.getElementById('qq-mobile-trade-price');
            if (mobilePriceEl) mobilePriceEl.textContent = `$${price.toFixed(2)}`;
            const mobileLabelEl = document.getElementById('qq-mobile-trade-label');
            if (mobileLabelEl) mobileLabelEl.textContent = tea.name || tea.symbol;
            
            // Update balance
            const balance = userProfile?.cash_balance || 10000;
            document.getElementById('qq-balance').textContent = `$${balance.toLocaleString('en-US', {minimumFractionDigits: 2})}`;
            
            // Reset trade type to BUY
            setQuickTradeType('BUY');
            updateQuickTradeSummary();
            
            // Update open positions display
            updateQQOpenPositions(tea.symbol);
            
            // Show modal FIRST so canvas has dimensions
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
            
            // Draw the chart AFTER modal is visible (needs a small delay for layout)
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    drawQuickQuoteChart(tea);
                    updateQQTradeAnnotations();
                });
            });
        }
        
        function closeQuickQuoteModal() {
            const modal = document.getElementById('quick-quote-modal');
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = '';
            }
            // Also close mobile trade form if open
            closeMobileQQTradeForm();
        }
        
        // Mobile Quick Quote Trade Form Functions
        function toggleMobileQQTradeForm() {
            const form = document.getElementById('qq-mobile-trade-form');
            const overlay = document.getElementById('qq-mobile-trade-overlay');
            if (!form || !overlay) return;
            
            if (form.classList.contains('active')) {
                closeMobileQQTradeForm();
                return;
            }
            
            // Sync data from main modal
            if (quickQuoteTea) {
                const price = quickQuoteTea.current_price || 0;
                document.getElementById('qq-mobile-form-title').textContent = `Trade ${quickQuoteTea.name || quickQuoteTea.symbol}`;
                document.getElementById('qq-mobile-price').value = price.toFixed(2);
                document.getElementById('qq-mobile-qty').value = document.getElementById('qq-qty')?.value || 100;
                
                const balance = userProfile?.cash_balance || 10000;
                document.getElementById('qq-mobile-balance').textContent = `$${balance.toLocaleString('en-US', {minimumFractionDigits: 2})}`;
                
                updateMobileQQSummary();
            }
            
            form.classList.add('active');
            overlay.classList.add('active');
        }
        
        function closeMobileQQTradeForm() {
            const form = document.getElementById('qq-mobile-trade-form');
            const overlay = document.getElementById('qq-mobile-trade-overlay');
            if (form) form.classList.remove('active');
            if (overlay) overlay.classList.remove('active');
        }
        
        function updateMobileQQSummary() {
            const qty = parseFloat(document.getElementById('qq-mobile-qty')?.value) || 0;
            const price = parseFloat(document.getElementById('qq-mobile-price')?.value) || 0;
            const total = qty * price;
            const balance = userProfile?.cash_balance || 10000;
            
            const valueEl = document.getElementById('qq-mobile-order-value');
            if (valueEl) valueEl.textContent = `$${total.toLocaleString('en-US', {minimumFractionDigits: 2})}`;
            
            const execBtn = document.getElementById('qq-mobile-execute-btn');
            if (execBtn) {
                execBtn.textContent = `${quickQuoteTradeType} ${qty} kg`;
                execBtn.className = `quick-trade-execute ${quickQuoteTradeType.toLowerCase()}`;
            }
        }
        
        function executeMobileQQTrade() {
            // Sync mobile form values to main form and execute
            const qty = document.getElementById('qq-mobile-qty')?.value;
            const sl = document.getElementById('qq-mobile-sl')?.value;
            const tp = document.getElementById('qq-mobile-tp')?.value;
            
            if (qty) document.getElementById('qq-qty').value = qty;
            if (sl) document.getElementById('qq-sl').value = sl;
            if (tp) document.getElementById('qq-tp').value = tp;
            
            updateQuickTradeSummary();
            executeQuickTrade();
            closeMobileQQTradeForm();
        }
        
        function setQuickTradeType(type) {
            quickQuoteTradeType = type;
            
            const buyBtn = document.getElementById('qq-btn-buy');
            const sellBtn = document.getElementById('qq-btn-sell');
            const execBtn = document.getElementById('qq-execute-btn');
            
            buyBtn.classList.toggle('active', type === 'BUY');
            sellBtn.classList.toggle('active', type === 'SELL');
            
            execBtn.className = `quick-trade-execute ${type.toLowerCase()}`;
            updateQuickTradeSummary();
        }
        
        function updateQuickTradeSummary() {
            const qty = parseFloat(document.getElementById('qq-qty').value) || 0;
            const price = parseFloat(document.getElementById('qq-trade-price').value) || 0;
            const total = qty * price;
            const balance = userProfile?.cash_balance || 10000;
            const afterTrade = quickQuoteTradeType === 'BUY' ? balance - total : balance + total;
            
            document.getElementById('qq-order-value').textContent = `$${total.toLocaleString('en-US', {minimumFractionDigits: 2})}`;
            document.getElementById('qq-after-trade').textContent = `$${afterTrade.toLocaleString('en-US', {minimumFractionDigits: 2})}`;
            
            const execBtn = document.getElementById('qq-execute-btn');
            execBtn.textContent = `${quickQuoteTradeType} ${qty} kg`;
        }
        
        // Quick Quote Modal State
        let qqTimeframe = '1D';
        let qqChartType = 'line';
        let qqIndicators = { sma: false, ema: false, bollinger: false };
        
        function setQQTimeframe(tf) {
            qqTimeframe = tf;
            document.querySelectorAll('.qq-tf-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tf === tf);
            });
            if (quickQuoteTea) {
                drawQuickQuoteChart(quickQuoteTea);
            }
        }
        
        function setQQChartType(type) {
            qqChartType = type;
            document.querySelectorAll('.qq-chart-type-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });
            if (quickQuoteTea) {
                drawQuickQuoteChart(quickQuoteTea);
            }
        }
        
        function toggleQQIndicator(ind) {
            qqIndicators[ind] = !qqIndicators[ind];
            document.querySelectorAll('.qq-indicator-btn').forEach(btn => {
                if (btn.dataset.ind === ind) {
                    btn.classList.toggle('active', qqIndicators[ind]);
                }
            });
            if (quickQuoteTea) {
                drawQuickQuoteChart(quickQuoteTea);
            }
        }
        
        function updateQQOpenPositions(symbol) {
            const container = document.getElementById('qq-open-positions');
            if (!container) return;
            
            // Get positions for this symbol
            const positions = (userProfile?.positions || []).filter(p => p.symbol === symbol && p.status === 'OPEN');
            
            if (positions.length === 0) {
                container.classList.remove('has-positions');
                container.innerHTML = '';
                return;
            }
            
            container.classList.add('has-positions');
            
            const currentPrice = quickQuoteTea?.current_price || 0;
            
            let html = '<div class="qq-positions-header">Your Open Positions</div>';
            positions.forEach(pos => {
                const entryPrice = pos.entry_price || pos.price;
                const qty = pos.quantity;
                const side = pos.type || pos.side;
                const pnl = side === 'BUY' 
                    ? (currentPrice - entryPrice) * qty 
                    : (entryPrice - currentPrice) * qty;
                const pnlClass = pnl >= 0 ? 'profit' : 'loss';
                const pnlSign = pnl >= 0 ? '+' : '';
                
                html += `
                    <div class="qq-position-row">
                        <div class="qq-position-info">
                            <span class="qq-position-side ${side.toLowerCase()}">${side}</span>
                            <div class="qq-position-details">
                                <span class="qq-position-qty">${qty} kg</span>
                                <span class="qq-position-entry">@ $${entryPrice.toFixed(2)}</span>
                            </div>
                        </div>
                        <span class="qq-position-pnl ${pnlClass}">${pnlSign}$${pnl.toFixed(2)}</span>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function updateQQTradeAnnotations() {
            const container = document.getElementById('qq-trade-annotations');
            if (!container || !quickQuoteTea || !qqChartMeta.maxPrice) return;
            
            const positions = (userProfile?.positions || []).filter(
                p => p.symbol === quickQuoteTea.symbol && p.status === 'OPEN'
            );
            
            if (positions.length === 0) {
                container.innerHTML = '';
                return;
            }
            
            const { minPrice, maxPrice, chartHeight, padding } = qqChartMeta;
            const priceRange = maxPrice - minPrice;
            
            let html = '';
            positions.forEach(pos => {
                const entryPrice = pos.entry_price || pos.price;
                const yEntry = padding.top + ((maxPrice - entryPrice) / priceRange) * chartHeight;
                
                if (yEntry >= padding.top && yEntry <= padding.top + chartHeight) {
                    html += `<div class="qq-trade-annotation entry" style="top: ${yEntry - 10}px;">Entry $${entryPrice.toFixed(2)}</div>`;
                }
                
                // Add SL/TP annotations if set
                if (pos.stop_loss) {
                    const ySL = padding.top + ((maxPrice - pos.stop_loss) / priceRange) * chartHeight;
                    if (ySL >= padding.top && ySL <= padding.top + chartHeight) {
                        html += `<div class="qq-trade-annotation sl" style="top: ${ySL - 10}px;">SL $${pos.stop_loss.toFixed(2)}</div>`;
                    }
                }
                
                if (pos.take_profit) {
                    const yTP = padding.top + ((maxPrice - pos.take_profit) / priceRange) * chartHeight;
                    if (yTP >= padding.top && yTP <= padding.top + chartHeight) {
                        html += `<div class="qq-trade-annotation tp" style="top: ${yTP - 10}px;">TP $${pos.take_profit.toFixed(2)}</div>`;
                    }
                }
            });
            
            container.innerHTML = html;
        }
        
        // Animate price change in modal
        function animateQQPriceChange(newPrice, oldPrice) {
            const priceEl = document.getElementById('qq-price');
            if (!priceEl) return;
            
            const isUp = newPrice > oldPrice;
            priceEl.classList.remove('qq-price-flash', 'qq-price-up', 'qq-price-down');
            
            // Force reflow
            void priceEl.offsetWidth;
            
            priceEl.classList.add('qq-price-flash');
            priceEl.classList.add(isUp ? 'qq-price-up' : 'qq-price-down');
            
            setTimeout(() => {
                priceEl.classList.remove('qq-price-flash', 'qq-price-up', 'qq-price-down');
            }, 500);
        }
        
        // ===== Multi-Chart Dashboard Modal =====
        let multiChartPanels = []; // Array of panel data: { id, symbol, tea }
        let multiChartNextId = 1;
        
        function openMultiChartModal() {
            const modal = document.getElementById('multi-chart-modal');
            if (!modal) return;
            
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
            
            // Initialize with one empty panel if no panels exist
            if (multiChartPanels.length === 0) {
                addMultiChart();
            } else {
                renderMultiChartPanels();
            }
        }
        
        function closeMultiChartModal() {
            const modal = document.getElementById('multi-chart-modal');
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = '';
            }
        }
        
        function addMultiChart(prefillSymbol = null) {
            if (multiChartPanels.length >= 4) {
                showToast('Maximum Charts', 'You can add up to 4 charts');
                return;
            }
            
            const panelId = multiChartNextId++;
            let tea = null;
            
            if (prefillSymbol) {
                tea = teas.find(t => t.symbol === prefillSymbol);
            }
            
            multiChartPanels.push({ id: panelId, symbol: prefillSymbol, tea: tea });
            updateMultiChartGridClass();
            renderMultiChartPanels();
        }
        
        function removeMultiChartPanel(panelId) {
            multiChartPanels = multiChartPanels.filter(p => p.id !== panelId);
            updateMultiChartGridClass();
            renderMultiChartPanels();
        }
        
        function updateMultiChartGridClass() {
            const grid = document.getElementById('multi-chart-grid');
            if (!grid) return;
            
            grid.classList.remove('single', 'double', 'triple');
            
            switch (multiChartPanels.length) {
                case 1:
                    grid.classList.add('single');
                    break;
                case 2:
                    grid.classList.add('double');
                    break;
                case 3:
                    grid.classList.add('triple');
                    break;
                // 4 panels uses default 2x2 grid
            }
        }
        
        function renderMultiChartPanels() {
            const grid = document.getElementById('multi-chart-grid');
            if (!grid) return;
            
            let html = '';
            
            multiChartPanels.forEach(panel => {
                if (panel.tea && panel.symbol) {
                    // Panel with a tea selected
                    const change = panel.tea.price_change_24h || 0;
                    const isUp = change >= 0;
                    const shortSymbol = panel.symbol.split('-')[1] || panel.symbol;
                    const origin = panel.symbol.split('-')[0] || '';
                    
                    html += `
                        <div class="mc-chart-panel" data-panel-id="${panel.id}">
                            <div class="mc-panel-header">
                                <div class="mc-panel-symbol">
                                    <span class="mc-panel-symbol-name">${origin} ${shortSymbol}</span>
                                    <span class="mc-panel-price ${isUp ? 'up' : 'down'}">$${panel.tea.current_price.toFixed(2)} (${isUp ? '+' : ''}${change.toFixed(1)}%)</span>
                                </div>
                                <div class="mc-panel-actions">
                                    <button class="mc-panel-btn trade" onclick="openQuickQuoteModal(teas.find(t => t.symbol === '${panel.symbol}'))">Trade</button>
                                    <button class="mc-panel-btn close" onclick="removeMultiChartPanel(${panel.id})">Ã—</button>
                                </div>
                            </div>
                            <div class="mc-panel-chart">
                                <canvas id="mc-chart-${panel.id}"></canvas>
                            </div>
                        </div>
                    `;
                } else {
                    // Empty panel - show tea selector
                    html += `
                        <div class="mc-chart-panel empty" data-panel-id="${panel.id}" onclick="showMultiChartTeaSelector(${panel.id}, event)">
                            <div class="mc-empty-placeholder">
                                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                                <span>Click to add chart</span>
                            </div>
                        </div>
                    `;
                }
            });
            
            grid.innerHTML = html;
            
            // Draw charts for panels with teas
            requestAnimationFrame(() => {
                multiChartPanels.forEach(panel => {
                    if (panel.tea) {
                        drawMultiChartPanel(panel.id, panel.tea);
                    }
                });
            });
        }
        
        function showMultiChartTeaSelector(panelId, event) {
            event.stopPropagation();
            
            // Remove any existing selector
            const existingSelector = document.querySelector('.mc-tea-selector');
            if (existingSelector) existingSelector.remove();
            
            // Create tea selector dropdown
            const selector = document.createElement('div');
            selector.className = 'mc-tea-selector';
            
            let options = '<div class="mc-tea-selector-header">Select a Tea</div><div class="mc-tea-selector-list">';
            
            teas.slice(0, 15).forEach(tea => {
                const shortSymbol = tea.symbol.split('-')[1] || tea.symbol;
                const origin = tea.symbol.split('-')[0] || '';
                const isUp = (tea.price_change_24h || 0) >= 0;
                
                options += `
                    <div class="mc-tea-option" onclick="selectMultiChartTea(${panelId}, '${tea.symbol}')">
                        <span class="mc-tea-option-symbol">${origin} ${shortSymbol}</span>
                        <span class="mc-tea-option-price ${isUp ? 'up' : 'down'}">$${tea.current_price.toFixed(2)}</span>
                    </div>
                `;
            });
            
            options += '</div>';
            selector.innerHTML = options;
            
            // Add to grid
            document.getElementById('multi-chart-grid').appendChild(selector);
            
            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', function closeSelector(e) {
                    if (!selector.contains(e.target)) {
                        selector.remove();
                        document.removeEventListener('click', closeSelector);
                    }
                });
            }, 10);
        }
        
        function selectMultiChartTea(panelId, symbol) {
            const panel = multiChartPanels.find(p => p.id === panelId);
            if (!panel) return;
            
            const tea = teas.find(t => t.symbol === symbol);
            panel.symbol = symbol;
            panel.tea = tea;
            
            // Remove selector
            const selector = document.querySelector('.mc-tea-selector');
            if (selector) selector.remove();
            
            renderMultiChartPanels();
        }
        
        function drawMultiChartPanel(panelId, tea) {
            const canvas = document.getElementById(`mc-chart-${panelId}`);
            if (!canvas || !tea) return;
            
            const ctx = canvas.getContext('2d');
            const rect = canvas.parentElement.getBoundingClientRect();
            if (rect.width <= 0 || rect.height <= 0) return;
            
            const dpr = window.devicePixelRatio || 1;
            const w = rect.width;
            const h = rect.height;
            
            canvas.width = w * dpr;
            canvas.height = h * dpr;
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            ctx.scale(dpr, dpr);
            
            const price = tea.current_price || 3.5;
            const change = tea.price_change_24h || 0;
            const isUp = change >= 0;
            
            // Get historical data from UNIFIED CACHE (DB-first)
            let fullHistory = getPriceHistorySync(tea.symbol, 'tea');
            if (!fullHistory || fullHistory.length === 0) {
                fullHistory = generateTeaHistory(tea);
            }
            if (!fullHistory || fullHistory.length === 0) return;
            
            const historySlice = fullHistory.slice(-48);
            
            const padding = { top: 15, right: 50, bottom: 20, left: 40 };
            const chartWidth = w - padding.left - padding.right;
            const chartHeight = h - padding.top - padding.bottom;
            
            const minPrice = Math.min(...historySlice.map(d => d.low)) * 0.998;
            const maxPrice = Math.max(...historySlice.map(d => d.high)) * 1.002;
            
            // Clear
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, w, h);
            
            // Draw simple grid
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 3; i++) {
                const y = padding.top + (chartHeight / 3) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(w - padding.right, y);
                ctx.stroke();
            }
            
            // Draw line chart with gradient
            const gradient = ctx.createLinearGradient(0, padding.top, 0, h - padding.bottom);
            gradient.addColorStop(0, isUp ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.beginPath();
            ctx.moveTo(padding.left, h - padding.bottom);
            
            historySlice.forEach((candle, i) => {
                const x = padding.left + (i / (historySlice.length - 1)) * chartWidth;
                const y = padding.top + ((maxPrice - candle.close) / (maxPrice - minPrice)) * chartHeight;
                ctx.lineTo(x, y);
            });
            
            ctx.lineTo(padding.left + chartWidth, h - padding.bottom);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Draw line
            ctx.beginPath();
            historySlice.forEach((candle, i) => {
                const x = padding.left + (i / (historySlice.length - 1)) * chartWidth;
                const y = padding.top + ((maxPrice - candle.close) / (maxPrice - minPrice)) * chartHeight;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.strokeStyle = isUp ? '#10b981' : '#ef4444';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Current price label
            const currentY = padding.top + ((maxPrice - price) / (maxPrice - minPrice)) * chartHeight;
            ctx.fillStyle = isUp ? '#10b981' : '#ef4444';
            ctx.fillRect(w - padding.right + 2, currentY - 7, 45, 14);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 9px JetBrains Mono';
            ctx.textAlign = 'left';
            ctx.fillText(`$${price.toFixed(2)}`, w - padding.right + 5, currentY + 3);
        }
        
        // Add keyboard shortcut to open multi-chart
        document.addEventListener('keydown', (e) => {
            if (e.key === 'm' && e.ctrlKey) {
                e.preventDefault();
                openMultiChartModal();
            }
        });
        
        // Store Quick Quote chart metadata for crosshair
        let qqChartMeta = {
            data: [],
            padding: { top: 20, right: 70, bottom: 30, left: 60 },
            minPrice: 0,
            maxPrice: 0,
            chartWidth: 0,
            chartHeight: 0,
            w: 0,
            h: 0
        };
        
        function drawQuickQuoteChart(tea) {
            const canvas = document.getElementById('qq-chart');
            if (!canvas || !tea) return;
            
            const ctx = canvas.getContext('2d');
            const rect = canvas.parentElement.getBoundingClientRect();
            if (rect.width <= 0 || rect.height <= 0) return;
            
            // High DPI support
            const dpr = window.devicePixelRatio || 1;
            const w = rect.width;
            const h = rect.height;
            
            canvas.width = w * dpr;
            canvas.height = h * dpr;
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            ctx.scale(dpr, dpr);
            
            const price = tea.current_price || 3.5;
            const change = tea.price_change_24h || 0;
            const isUp = change >= 0;
            
            // Get historical data from UNIFIED CACHE (DB-first)
            let fullHistory = getPriceHistorySync(tea.symbol, 'tea');
            if (!fullHistory || fullHistory.length === 0) {
                fullHistory = generateTeaHistory(tea);
            }
            if (!fullHistory || fullHistory.length === 0) return;
            
            // Include extra points for indicator warm-up (BB needs 20 periods)
            const warmupPeriod = 25;
            
            // Sample data based on selected timeframe with warm-up buffer
            let historySlice;
            switch (qqTimeframe) {
                case '1H':
                    historySlice = fullHistory.slice(-(12 + warmupPeriod)); // Extra for BB warm-up
                    break;
                case '1D':
                    historySlice = fullHistory.slice(-(24 + warmupPeriod)); // Extra for BB warm-up
                    break;
                case '1W':
                    // Sample every 4h with warm-up
                    historySlice = fullHistory.slice(-(168 + warmupPeriod * 4)).filter((_, i) => i % 4 === 0);
                    break;
                case '1M':
                    // Daily candles with warm-up
                    historySlice = fullHistory.slice(-(720 + warmupPeriod * 24)).filter((_, i) => i % 24 === 0);
                    break;
                default:
                    historySlice = fullHistory.slice(-(48 + warmupPeriod));
            }
            if (historySlice.length === 0) historySlice = fullHistory.slice(-50);
            
            const padding = { top: 20, right: 70, bottom: 30, left: 60 };
            const chartWidth = w - padding.left - padding.right;
            const chartHeight = h - padding.top - padding.bottom;
            
            const allHighs = historySlice.map(d => d.high);
            const allLows = historySlice.map(d => d.low);
            const minPrice = Math.min(...allLows) * 0.998;
            const maxPrice = Math.max(...allHighs) * 1.002;
            
            // Store metadata for crosshair and annotations
            qqChartMeta = { data: historySlice, padding, minPrice, maxPrice, chartWidth, chartHeight, w, h };
            
            // Clear
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, w, h);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight / 4) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(w - padding.right, y);
                ctx.stroke();
                
                const priceLabel = maxPrice - ((maxPrice - minPrice) / 4) * i;
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.font = '10px JetBrains Mono';
                ctx.textAlign = 'right';
                ctx.fillText(`$${priceLabel.toFixed(2)}`, padding.left - 8, y + 3);
            }
            
            // Draw time labels
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = '9px JetBrains Mono';
            ctx.textAlign = 'center';
            const timeLabels = [0, Math.floor(historySlice.length / 4), Math.floor(historySlice.length / 2), Math.floor(3 * historySlice.length / 4), historySlice.length - 1];
            timeLabels.forEach(i => {
                if (historySlice[i]) {
                    const x = padding.left + (i / (historySlice.length - 1)) * chartWidth;
                    const date = historySlice[i].date;
                    const label = qqTimeframe === '1M' 
                        ? date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short' })
                        : date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                    ctx.fillText(label, x, h - 8);
                }
            });
            
            // Calculate indicators if enabled
            const closes = historySlice.map(d => d.close);
            
            // Draw Bollinger Bands first (behind everything)
            if (qqIndicators.bollinger && closes.length >= 20) {
                const period = 20;
                const mult = 2;
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
                ctx.lineWidth = 1;
                
                const upper = [], lower = [], middle = [];
                for (let i = period - 1; i < closes.length; i++) {
                    const slice = closes.slice(i - period + 1, i + 1);
                    const sma = slice.reduce((a, b) => a + b, 0) / period;
                    const variance = slice.reduce((sum, val) => sum + Math.pow(val - sma, 2), 0) / period;
                    const stdDev = Math.sqrt(variance);
                    upper.push(sma + mult * stdDev);
                    lower.push(sma - mult * stdDev);
                    middle.push(sma);
                }
                
                // Draw bands with fill
                ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                ctx.beginPath();
                for (let i = 0; i < upper.length; i++) {
                    const x = padding.left + ((i + period - 1) / (historySlice.length - 1)) * chartWidth;
                    const y = padding.top + ((maxPrice - upper[i]) / (maxPrice - minPrice)) * chartHeight;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                for (let i = lower.length - 1; i >= 0; i--) {
                    const x = padding.left + ((i + period - 1) / (historySlice.length - 1)) * chartWidth;
                    const y = padding.top + ((maxPrice - lower[i]) / (maxPrice - minPrice)) * chartHeight;
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                // Draw middle line
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.7)';
                middle.forEach((val, i) => {
                    const x = padding.left + ((i + period - 1) / (historySlice.length - 1)) * chartWidth;
                    const y = padding.top + ((maxPrice - val) / (maxPrice - minPrice)) * chartHeight;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }
            
            // Draw chart based on type
            if (qqChartType === 'candle') {
                // Draw candlesticks
                const candleWidth = Math.max(3, Math.min(10, (chartWidth / historySlice.length) * 0.7));
                
                historySlice.forEach((candle, i) => {
                    const x = padding.left + (i / (historySlice.length - 1)) * chartWidth;
                    const candleUp = candle.close >= candle.open;
                    const color = candleUp ? '#10b981' : '#ef4444';
                    
                    const openY = padding.top + ((maxPrice - candle.open) / (maxPrice - minPrice)) * chartHeight;
                    const closeY = padding.top + ((maxPrice - candle.close) / (maxPrice - minPrice)) * chartHeight;
                    const highY = padding.top + ((maxPrice - candle.high) / (maxPrice - minPrice)) * chartHeight;
                    const lowY = padding.top + ((maxPrice - candle.low) / (maxPrice - minPrice)) * chartHeight;
                    
                    // Wick
                    ctx.beginPath();
                    ctx.moveTo(x, highY);
                    ctx.lineTo(x, lowY);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Body
                    const bodyTop = Math.min(openY, closeY);
                    const bodyHeight = Math.max(1, Math.abs(closeY - openY));
                    ctx.fillStyle = color;
                    ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                });
            } else {
                // Draw line chart with gradient fill
                const gradient = ctx.createLinearGradient(0, padding.top, 0, h - padding.bottom);
                gradient.addColorStop(0, isUp ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.beginPath();
                ctx.moveTo(padding.left, h - padding.bottom);
                
                historySlice.forEach((candle, i) => {
                    const x = padding.left + (i / (historySlice.length - 1)) * chartWidth;
                    const y = padding.top + ((maxPrice - candle.close) / (maxPrice - minPrice)) * chartHeight;
                    ctx.lineTo(x, y);
                });
                
                ctx.lineTo(padding.left + chartWidth, h - padding.bottom);
                ctx.closePath();
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Draw line
                ctx.beginPath();
                historySlice.forEach((candle, i) => {
                    const x = padding.left + (i / (historySlice.length - 1)) * chartWidth;
                    const y = padding.top + ((maxPrice - candle.close) / (maxPrice - minPrice)) * chartHeight;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.strokeStyle = isUp ? '#10b981' : '#ef4444';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Draw SMA if enabled
            if (qqIndicators.sma && closes.length >= 10) {
                const sma10 = [];
                for (let i = 9; i < closes.length; i++) {
                    const avg = closes.slice(i - 9, i + 1).reduce((a, b) => a + b, 0) / 10;
                    sma10.push(avg);
                }
                
                ctx.beginPath();
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 1.5;
                sma10.forEach((val, i) => {
                    const x = padding.left + ((i + 9) / (historySlice.length - 1)) * chartWidth;
                    const y = padding.top + ((maxPrice - val) / (maxPrice - minPrice)) * chartHeight;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }
            
            // Draw EMA if enabled
            if (qqIndicators.ema && closes.length >= 10) {
                const multiplier = 2 / (10 + 1);
                const ema = [closes[0]];
                for (let i = 1; i < closes.length; i++) {
                    ema.push((closes[i] - ema[i - 1]) * multiplier + ema[i - 1]);
                }
                
                ctx.beginPath();
                ctx.strokeStyle = '#8b5cf6';
                ctx.lineWidth = 1.5;
                ema.forEach((val, i) => {
                    const x = padding.left + (i / (historySlice.length - 1)) * chartWidth;
                    const y = padding.top + ((maxPrice - val) / (maxPrice - minPrice)) * chartHeight;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }
            
            // Draw current price line
            const currentY = padding.top + ((maxPrice - price) / (maxPrice - minPrice)) * chartHeight;
            ctx.beginPath();
            ctx.setLineDash([4, 4]);
            ctx.moveTo(padding.left, currentY);
            ctx.lineTo(w - padding.right, currentY);
            ctx.strokeStyle = isUp ? '#10b981' : '#ef4444';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Current price label
            ctx.fillStyle = isUp ? '#10b981' : '#ef4444';
            ctx.fillRect(w - padding.right + 2, currentY - 8, 55, 16);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px JetBrains Mono';
            ctx.textAlign = 'left';
            ctx.fillText(`$${price.toFixed(2)}`, w - padding.right + 6, currentY + 3);
            
            // Update trade annotations after chart is drawn
            updateQQTradeAnnotations();
            
            // Setup crosshair events (once)
            if (!canvas.dataset.crosshairSetup) {
                canvas.dataset.crosshairSetup = 'true';
                setupQQChartCrosshair(canvas);
            }
        }
        
        function setupQQChartCrosshair(canvas) {
            const crosshair = document.getElementById('qq-crosshair');
            const tooltip = document.getElementById('qq-tooltip');
            if (!crosshair || !tooltip) return;
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const { data, padding, minPrice, maxPrice, chartWidth, chartHeight, w, h } = qqChartMeta;
                if (!data || data.length === 0) return;
                
                // Check if within chart area
                if (x < padding.left || x > w - padding.right || y < padding.top || y > h - padding.bottom) {
                    crosshair.style.display = 'none';
                    tooltip.style.display = 'none';
                    return;
                }
                
                // Find nearest candle
                const normalizedX = (x - padding.left) / chartWidth;
                const candleIndex = Math.round(normalizedX * (data.length - 1));
                const candle = data[Math.max(0, Math.min(data.length - 1, candleIndex))];
                if (!candle) return;
                
                // Calculate candle X position
                const candleX = padding.left + (candleIndex / (data.length - 1)) * chartWidth;
                
                // Show crosshair
                crosshair.style.display = 'block';
                crosshair.querySelector('.qq-crosshair-v').style.left = candleX + 'px';
                crosshair.querySelector('.qq-crosshair-h').style.top = y + 'px';
                
                // Calculate price at cursor Y
                const priceAtY = maxPrice - ((y - padding.top) / chartHeight) * (maxPrice - minPrice);
                
                // Format tooltip
                const candleUp = candle.close >= candle.open;
                const changeAmount = candle.close - candle.open;
                const changePercent = (changeAmount / candle.open * 100).toFixed(2);
                const timeStr = candle.date.toLocaleString('en-GB', { 
                    weekday: 'short', 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                tooltip.innerHTML = `
                    <div class="qq-tooltip-row">
                        <span class="qq-tooltip-label">Time</span>
                        <span class="qq-tooltip-value">${timeStr}</span>
                    </div>
                    <div class="qq-tooltip-row">
                        <span class="qq-tooltip-label">Open</span>
                        <span class="qq-tooltip-value">$${candle.open.toFixed(2)}</span>
                    </div>
                    <div class="qq-tooltip-row">
                        <span class="qq-tooltip-label">High</span>
                        <span class="qq-tooltip-value">$${candle.high.toFixed(2)}</span>
                    </div>
                    <div class="qq-tooltip-row">
                        <span class="qq-tooltip-label">Low</span>
                        <span class="qq-tooltip-value">$${candle.low.toFixed(2)}</span>
                    </div>
                    <div class="qq-tooltip-row">
                        <span class="qq-tooltip-label">Close</span>
                        <span class="qq-tooltip-value ${candleUp ? 'up' : 'down'}">$${candle.close.toFixed(2)}</span>
                    </div>
                    <div class="qq-tooltip-row">
                        <span class="qq-tooltip-label">Change</span>
                        <span class="qq-tooltip-value ${candleUp ? 'up' : 'down'}">${candleUp ? '+' : ''}${changePercent}%</span>
                    </div>
                `;
                
                // Position tooltip
                tooltip.style.display = 'block';
                let tooltipX = candleX + 15;
                let tooltipY = y - 60;
                
                // Keep tooltip in bounds
                if (tooltipX + 150 > w) tooltipX = candleX - 165;
                if (tooltipY < 10) tooltipY = y + 15;
                
                tooltip.style.left = tooltipX + 'px';
                tooltip.style.top = tooltipY + 'px';
            });
            
            canvas.addEventListener('mouseleave', () => {
                crosshair.style.display = 'none';
                tooltip.style.display = 'none';
            });
        }
        
        async function executeQuickTrade() {
            if (!currentUser) {
                closeQuickQuoteModal();
                openAuthModal();
                return;
            }
            
            if (!quickQuoteTea) return;
            
            const qty = parseFloat(document.getElementById('qq-qty').value) || 0;
            const price = quickQuoteTea.current_price;
            const total = qty * price;
            const slInput = document.getElementById('qq-sl');
            const tpInput = document.getElementById('qq-tp');
            const stopLoss = slInput?.value ? parseFloat(slInput.value) : null;
            const takeProfit = tpInput?.value ? parseFloat(tpInput.value) : null;
            
            if (qty <= 0) {
                showToast('Invalid quantity', 'Please enter a valid quantity', true);
                return;
            }
            
            // Check balance for BUY
            if (quickQuoteTradeType === 'BUY' && total > (userProfile?.cash_balance || 0)) {
                showToast('Insufficient Balance', 'You don\'t have enough funds', true);
                return;
            }
            
            const execBtn = document.getElementById('qq-execute-btn');
            execBtn.disabled = true;
            execBtn.textContent = 'Executing...';
            
            try {
                if (quickQuoteTradeType === 'BUY') {
                    // Deduct from balance
                    const { error: balanceError } = await supabaseClient
                        .from('profiles')
                        .update({ cash_balance: (userProfile?.cash_balance || 0) - total })
                        .eq('id', currentUser.id);
                    
                    if (balanceError) throw balanceError;
                    
                    // Update local balance
                    if (userProfile) userProfile.cash_balance -= total;
                }
                
                // Record the trade
                const tradeData = {
                    user_id: currentUser.id,
                    tea_id: quickQuoteTea.id,
                    side: quickQuoteTradeType,
                    quantity: qty,
                    price: price,
                    total_value: total
                };
                
                const { data: trade, error: tradeError } = await supabaseClient
                    .from('trades')
                    .insert(tradeData)
                    .select()
                    .single();
                
                if (tradeError) throw tradeError;
                
                // Update positions
                const existingPos = positions.find(p => p.tea_id === quickQuoteTea.id);
                
                if (quickQuoteTradeType === 'BUY') {
                    if (existingPos) {
                        // Average up
                        const newQty = existingPos.quantity + qty;
                        const newAvgPrice = ((existingPos.avg_entry_price * existingPos.quantity) + (price * qty)) / newQty;
                        
                        await supabaseClient
                            .from('positions')
                            .update({ quantity: newQty, avg_entry_price: newAvgPrice })
                            .eq('id', existingPos.id);
                        
                        existingPos.quantity = newQty;
                        existingPos.avg_entry_price = newAvgPrice;
                    } else {
                        const posData = {
                            user_id: currentUser.id,
                            tea_id: quickQuoteTea.id,
                            quantity: qty,
                            avg_entry_price: price
                        };
                        
                        const { data: newPos } = await supabaseClient
                            .from('positions')
                            .insert(posData)
                            .select()
                            .single();
                        
                        if (newPos) positions.push(newPos);
                    }
                } else {
                    // SELL - reduce position
                    if (existingPos && existingPos.quantity >= qty) {
                        const newQty = existingPos.quantity - qty;
                        
                        if (newQty <= 0) {
                            await supabaseClient
                                .from('positions')
                                .delete()
                                .eq('id', existingPos.id);
                            
                            positions = positions.filter(p => p.id !== existingPos.id);
                        } else {
                            await supabaseClient
                                .from('positions')
                                .update({ quantity: newQty })
                                .eq('id', existingPos.id);
                            
                            existingPos.quantity = newQty;
                        }
                        
                        // Credit balance
                        const { error: creditError } = await supabaseClient
                            .from('profiles')
                            .update({ cash_balance: (userProfile?.cash_balance || 0) + total })
                            .eq('id', currentUser.id);
                        
                        if (!creditError && userProfile) {
                            userProfile.cash_balance += total;
                        }
                    }
                }
                
                // Refresh trades and UI
                await loadUserTrades();
                updatePortfolioDisplay();
                
                showToast(`${quickQuoteTradeType} Order Filled`, `${qty} kg of ${quickQuoteTea.name || quickQuoteTea.symbol} @ $${price.toFixed(2)}`);
                closeQuickQuoteModal();
                
            } catch (error) {
                console.error('Trade error:', error);
                showToast('Trade Failed', error.message || 'Failed to execute trade', true);
                execBtn.disabled = false;
                execBtn.textContent = `${quickQuoteTradeType} ${qty} kg`;
            }
        }
        
        // Close modal on escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeQuickQuoteModal();
            }
        });
        
        // Close modal on overlay click
        document.getElementById('quick-quote-modal')?.addEventListener('click', (e) => {
            if (e.target.classList.contains('quick-quote-modal-overlay')) {
                closeQuickQuoteModal();
            }
        });

        // Start market depth animation
        setInterval(updateMarketDepth, 2000);
        setInterval(updateMacroIndicators, 5000);
        setInterval(updateQuoteBoard, 3000);

        // Initialize command line
        initCommandLine();

        // =============================================
        // LEADERBOARD FUNCTIONS
        // =============================================

        async function loadLeaderboard() {
            try {
                const { data, error } = await supabaseClient
                    .from('leaderboard')
                    .select('*')
                    .order('total_value', { ascending: false })
                    .limit(10);

                if (error) throw error;
                
                if (data && data.length > 0) {
                    updateLeaderboardDisplay(data);
                }
            } catch (error) {
                console.error('Failed to load leaderboard:', error);
            }
        }

        function updateLeaderboardDisplay(leaders) {
            const listEl = document.getElementById('leaderboard-list');
            let html = '';

            leaders.forEach((user, index) => {
                const rank = index + 1;
                let rankClass = '';
                if (rank === 1) rankClass = 'gold';
                else if (rank === 2) rankClass = 'silver';
                else if (rank === 3) rankClass = 'bronze';

                const returnPct = user.return_pct || 0;
                const returnClass = returnPct >= 0 ? 'up' : 'down';
                const returnSign = returnPct >= 0 ? '+' : '';

                html += `
                    <div class="leaderboard-item">
                        <div class="leaderboard-rank ${rankClass}">${rank}</div>
                        <div class="leaderboard-name">${user.username}</div>
                        <div class="leaderboard-return ${returnClass}">${returnSign}${returnPct.toFixed(1)}%</div>
                    </div>
                `;
            });

            if (html) {
                listEl.innerHTML = html;
            }
        }

        // =============================================
        // PAIRS TRADING SYSTEM
        // =============================================

        let teaPairs = [];
        let currentPairTrade = null;
        let selectedLeverage = 1;
        let previousPairRatios = {};

        // Regional Index Pairs (calculated from tea averages)
        const indexPairs = [
            { id: 'idx-kenya-india', base_symbol: 'KENYA', quote_symbol: 'INDIA', isIndex: true },
            { id: 'idx-india-ceylon', base_symbol: 'INDIA', quote_symbol: 'CEYLON', isIndex: true },
            { id: 'idx-africa-asia', base_symbol: 'AFRICA', quote_symbol: 'ASIA', isIndex: true },
            { id: 'idx-kenya-ceylon', base_symbol: 'KENYA', quote_symbol: 'CEYLON', isIndex: true },
            { id: 'idx-china-india', base_symbol: 'CHINA', quote_symbol: 'INDIA', isIndex: true },
        ];

        async function loadTeaPairs() {
            try {
                const { data, error } = await supabaseClient
                    .from('tea_pairs')
                    .select('*');
                
                if (error) throw error;
                teaPairs = data;
                updatePairsTable();
            } catch (error) {
                console.error('Failed to load pairs:', error);
            }
        }
        
        // Get index price from regional indexes
        function getIndexPrice(indexSymbol) {
            const indexes = calculateRegionalIndexes();
            const idx = indexes.find(i => i.symbol === indexSymbol);
            return idx ? { price: idx.price, previousPrice: idx.previousPrice, name: idx.name, color: idx.color } : null;
        }

        function setMarketView(view) {
            const singlesView = document.getElementById('singles-view');
            const pairsView = document.getElementById('pairs-view');
            const toggleSingles = document.getElementById('toggle-singles');
            const togglePairs = document.getElementById('toggle-pairs');
            const gradeFilters = document.getElementById('grade-filters');

            if (view === 'singles') {
                singlesView.style.display = 'block';
                pairsView.style.display = 'none';
                toggleSingles.classList.add('active');
                togglePairs.classList.remove('active');
                gradeFilters.style.display = 'flex';
            } else {
                singlesView.style.display = 'none';
                pairsView.style.display = 'block';
                toggleSingles.classList.remove('active');
                togglePairs.classList.add('active');
                gradeFilters.style.display = 'none';
                if (teaPairs.length === 0) loadTeaPairs();
                updatePairsTable();
            }
        }

        // Pairs table sorting state
        let pairsSortColumn = 'pair';
        let pairsSortDirection = 'asc';

        function sortPairsTable(column) {
            if (pairsSortColumn === column) {
                pairsSortDirection = pairsSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                pairsSortColumn = column;
                pairsSortDirection = 'asc';
            }
            
            // Update header classes
            document.querySelectorAll('#pairs-table th.sortable').forEach(th => {
                th.classList.remove('asc', 'desc');
                if (th.dataset.sort === column) {
                    th.classList.add(pairsSortDirection);
                }
            });
            
            updatePairsTable();
        }

        function updatePairsTable() {
            const tbody = document.getElementById('pairs-table-body');
            if (!tbody || !teas.length) return;

            // Build tea price map
            const teaMap = {};
            teas.forEach(tea => teaMap[tea.symbol] = tea);
            
            // Get regional indexes
            const indexes = calculateRegionalIndexes();
            const indexMap = {};
            indexes.forEach(idx => indexMap[idx.symbol] = idx);

            // Build data array from regular tea pairs
            const pairsData = (teaPairs || []).map(pair => {
                const baseTea = teaMap[pair.base_symbol];
                const quoteTea = teaMap[pair.quote_symbol];

                if (!baseTea || !quoteTea) return null;

                const basePrice = baseTea.current_price;
                const quotePrice = quoteTea.current_price;
                const ratio = quotePrice > 0 ? basePrice / quotePrice : 0;
                const pairKey = `${pair.base_symbol}/${pair.quote_symbol}`;

                // Calculate change from previous ratio
                let changePct = 0;
                let changeStr = 'â€”';
                let changeClass = '';
                let flashClass = '';

                if (previousPairRatios[pairKey] !== undefined) {
                    const prevRatio = previousPairRatios[pairKey];
                    if (prevRatio !== ratio) {
                        changePct = ((ratio - prevRatio) / prevRatio) * 100;
                        changeStr = `${changePct >= 0 ? '+' : ''}${changePct.toFixed(2)}%`;
                        changeClass = changePct > 0 ? 'up' : 'down';
                        flashClass = changePct > 0 ? 'flash-up' : 'flash-down';
                    }
                }
                previousPairRatios[pairKey] = ratio;

                // Spread (price difference)
                const spread = Math.abs(basePrice - quotePrice);

                // Format symbols for display
                const baseShort = pair.base_symbol.split('-')[1] || pair.base_symbol;
                const quoteShort = pair.quote_symbol.split('-')[1] || pair.quote_symbol;

                return {
                    pair, basePrice, quotePrice, ratio, changePct, changeStr, changeClass, flashClass, spread, baseShort, quoteShort, isIndex: false
                };
            }).filter(Boolean);
            
            // Add index pairs
            indexPairs.forEach(pair => {
                const baseIdx = indexMap[pair.base_symbol];
                const quoteIdx = indexMap[pair.quote_symbol];
                
                if (!baseIdx || !quoteIdx || baseIdx.price === 0 || quoteIdx.price === 0) return;
                
                const basePrice = baseIdx.price;
                const quotePrice = quoteIdx.price;
                const ratio = quotePrice > 0 ? basePrice / quotePrice : 0;
                const pairKey = `${pair.base_symbol}/${pair.quote_symbol}`;
                
                let changePct = 0;
                let changeStr = 'â€”';
                let changeClass = '';
                let flashClass = '';

                if (previousPairRatios[pairKey] !== undefined) {
                    const prevRatio = previousPairRatios[pairKey];
                    if (prevRatio !== ratio) {
                        changePct = ((ratio - prevRatio) / prevRatio) * 100;
                        changeStr = `${changePct >= 0 ? '+' : ''}${changePct.toFixed(2)}%`;
                        changeClass = changePct > 0 ? 'up' : 'down';
                        flashClass = changePct > 0 ? 'flash-up' : 'flash-down';
                    }
                }
                previousPairRatios[pairKey] = ratio;

                const spread = Math.abs(basePrice - quotePrice);
                
                pairsData.push({
                    pair,
                    basePrice,
                    quotePrice,
                    ratio,
                    changePct,
                    changeStr,
                    changeClass,
                    flashClass,
                    spread,
                    baseShort: pair.base_symbol,
                    quoteShort: pair.quote_symbol,
                    isIndex: true,
                    baseColor: baseIdx.color,
                    quoteColor: quoteIdx.color
                });
            });

            // Sort the data
            pairsData.sort((a, b) => {
                // Index pairs always at top
                if (a.isIndex !== b.isIndex) {
                    return a.isIndex ? -1 : 1;
                }
                
                let valA, valB;
                switch (pairsSortColumn) {
                    case 'pair':
                        valA = `${a.baseShort}/${a.quoteShort}`;
                        valB = `${b.baseShort}/${b.quoteShort}`;
                        break;
                    case 'base':
                        valA = a.basePrice;
                        valB = b.basePrice;
                        break;
                    case 'quote':
                        valA = a.quotePrice;
                        valB = b.quotePrice;
                        break;
                    case 'ratio':
                        valA = a.ratio;
                        valB = b.ratio;
                        break;
                    case 'change':
                        valA = a.changePct;
                        valB = b.changePct;
                        break;
                    case 'spread':
                        valA = a.spread;
                        valB = b.spread;
                        break;
                    default:
                        valA = a.baseShort;
                        valB = b.baseShort;
                }
                
                if (typeof valA === 'string') {
                    return pairsSortDirection === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                }
                return pairsSortDirection === 'asc' ? valA - valB : valB - valA;
            });

            // Render sorted data
            tbody.innerHTML = pairsData.map(data => {
                const baseStyle = data.isIndex ? `style="color: ${data.baseColor}; font-weight: 700;"` : '';
                const quoteStyle = data.isIndex ? `style="color: ${data.quoteColor}; font-weight: 700;"` : '';
                const rowClass = data.isIndex ? 'index-pair-row' : '';
                const clickHandler = data.isIndex ? 
                    `onclick="openIndexPairModal('${data.pair.id}', 'LONG')"` : 
                    `onclick="openPairsModal('${data.pair.id}', 'LONG')"`;
                
                return `
                    <tr ${clickHandler} style="cursor: pointer;" class="${rowClass}">
                        <td>
                            <span class="pair-symbol">
                                <span class="base" ${baseStyle}>${data.baseShort}</span>/<span class="quote" ${quoteStyle}>${data.quoteShort}</span>
                                ${data.isIndex ? '<span class="index-badge">IDX</span>' : ''}
                            </span>
                        </td>
                        <td class="pairs-price ${data.flashClass}">$${data.basePrice.toFixed(2)}</td>
                        <td class="pairs-price">$${data.quotePrice.toFixed(2)}</td>
                        <td><span class="pair-ratio">${data.ratio.toFixed(4)}</span></td>
                        <td class="${data.changeClass}">${data.changeStr}</td>
                        <td>$${data.spread.toFixed(2)}</td>
                    </tr>
                `;
            }).join('');
        }
        
        // Open modal for index pairs
        function openIndexPairModal(pairId, side) {
            if (!currentUser) {
                showToast('Login Required', 'Please sign in to trade pairs', true);
                return;
            }
            
            const pair = indexPairs.find(p => p.id === pairId);
            if (!pair) {
                showToast('Error', 'Index pair not found', true);
                return;
            }
            
            const baseIdx = getIndexPrice(pair.base_symbol);
            const quoteIdx = getIndexPrice(pair.quote_symbol);
            
            if (!baseIdx || !quoteIdx) {
                showToast('Error', 'Index prices not available', true);
                return;
            }
            
            const ratio = baseIdx.price / quoteIdx.price;
            
            currentPairTrade = {
                pairId,
                pair,
                side,
                baseTea: { current_price: baseIdx.price, symbol: pair.base_symbol },
                quoteTea: { current_price: quoteIdx.price, symbol: pair.quote_symbol },
                ratio,
                baseShort: pair.base_symbol,
                quoteShort: pair.quote_symbol,
                isIndex: true
            };

            // Update modal display
            document.getElementById('pairs-modal-title').textContent = `${side} ${pair.base_symbol}/${pair.quote_symbol}`;
            document.getElementById('modal-pair-display').innerHTML = 
                `<span class="base" style="color: ${baseIdx.color};">${pair.base_symbol}</span>/<span class="quote" style="color: ${quoteIdx.color};">${pair.quote_symbol}</span>`;
            document.getElementById('modal-ratio-display').textContent = `Ratio: ${ratio.toFixed(4)}`;

            setLeverage(1);
            setPairsSide(side);
            updatePairsSummary();
            document.getElementById('pairs-modal').classList.add('active');
        }

        function openPairsModal(pairId, side) {
            if (!currentUser) {
                showToast('Login Required', 'Please sign in to trade pairs', true);
                return;
            }

            const pair = teaPairs.find(p => p.id === pairId);
            if (!pair) {
                showToast('Error', 'Pair not found. Please refresh the page.', true);
                return;
            }

            const teaMap = {};
            teas.forEach(tea => teaMap[tea.symbol] = tea);

            const baseTea = teaMap[pair.base_symbol];
            const quoteTea = teaMap[pair.quote_symbol];
            if (!baseTea || !quoteTea) {
                showToast('Error', 'Tea prices not available. Please refresh.', true);
                return;
            }

            const ratio = baseTea.current_price / quoteTea.current_price;
            const baseShort = pair.base_symbol.split('-')[1] || pair.base_symbol;
            const quoteShort = pair.quote_symbol.split('-')[1] || pair.quote_symbol;

            currentPairTrade = {
                pairId,
                pair,
                side,
                baseTea,
                quoteTea,
                ratio,
                baseShort,
                quoteShort
            };

            // Update modal display
            document.getElementById('pairs-modal-title').textContent = `${side} ${baseShort}/${quoteShort}`;
            document.getElementById('modal-pair-display').innerHTML = 
                `<span class="base">${baseShort}</span>/<span class="quote">${quoteShort}</span>`;
            document.getElementById('modal-ratio-display').textContent = `Ratio: ${ratio.toFixed(4)}`;

            // Reset leverage
            setLeverage(1);

            // Set initial side
            setPairsSide(side);

            updatePairsSummary();
            document.getElementById('pairs-modal').classList.add('active');
        }

        function closePairsModal() {
            document.getElementById('pairs-modal').classList.remove('active');
            currentPairTrade = null;
        }

        function setLeverage(lev) {
            selectedLeverage = lev;
            document.querySelectorAll('.leverage-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.leverage) === lev);
            });
            updatePairsSummary();
        }

        function setPairsSide(side) {
            if (!currentPairTrade) return;
            
            currentPairTrade.side = side;
            
            // Update side buttons
            document.querySelectorAll('.side-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.side === side);
            });
            
            // Update modal title and confirm button
            const { baseShort, quoteShort } = currentPairTrade;
            document.getElementById('pairs-modal-title').textContent = `${side} ${baseShort}/${quoteShort}`;
            
            const confirmBtn = document.getElementById('pairs-confirm-btn');
            confirmBtn.className = `confirm-btn ${side.toLowerCase()}`;
            confirmBtn.textContent = `${side} ${baseShort}/${quoteShort}`;
        }

        function updatePairsSummary() {
            const amount = parseFloat(document.getElementById('pairs-amount').value) || 0;
            const exposure = amount * selectedLeverage;

            document.getElementById('summary-size').textContent = `$${amount.toFixed(2)}`;
            document.getElementById('summary-leverage').textContent = `${selectedLeverage}x`;
            document.getElementById('summary-exposure').textContent = `$${exposure.toFixed(2)}`;
            document.getElementById('summary-ratio').textContent = currentPairTrade ? 
                currentPairTrade.ratio.toFixed(4) : 'â€”';
        }

        async function executePairTrade() {
            if (!currentPairTrade || !currentUser) {
                showToast('Error', 'Trade data not available. Please try again.', true);
                return;
            }

            if (!currentPairTrade.side) {
                showToast('Error', 'Invalid trade direction. Please reopen the trade modal.', true);
                return;
            }

            const amount = parseFloat(document.getElementById('pairs-amount').value);
            if (!amount || amount < 10) {
                showToast('Invalid Amount', 'Minimum position size is $10', true);
                return;
            }

            if (amount > userProfile.cash_balance) {
                showToast('Insufficient Funds', 'Not enough cash balance', true);
                return;
            }

            try {
                // Deduct cash (margin)
                const newBalance = userProfile.cash_balance - amount;
                const { error: balanceError } = await supabaseClient
                    .from('profiles')
                    .update({ cash_balance: newBalance })
                    .eq('id', currentUser.id);
                if (balanceError) throw balanceError;

                // Record pair trade
                const { error: tradeError } = await supabaseClient
                    .from('trades')
                    .insert({
                        user_id: currentUser.id,
                        tea_id: currentPairTrade.baseTea.id,
                        side: currentPairTrade.side === 'LONG' ? 'BUY' : 'SELL',
                        quantity: amount, // Using quantity as the margin amount
                        price: currentPairTrade.ratio,
                        total_value: amount * selectedLeverage,
                        pair_id: currentPairTrade.pairId,
                        leverage: selectedLeverage,
                        is_pair_trade: true
                    });
                if (tradeError) throw tradeError;

                userProfile.cash_balance = newBalance;
                
                // Save values before closing modal (which nulls currentPairTrade)
                const tradeInfo = {
                    side: currentPairTrade.side,
                    baseShort: currentPairTrade.baseShort,
                    quoteShort: currentPairTrade.quoteShort,
                    ratio: currentPairTrade.ratio
                };
                
                closePairsModal();
                
                const exposure = amount * selectedLeverage;
                showToast('Pair Trade Executed!', 
                    `${tradeInfo.side} ${tradeInfo.baseShort}/${tradeInfo.quoteShort} @ ${tradeInfo.ratio.toFixed(4)} with ${selectedLeverage}x leverage ($${exposure.toFixed(2)} exposure)`);

                await loadUserTrades();
                await loadPositions();
                updatePortfolioDisplay();

            } catch (error) {
                console.error('Pair trade failed:', error);
                showToast('Trade Failed', error.message, true);
            }
        }

        // =============================================
        // UTILITY FUNCTIONS
        // =============================================

        function showToast(title, message, isError = false) {
            const toast = document.getElementById('trade-toast');
            document.getElementById('toast-title').textContent = title;
            document.getElementById('toast-message').textContent = message;
            toast.classList.toggle('error', isError);
            toast.classList.add('visible');

            setTimeout(() => {
                toast.classList.remove('visible');
            }, 4000);
        }

        // Refresh data periodically
        setInterval(async () => {
            await loadTeas();
            if (currentUser) {
                await loadPositions();
                updatePortfolioDisplay();
            }
            await loadLeaderboard();
        }, 30000); // Every 30 seconds

    </script>
    
    <!-- Chat Notification Badge (fixed position - must be outside main-grid) -->
    <div class="chat-notification-badge" id="chat-notification-badge" onclick="scrollToChatSection()">
        <svg fill="currentColor" viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>
        <span class="chat-notification-count" id="chat-notification-count">0</span>
    </div>
</body>
</html>
